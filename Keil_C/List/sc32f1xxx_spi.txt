; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_spi.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_spi.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_spi.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_spi.c]
                          THUMB

                          AREA ||i.SPI_ClearFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearFlag PROC
;;;998     */
;;;999    void SPI_ClearFlag ( SPI_TypeDef* SPIx, uint32_t SPI_FLAG )
000000  b289              UXTH     r1,r1
;;;1000   {
;;;1001   #if defined(SC32f10xx)||defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;1002       /* Check the parameters */
;;;1003       assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;1004       /* Clear the flags */
;;;1005       SPIx->SPI_STS = ( uint16_t ) SPI_FLAG;
000002  6041              STR      r1,[r0,#4]
;;;1006   #elif defined(SC32f15xx)||defined(SC32R601)
;;;1007     /* Check the parameters */
;;;1008     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1009     /* Clear the flags */
;;;1010     if( SPIx == SPI0 )
;;;1011   	{
;;;1012     SPIx->SPI_STS = (uint16_t)SPI_FLAG;
;;;1013   	}
;;;1014   	 if( SPIx == SPI1 )
;;;1015   	{		
;;;1016   		if(SPI_FLAG == SPI_Flag_TXEIF)
;;;1017   		{
;;;1018   			SPIx->SPI_STS = (uint16_t)SPI_FLAG<<4;
;;;1019   		}
;;;1020   		else
;;;1021   		{
;;;1022   		 SPIx->SPI_STS = (uint16_t)SPI_FLAG;
;;;1023   		}
;;;1024   	}
;;;1025   #endif
;;;1026   }
000004  4770              BX       lr
;;;1027   
                          ENDP


                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=2

                  SPI_Cmd PROC
;;;290     */
;;;291    void SPI_Cmd ( SPI_TypeDef* SPIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;292    {
000002  d004              BEQ      |L2.14|
;;;293    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;294        /* Check the parameters */
;;;295        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;296        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;297        if ( NewState != DISABLE )
;;;298        {
;;;299            /* Enable the SPI TX Function */
;;;300            SPIx->SPI_CON |= SPI_CON_SPEN;
;;;301        }
;;;302        else
;;;303        {
;;;304            /* Disable the SPI TX Function */
;;;305            SPIx->SPI_CON &= ( uint16_t ) ~SPI_CON_SPEN;
;;;306        }
;;;307    #elif defined(SC32f15xx)||defined(SC32R601)
;;;308        /* Check the parameters */
;;;309        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;310        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;311        if ( SPIx == SPI0 )
;;;312        {
;;;313            if ( NewState != DISABLE )
;;;314            {
;;;315                /* Enable the SPI TX Function */
;;;316                SPIx->SPI_CON |= SPI0_CON_SPEN;
;;;317            }
;;;318            else
;;;319            {
;;;320                /* Disable the SPI TX Function */
;;;321                SPIx->SPI_CON &= ( uint16_t ) ~SPI0_CON_SPEN;
;;;322            }
;;;323        }
;;;324        if ( SPIx == SPI1 )
;;;325        {
;;;326            if ( NewState != DISABLE )
;;;327            {
;;;328                /* Enable the SPI TX Function */
;;;329                SPIx->SPI_CON |= SPI1_TWI1_CON_QTWEN;
;;;330            }
;;;331            else
;;;332            {
;;;333                /* Disable the SPI TX Function */
;;;334                SPIx->SPI_CON &= ( uint16_t ) ~SPI1_TWI1_CON_QTWEN;
;;;335            }
;;;336        }
;;;337    #elif defined(SC32R803)
;;;338        /* Check the parameters */
;;;339        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;340        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;341    
;;;342    		if ( NewState != DISABLE )
;;;343    		{
;;;344    				/* Enable the SPI TX Function */
;;;345    				SPIx->SPI_CON |= TWI_QSPIx_CON_QTWEN;
000004  6801              LDR      r1,[r0,#0]
000006  2280              MOVS     r2,#0x80
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;346    		}
;;;347    		else
;;;348    		{
;;;349    				/* Disable the SPI TX Function */
;;;350    			SPIx->SPI_CON  &= ( uint16_t ) ~TWI_QSPIx_CON_QTWEN;
;;;351    		}		
;;;352    #endif
;;;353    }
00000c  4770              BX       lr
                  |L2.14|
00000e  6801              LDR      r1,[r0,#0]            ;350
000010  4a01              LDR      r2,|L2.24|
000012  4011              ANDS     r1,r1,r2              ;350
000014  6001              STR      r1,[r0,#0]            ;350
000016  4770              BX       lr
;;;354    
                          ENDP

                  |L2.24|
                          DCD      0x0000ff7f

                          AREA ||i.SPI_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_DMACmd PROC
;;;1046    */
;;;1047   void SPI_DMACmd ( SPI_TypeDef* SPIx, uint16_t SPI_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;1048   {
000002  d003              BEQ      |L3.12|
;;;1049       /* Check the parameters */
;;;1050       assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;1051       assert_param ( IS_SPI_DMAREQ ( SPI_DMAReq ) );
;;;1052       assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;1053       if ( NewState != DISABLE )
;;;1054       {
;;;1055           /* Enable the selected SPI DMA requests */
;;;1056           SPIx->SPI_IDE |= SPI_DMAReq;
000004  6902              LDR      r2,[r0,#0x10]
000006  430a              ORRS     r2,r2,r1
000008  6102              STR      r2,[r0,#0x10]
;;;1057       }
;;;1058       else
;;;1059       {
;;;1060           /* Disable the selected SPI DMA requests */
;;;1061           SPIx->SPI_IDE &= ( uint16_t ) ~SPI_DMAReq;
;;;1062       }
;;;1063   }
00000a  4770              BX       lr
                  |L3.12|
00000c  6902              LDR      r2,[r0,#0x10]         ;1061
00000e  43c9              MVNS     r1,r1                 ;1061
000010  b289              UXTH     r1,r1                 ;1061
000012  400a              ANDS     r2,r2,r1              ;1061
000014  6102              STR      r2,[r0,#0x10]         ;1061
000016  4770              BX       lr
;;;1064   
                          ENDP


                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=1

                  SPI_DataSizeConfig PROC
;;;443      */
;;;444    void SPI_DataSizeConfig ( SPI_TypeDef* SPIx, SPI_DataSize_TypeDef SPI_DataSize )
000000  6802              LDR      r2,[r0,#0]
;;;445    {
;;;446    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;447        /* Check the parameters */
;;;448        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;449        assert_param ( IS_SPI_DATASIZE ( SPI_DataSize ) );
;;;450    
;;;451        /* Clear SPMD bit */
;;;452        SPIx->SPI_CON &= ( uint16_t ) ~SPI_CON_SPMD;
;;;453        /* Set new SPMD bit value */
;;;454        SPIx->SPI_CON |= SPI_DataSize;
;;;455    #elif defined(SC32f15xx)||defined(SC32R601)
;;;456        /* Check the parameters */
;;;457        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;458        assert_param ( IS_SPI_DATASIZE ( SPI_DataSize ) );
;;;459        if ( SPIx == SPI0 )
;;;460        {
;;;461            /* Clear SPMD bit */
;;;462            SPIx->SPI_CON &= ( uint16_t ) ~SPI0_CON_SPMD;
;;;463            /* Set new SPMD bit value */
;;;464            SPIx->SPI_CON |= SPI_DataSize;
;;;465        }
;;;466        if ( SPIx == SPI1 )
;;;467        {
;;;468            /* Clear SPMD bit */
;;;469            SPIx->SPI_CON &= ( uint16_t ) ~SPI1_CON_SPMD;
;;;470            /* Set new SPMD bit value */
;;;471            SPIx->SPI_CON |= SPI_DataSize << 16;
;;;472        }
;;;473    #elif defined(SC32R803)
;;;474        /* Check the parameters */
;;;475        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;476        assert_param ( IS_SPI_DATASIZE ( SPI_DataSize ) );
;;;477    
;;;478    		/* Clear SPMD bit */
;;;479    		 SPIx->SPI_CON &= ( uint32_t ) ~TWI_QSPIx_CON_DWIDTH;
000002  2303              MOVS     r3,#3
000004  071b              LSLS     r3,r3,#28
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;480    		/* Set new SPMD bit value */
;;;481    		 SPIx->SPI_CON |= SPI_DataSize ;		
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;482    #endif
;;;483    }
000010  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.SPI_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_DeInit PROC
;;;52      */
;;;53     void SPI_DeInit ( SPI_TypeDef* SPIx )
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55         /* Check the parameters */
;;;56         assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;57         if ( SPIx == SPI0 )
000004  4818              LDR      r0,|L5.104|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L5.28|
;;;58         {
;;;59     #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)||defined(SC32f15xx)||defined(SC32R601)
;;;60             /* Enable SPI0 reset state */
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_SPI0, ENABLE );
;;;62             /* Release SPI0 from reset state */
;;;63             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_SPI0, DISABLE );
;;;64     #elif defined(SC32R803)
;;;65             /* Enable TWI0 reset state */
;;;66             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;67             /* Disable TWI0 reset state */
;;;68             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI0, DISABLE );			
000012  2100              MOVS     r1,#0
000014  2010              MOVS     r0,#0x10
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
00001a  e00a              B        |L5.50|
                  |L5.28|
;;;69     #endif
;;;70         }
;;;71         else if ( SPIx == SPI1 )
00001c  4813              LDR      r0,|L5.108|
00001e  4284              CMP      r4,r0
000020  d107              BNE      |L5.50|
;;;72         {
;;;73     #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;74             /* Clear SPI1 Register */
;;;75             SPIx->SPI_CON  = ( uint16_t ) 0x00000000;
;;;76             SPIx->SPI_DATA = ( uint16_t ) 0x00000000;
;;;77             SPIx->SPI_IDE  = ( uint16_t ) 0x00000000;
;;;78             SPIx->SPI_STS  = ( uint16_t ) 0x000000FF;
;;;79     #elif defined(SC32R803)
;;;80             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI1, ENABLE );
000022  2101              MOVS     r1,#1
000024  2010              MOVS     r0,#0x10
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;81             /* Disable TWI0 reset state */
;;;82             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI1, DISABLE );
00002a  2100              MOVS     r1,#0
00002c  2010              MOVS     r0,#0x10
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.50|
;;;83     #elif defined(SC32f15xx)||defined(SC32R601)
;;;84             /* Enable SPI1 reset state */
;;;85             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_SPI1_TWI1, ENABLE );
;;;86             /* Release SPI1 from reset state */
;;;87             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_SPI1_TWI1, DISABLE );
;;;88     #endif
;;;89         }
;;;90     #if defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;91         if ( SPIx == SPI2 )
;;;92         {
;;;93             /* Clear SPI1 Register */
;;;94             SPIx->SPI_CON  = ( uint16_t ) 0x00000000;
;;;95             SPIx->SPI_DATA = ( uint16_t ) 0x00000000;
;;;96             SPIx->SPI_IDE  = ( uint16_t ) 0x00000000;
;;;97             SPIx->SPI_STS  = ( uint16_t ) 0x000000FF;
;;;98         }
;;;99     #elif defined(SC32R803)
;;;100        if ( SPIx == SPI2 )
000032  480d              LDR      r0,|L5.104|
000034  3020              ADDS     r0,r0,#0x20
000036  4284              CMP      r4,r0
000038  d108              BNE      |L5.76|
;;;101        {
;;;102            /* Enable TWI0 reset state */
;;;103            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI2, ENABLE );
00003a  2101              MOVS     r1,#1
00003c  2020              MOVS     r0,#0x20
00003e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;104            /* Disable TWI0 reset state */
;;;105            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI2, DISABLE );
000042  2100              MOVS     r1,#0
000044  2020              MOVS     r0,#0x20
000046  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L5.74|
;;;106        }
;;;107        else if ( SPIx == SPI3 )
;;;108        {
;;;109            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI3, ENABLE );
;;;110            /* Disable TWI0 reset state */
;;;111            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI3, DISABLE );
;;;112        }		
;;;113    #endif
;;;114    
;;;115    }
00004a  bd10              POP      {r4,pc}
                  |L5.76|
00004c  4807              LDR      r0,|L5.108|
00004e  3020              ADDS     r0,r0,#0x20           ;107
000050  4284              CMP      r4,r0                 ;107
000052  d1fa              BNE      |L5.74|
000054  2101              MOVS     r1,#1                 ;109
000056  2020              MOVS     r0,#0x20              ;109
000058  f7fffffe          BL       RCC_APB1PeriphResetCmd
00005c  2100              MOVS     r1,#0                 ;111
00005e  2020              MOVS     r0,#0x20              ;111
000060  f7fffffe          BL       RCC_APB1PeriphResetCmd
000064  bd10              POP      {r4,pc}
;;;116    
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      0x40020040
                  |L5.108|
                          DCD      0x40021040

                          AREA ||i.SPI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetFlagStatus PROC
;;;918     */
;;;919    FlagStatus SPI_GetFlagStatus ( SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG )
000000  4602              MOV      r2,r0
;;;920    {
;;;921    #if defined(SC32f10xx)||defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;922        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;923        /* Check the parameters */
;;;924        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;925        assert_param ( IS_SPI_FLAG ( SPI_FLAG ) );
;;;926    
;;;927        if ( ( SPIx->SPI_STS & SPI_FLAG ) != ( uint16_t ) RESET )
000004  6852              LDR      r2,[r2,#4]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L6.12|
;;;928        {
;;;929            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;930        }
;;;931        else
;;;932        {
;;;933            bitstatus = RESET;
;;;934        }
;;;935        return bitstatus;
;;;936    #elif defined(SC32f15xx)||defined(SC32R601)
;;;937        ITStatus bitstatus = RESET;
;;;938        /* Check the parameters */
;;;939        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;940        assert_param ( IS_SPI_FLAG ( SPI_FLAG ) );
;;;941        if ( SPIx == SPI0 )
;;;942        {
;;;943            if ( ( SPIx->SPI_STS & SPI_FLAG ) != ( uint16_t ) RESET )
;;;944            {
;;;945                bitstatus = SET;
;;;946            }
;;;947            else
;;;948            {
;;;949                bitstatus = RESET;
;;;950            }
;;;951        }
;;;952        if ( SPIx == SPI1 )
;;;953        {
;;;954            if ( SPI_FLAG == SPI_Flag_TXEIF )
;;;955            {
;;;956                if ( ( SPIx->SPI_STS & ( SPI_FLAG << 4 ) ) != ( uint16_t ) RESET )
;;;957                {
;;;958                    bitstatus = SET;
;;;959                }
;;;960                else
;;;961                {
;;;962                    bitstatus = RESET;
;;;963                }
;;;964            }
;;;965            if ( ( SPIx->SPI_STS & SPI_FLAG ) != ( uint16_t ) RESET )
;;;966            {
;;;967                bitstatus = SET;
;;;968            }
;;;969            else
;;;970            {
;;;971                bitstatus = RESET;
;;;972            }
;;;973        }
;;;974        return bitstatus;
;;;975    #endif
;;;976    }
00000c  4770              BX       lr
;;;977    
                          ENDP


                          AREA ||i.SPI_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_ITConfig PROC
;;;874     */
;;;875    void SPI_ITConfig ( SPI_TypeDef* SPIx, uint16_t SPI_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;876    {
000002  d003              BEQ      |L7.12|
;;;877    
;;;878        /* Check the parameters */
;;;879        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;880        assert_param ( IS_SPI_IT ( SPI_IT ) );
;;;881        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;882        if ( NewState != DISABLE )
;;;883        {
;;;884            /* Enable the Interrupt sources */
;;;885            SPIx->SPI_IDE |= SPI_IT;
000004  6902              LDR      r2,[r0,#0x10]
000006  430a              ORRS     r2,r2,r1
000008  6102              STR      r2,[r0,#0x10]
;;;886        }
;;;887        else
;;;888        {
;;;889            /* Disable the Interrupt sources */
;;;890            SPIx->SPI_IDE &= ( uint16_t ) ~SPI_IT;
;;;891        }
;;;892    
;;;893    }
00000a  4770              BX       lr
                  |L7.12|
00000c  6902              LDR      r2,[r0,#0x10]         ;890
00000e  43c9              MVNS     r1,r1                 ;890
000010  b289              UXTH     r1,r1                 ;890
000012  400a              ANDS     r2,r2,r1              ;890
000014  6102              STR      r2,[r0,#0x10]         ;890
000016  4770              BX       lr
;;;894    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;146     */
;;;147    void SPI_Init ( SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;148    {
;;;149    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;150        uint32_t tmpreg;
;;;151        /* Check the parameters */
;;;152        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;153        assert_param ( IS_SPI_Mode ( SPI_InitStruct->SPI_Mode ) );
;;;154        assert_param ( IS_SPI_DATASIZE ( SPI_InitStruct->SPI_DataSize ) );
;;;155        assert_param ( IS_SPI_CPHA ( SPI_InitStruct->SPI_CPHA ) );
;;;156        assert_param ( IS_SPI_CPOL ( SPI_InitStruct->SPI_CPOL ) );
;;;157        assert_param ( IS_SPI_PRESCALER ( SPI_InitStruct->SPI_Prescaler ) );
;;;158        assert_param ( IS_SPI_FIRSTBIT ( SPI_InitStruct->SPI_FirstBit ) );
;;;159    
;;;160        /*---------------------------- SPIx SPI_CON Configuration ------------------------*/
;;;161        /* Get the SPIx SPI_CON value */
;;;162        tmpreg = SPIx->SPI_CON;
;;;163        /* Clear MSTR, SPMD, DORD, CPOL, SPR bits */
;;;164        tmpreg &= ( uint32_t ) ~ ( SPI_CON_MSTR | SPI_CON_SPMD | SPI_CON_DORD |
;;;165                                   SPI_CON_CPHA | SPI_CON_CPOL | SPI_CON_SPR );
;;;166        /* Configure SPIx: mode, data size, first transmitted bit,clock predivision , CPOL and CPHA */
;;;167        /* Set MSTR bits to SPI_Mode value */
;;;168        /* Set SPMD bit according to SPI_DataSize value */
;;;169        /* Set DORD bit according to SPI_FirstBit value */
;;;170        /* Set CPOL bit according to SPI_CPOL value */
;;;171        /* Set CPHA bit according to SPI_CPHA value */
;;;172        /* Set SPR according to SPI_Prescaler value */
;;;173        tmpreg |= ( uint32_t ) ( SPI_InitStruct->SPI_Mode | SPI_InitStruct->SPI_DataSize |
;;;174                                 SPI_InitStruct->SPI_FirstBit | SPI_InitStruct->SPI_CPHA |
;;;175                                 SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_Prescaler );
;;;176        /* Write to SPIx SPI_CON */
;;;177        SPIx->SPI_CON = tmpreg;
;;;178    #elif defined(SC32f15xx)||defined(SC32R601)
;;;179        uint32_t tmpreg;
;;;180        /* Check the parameters */
;;;181        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;182        assert_param ( IS_SPI_Mode ( SPI_InitStruct->SPI_Mode ) );
;;;183        assert_param ( IS_SPI_DATASIZE ( SPI_InitStruct->SPI_DataSize ) );
;;;184        assert_param ( IS_SPI_CPHA ( SPI_InitStruct->SPI_CPHA ) );
;;;185        assert_param ( IS_SPI_CPOL ( SPI_InitStruct->SPI_CPOL ) );
;;;186        assert_param ( IS_SPI_PRESCALER ( SPI_InitStruct->SPI_Prescaler ) );
;;;187        assert_param ( IS_SPI_FIRSTBIT ( SPI_InitStruct->SPI_FirstBit ) );
;;;188    
;;;189        /*---------------------------- SPIx SPI0_CON Configuration ------------------------*/
;;;190        if ( SPIx == SPI0 )
;;;191        {
;;;192            /* Get the SPIx SPI0_CON value */
;;;193            tmpreg = SPIx->SPI_CON;
;;;194            /* Clear MSTR, SPMD, DORD, CPOL, SPR bits */
;;;195            tmpreg &= ( uint32_t ) ~ ( SPI0_CON_MSTR | SPI0_CON_SPMD | SPI0_CON_DORD |
;;;196                                       SPI0_CON_CPHA | SPI0_CON_CPOL | SPI0_CON_SPR );
;;;197            /* Configure SPIx: mode, data size, first transmitted bit,clock predivision , CPOL and CPHA */
;;;198            /* Set MSTR bits to SPI0_Mode value */
;;;199            /* Set SPMD bit according to SPI0_DataSize value */
;;;200            /* Set DORD bit according to SPI0_FirstBit value */
;;;201            /* Set CPOL bit according to SPI0_CPOL value */
;;;202            /* Set CPHA bit according to SPI0_CPHA value */
;;;203            /* Set SPR according to SPI0_Prescaler value */
;;;204            tmpreg |= ( uint32_t ) ( SPI_InitStruct->SPI_Mode | SPI_InitStruct->SPI_DataSize |
;;;205                                     SPI_InitStruct->SPI_FirstBit | SPI_InitStruct->SPI_CPHA |
;;;206                                     SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_Prescaler );
;;;207    
;;;208            /* Write to SPIx SPI0_CON */
;;;209    
;;;210            SPIx->SPI_CON = tmpreg;
;;;211        }
;;;212        if ( SPIx == SPI1 )
;;;213        {
;;;214            /* Get the SPIx SPI0_CON value */
;;;215            tmpreg = SPIx->SPI_CON;
;;;216            /* Clear MSTR, SPMD, DORD, CPOL, SPR bits */
;;;217            tmpreg &= ( uint32_t ) ~ ( SPI1_CON_MSTR | SPI1_CON_SPMD | SPI1_CON_DORD |
;;;218                                       SPI1_CON_CPHA | SPI1_CON_CPOL | SPI1_TWI1_CON_QTWCK );
;;;219            /* Configure SPIx: mode, data size, first transmitted bit,clock predivision , CPOL and CPHA */
;;;220            /* Set MSTR bits to SPI0_Mode value */
;;;221            /* Set SPMD bit according to SPI1_DataSize value */
;;;222            /* Set DORD bit according to SPI1_FirstBit value */
;;;223            /* Set CPOL bit according to SPI1_CPOL value */
;;;224            /* Set CPHA bit according to SPI1_CPHA value */
;;;225            /* Set SPR according to SPI0_Prescaler value */
;;;226            tmpreg |= ( uint32_t ) ( ( ( SPI_InitStruct->SPI_Mode | SPI_InitStruct->SPI_DataSize |
;;;227                                         SPI_InitStruct->SPI_FirstBit | SPI_InitStruct->SPI_CPHA |
;;;228                                         SPI_InitStruct->SPI_CPOL ) ) << 16 ) | ( 0x01 << SPI1_TWI1_CON_MODE_Pos ) |
;;;229                      SPI_InitStruct->SPI_Prescaler;
;;;230    
;;;231            /* Write to SPIx SPI0_CON */
;;;232    
;;;233            SPIx->SPI_CON = tmpreg;
;;;234    
;;;235        }
;;;236    #elif defined(SC32R803)
;;;237        uint32_t tmpreg;
;;;238        /* Check the parameters */
;;;239        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;240        assert_param ( IS_SPI_Mode ( SPI_InitStruct->SPI_Mode ) );
;;;241        assert_param ( IS_SPI_DATASIZE ( SPI_InitStruct->SPI_DataSize ) );
;;;242        assert_param ( IS_SPI_CPHA ( SPI_InitStruct->SPI_CPHA ) );
;;;243        assert_param ( IS_SPI_CPOL ( SPI_InitStruct->SPI_CPOL ) );
;;;244        assert_param ( IS_SPI_PRESCALER ( SPI_InitStruct->SPI_Prescaler ) );
;;;245        assert_param ( IS_SPI_FIRSTBIT ( SPI_InitStruct->SPI_FirstBit ) );
;;;246    
;;;247        /*---------------------------- SPIx SPI0_CON Configuration ------------------------*/
;;;248    		/* Get the SPIx SPI0_CON value */
;;;249    		tmpreg = SPIx->SPI_CON;
000002  6802              LDR      r2,[r0,#0]
;;;250    		/* Clear MSTR, SPMD, DORD, CPOL, SPR bits */
;;;251    		tmpreg &= ( uint32_t ) ~ ( TWI_QSPIx_CON_SMSTR | TWI_QSPIx_CON_DWIDTH | TWI_QSPIx_CON_DORD |
000004  4b09              LDR      r3,|L8.44|
000006  401a              ANDS     r2,r2,r3
;;;252    															 TWI_QSPIx_CON_CPHA | TWI_QSPIx_CON_CPOL | TWI_QSPIx_CON_QTWCK|TWI_QSPIx_CON_MODE );
;;;253    		/* Configure SPIx: mode, data size, first transmitted bit,clock predivision , CPOL and CPHA */
;;;254    		/* Set MSTR bits to SPI0_Mode value */
;;;255    		/* Set SPMD bit according to SPI1_DataSize value */
;;;256    		/* Set DORD bit according to SPI1_FirstBit value */
;;;257    		/* Set CPOL bit according to SPI1_CPOL value */
;;;258    		/* Set CPHA bit according to SPI1_CPHA value */
;;;259    		/* Set SPR according to SPI0_Prescaler value */
;;;260    		tmpreg |= ( uint32_t ) ( SPI_InitStruct->SPI_Mode | SPI_InitStruct->SPI_DataSize |
000008  684c              LDR      r4,[r1,#4]
00000a  680b              LDR      r3,[r1,#0]
00000c  688d              LDR      r5,[r1,#8]
00000e  4323              ORRS     r3,r3,r4
000010  690c              LDR      r4,[r1,#0x10]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  6949              LDR      r1,[r1,#0x14]
00001a  4323              ORRS     r3,r3,r4
00001c  430b              ORRS     r3,r3,r1
00001e  2101              MOVS     r1,#1
000020  4313              ORRS     r3,r3,r2
000022  0589              LSLS     r1,r1,#22
000024  430b              ORRS     r3,r3,r1
;;;261    																 SPI_InitStruct->SPI_FirstBit | SPI_InitStruct->SPI_CPHA |
;;;262    																 SPI_InitStruct->SPI_CPOL )  | ( 0x01 << TWI_QSPIx_CON_MODE_Pos ) |
;;;263    						                   	SPI_InitStruct->SPI_Prescaler;
;;;264    
;;;265    		/* Write to SPIx SPI0_CON */
;;;266    
;;;267    		SPIx->SPI_CON  = tmpreg;
000026  6003              STR      r3,[r0,#0]
;;;268    
;;;269     
;;;270    		
;;;271    		
;;;272    #endif
;;;273    }
000028  bd30              POP      {r4,r5,pc}
;;;274    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0xcf22f0ff

                          AREA ||i.SPI_PinRemapConfig||, CODE, READONLY, ALIGN=2

                  SPI_PinRemapConfig PROC
;;;772     */
;;;773    void SPI_PinRemapConfig ( SPI_TypeDef* SPIx, SPI_PinRemap_TypeDef SPI_PinRemap )
000000  6802              LDR      r2,[r0,#0]
;;;774    {
;;;775    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;776        uint32_t tmpreg ;
;;;777        /* Check the parameters */
;;;778        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;779        if ( SPIx == SPI0 )
;;;780        {
;;;781            assert_param ( IS_SPI_LIST1_PINREMAP ( SPI_PinRemap ) );
;;;782        }
;;;783        else
;;;784        {
;;;785            assert_param ( IS_SPI_LIST2_PINREMAP ( SPI_PinRemap ) );
;;;786        }
;;;787    
;;;788        tmpreg = SPIx->SPI_CON;
;;;789    
;;;790        tmpreg &= ( uint32_t ) ( ~SPI_CON_SPOS );
;;;791    
;;;792        tmpreg |= SPI_PinRemap;
;;;793    
;;;794        SPIx->SPI_CON = tmpreg;
;;;795    
;;;796    
;;;797    #elif defined(SC32f15xx)||defined(SC32R601)
;;;798        uint32_t tmpreg ;
;;;799        /* Check the parameters */
;;;800        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;801        assert_param ( IS_SPI_LIST_PINREMAP ( SPI_PinRemap ) );
;;;802    
;;;803    
;;;804        tmpreg = SPIx->SPI_CON;
;;;805        if ( SPIx == SPI0 )
;;;806        {
;;;807            tmpreg &= ( uint32_t ) ( ~SPI0_CON_SPOS );
;;;808        }
;;;809    
;;;810        if ( SPIx == SPI1 )
;;;811        {
;;;812            tmpreg &= ( uint32_t ) ( ~SPI1_TWI1_CON_SPOS );
;;;813        }
;;;814        tmpreg |= SPI_PinRemap;
;;;815    
;;;816        SPIx->SPI_CON = tmpreg;
;;;817    #elif defined(SC32R803)
;;;818        uint32_t tmpreg ;
;;;819        /* Check the parameters */
;;;820        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;821        assert_param ( IS_SPI_LIST_PINREMAP ( SPI_PinRemap ) );
;;;822    
;;;823    
;;;824        tmpreg = SPIx->SPI_CON;
;;;825    
;;;826         if (( SPIx == SPI2 )||( SPIx == SPI3 ))
000002  4b06              LDR      r3,|L9.28|
000004  4298              CMP      r0,r3
000006  d002              BEQ      |L9.14|
000008  4b05              LDR      r3,|L9.32|
00000a  4298              CMP      r0,r3
00000c  d102              BNE      |L9.20|
                  |L9.14|
;;;827        {
;;;828            tmpreg &= ( uint32_t ) ( ~TWI_QSPIx_CON_SPOS );
00000e  2303              MOVS     r3,#3
000010  035b              LSLS     r3,r3,#13
000012  439a              BICS     r2,r2,r3
                  |L9.20|
;;;829        }
;;;830        tmpreg |= SPI_PinRemap;
000014  430a              ORRS     r2,r2,r1
;;;831    
;;;832        SPIx->SPI_CON = tmpreg;		
000016  6002              STR      r2,[r0,#0]
;;;833    #endif
;;;834    }
000018  4770              BX       lr
;;;835    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40020060
                  |L9.32|
                          DCD      0x40021060

                          AREA ||i.SPI_ReceiveData||, CODE, READONLY, ALIGN=1

                  SPI_ReceiveData PROC
;;;728     */
;;;729    uint32_t SPI_ReceiveData ( SPI_TypeDef* SPIx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;730    {
;;;731        /* Check the parameters */
;;;732        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;733        return ( uint32_t ) SPIx->SPI_DATA;
;;;734    }
000002  4770              BX       lr
;;;735    
                          ENDP


                          AREA ||i.SPI_ReceiveDataFIFO||, CODE, READONLY, ALIGN=2

                  SPI_ReceiveDataFIFO PROC
;;;610     */
;;;611    void SPI_ReceiveDataFIFO ( SPI_TypeDef* SPIx, uint32_t* Data, uint16_t length )
000000  b530              PUSH     {r4,r5,lr}
;;;612    {
;;;613    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;614        uint16_t tmpNum;
;;;615        /* Check the parameters */
;;;616        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;617        /* ReceiveData 16Bit Data */
;;;618        if ( SPIx->SPI_CON & SPI_CON_SPMD )
;;;619        {
;;;620            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;621            {
;;;622               ( * ( ( uint16_t* ) Data + tmpNum ) ) = ( uint16_t ) SPIx->SPI_DATA;
;;;623            }
;;;624        }
;;;625        /* Transmit 8 Bit Data */
;;;626        else
;;;627        {
;;;628            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;629            {
;;;630                ( * ( ( uint8_t* ) Data + tmpNum ) ) = ( uint8_t ) SPIx->SPI_DATA;
;;;631            }
;;;632        }
;;;633    #elif defined(SC32f15xx)||defined(SC32R601)
;;;634        uint16_t tmpNum;
;;;635        /* Check the parameters */
;;;636        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;637        /* ReceiveData 16Bit Data */
;;;638        if ( SPIx == SPI0 )
;;;639        {
;;;640            if ( SPIx->SPI_CON & SPI0_CON_SPMD )
;;;641            {
;;;642                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;643                {
;;;644                 ( * ( ( uint16_t* ) Data + tmpNum ) ) = ( uint16_t ) SPIx->SPI_DATA;
;;;645                }
;;;646            }
;;;647            /* Transmit 8 Bit Data */
;;;648            else
;;;649            {
;;;650                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;651                {
;;;652                    ( * ( ( uint8_t* ) Data + tmpNum ) ) = ( uint8_t ) SPIx->SPI_DATA;
;;;653                }
;;;654            }
;;;655        }
;;;656    #elif defined(SC32R803)
;;;657        uint16_t tmpNum;
;;;658        /* Check the parameters */
;;;659        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;660        /* ReceiveData 16Bit Data */
;;;661        if (( SPIx == SPI0 )||( SPIx == SPI1 ))
000002  4b19              LDR      r3,|L11.104|
000004  4298              CMP      r0,r3
000006  d002              BEQ      |L11.14|
000008  4b18              LDR      r3,|L11.108|
00000a  4298              CMP      r0,r3
00000c  d110              BNE      |L11.48|
                  |L11.14|
;;;662        {
;;;663    				if ( ( SPIx->SPI_CON & TWI_QSPIx_CON_DWIDTH)>=SPI_DataSize_24B)
00000e  6803              LDR      r3,[r0,#0]
000010  2403              MOVS     r4,#3
000012  0724              LSLS     r4,r4,#28
000014  4023              ANDS     r3,r3,r4
000016  2401              MOVS     r4,#1
000018  0764              LSLS     r4,r4,#29
00001a  42a3              CMP      r3,r4
00001c  d309              BCC      |L11.50|
;;;664    				{
;;;665    						for ( tmpNum = 0; tmpNum < length; tmpNum++ )
00001e  2300              MOVS     r3,#0
000020  e004              B        |L11.44|
                  |L11.34|
;;;666    						{
;;;667    						 ( * ( ( uint32_t* ) Data + tmpNum ) ) 	 =( uint32_t )  SPIx->SPI_DATA;
000022  68c4              LDR      r4,[r0,#0xc]
000024  009d              LSLS     r5,r3,#2
000026  514c              STR      r4,[r1,r5]
000028  1c5b              ADDS     r3,r3,#1              ;665
00002a  b29b              UXTH     r3,r3                 ;665
                  |L11.44|
00002c  4293              CMP      r3,r2                 ;665
00002e  d3f8              BCC      |L11.34|
                  |L11.48|
;;;668    						}					
;;;669    				}
;;;670            else if ( ( SPIx->SPI_CON & TWI_QSPIx_CON_DWIDTH)==SPI_DataSize_16B)
;;;671            {
;;;672                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;673                {
;;;674                   ( * ( ( uint16_t* ) Data + tmpNum ) ) = ( uint16_t ) SPIx->SPI_DATA;
;;;675                }
;;;676            }
;;;677            /* Transmit 8 Bit Data */
;;;678            else if ( ( SPIx->SPI_CON & TWI_QSPIx_CON_DWIDTH)==SPI_DataSize_8B)
;;;679            {
;;;680                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;681                {
;;;682                    ( * ( ( uint8_t* ) Data + tmpNum ) ) = ( uint8_t ) SPIx->SPI_DATA;
;;;683                }
;;;684            }
;;;685    				
;;;686    
;;;687        }		
;;;688    		
;;;689    #endif
;;;690    }
000030  bd30              POP      {r4,r5,pc}
                  |L11.50|
000032  6803              LDR      r3,[r0,#0]            ;670
000034  009b              LSLS     r3,r3,#2              ;670
000036  0f9b              LSRS     r3,r3,#30             ;670
000038  2b01              CMP      r3,#1                 ;670
00003a  d004              BEQ      |L11.70|
00003c  6803              LDR      r3,[r0,#0]            ;678
00003e  009b              LSLS     r3,r3,#2              ;678
000040  0f9b              LSRS     r3,r3,#30             ;678
000042  d1f5              BNE      |L11.48|
000044  e00d              B        |L11.98|
                  |L11.70|
000046  2300              MOVS     r3,#0                 ;672
000048  e004              B        |L11.84|
                  |L11.74|
00004a  68c4              LDR      r4,[r0,#0xc]          ;674
00004c  005d              LSLS     r5,r3,#1              ;674
00004e  534c              STRH     r4,[r1,r5]            ;674
000050  1c5b              ADDS     r3,r3,#1              ;672
000052  b29b              UXTH     r3,r3                 ;672
                  |L11.84|
000054  4293              CMP      r3,r2                 ;672
000056  d3f8              BCC      |L11.74|
000058  bd30              POP      {r4,r5,pc}
                  |L11.90|
00005a  68c4              LDR      r4,[r0,#0xc]          ;682
00005c  54cc              STRB     r4,[r1,r3]            ;682
00005e  1c5b              ADDS     r3,r3,#1              ;680
000060  b29b              UXTH     r3,r3                 ;680
                  |L11.98|
000062  4293              CMP      r3,r2                 ;680
000064  d3f9              BCC      |L11.90|
000066  bd30              POP      {r4,r5,pc}
;;;691    
                          ENDP

                  |L11.104|
                          DCD      0x40020040
                  |L11.108|
                          DCD      0x40021040

                          AREA ||i.SPI_SendData||, CODE, READONLY, ALIGN=1

                  SPI_SendData PROC
;;;705     */
;;;706    void SPI_SendData ( SPI_TypeDef* SPIx, uint32_t Data )
000000  60c1              STR      r1,[r0,#0xc]
;;;707    {
;;;708    
;;;709        /* Check the parameters */
;;;710        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;711        /* Transmit  Data */
;;;712        SPIx->SPI_DATA = Data;
;;;713    
;;;714    }
000002  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.SPI_SendDataFIFO||, CODE, READONLY, ALIGN=2

                  SPI_SendDataFIFO PROC
;;;515     */
;;;516    void SPI_SendDataFIFO ( SPI_TypeDef* SPIx, uint32_t* Data, uint16_t length )
000000  b510              PUSH     {r4,lr}
;;;517    {
;;;518    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;519        uint8_t tmpNum;
;;;520        /* Check the parameters */
;;;521        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;522        /* Transmit 16Bit Data */
;;;523        if ( SPIx->SPI_CON & SPI_CON_SPMD )
;;;524        {
;;;525            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;526            {
;;;527                SPIx->SPI_DATA = ( uint16_t )( * ( ( uint16_t* ) Data + tmpNum ) );
;;;528            }
;;;529        }
;;;530        /* Transmit 8 Bit Data */
;;;531        else
;;;532        {
;;;533            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;534            {
;;;535                SPIx->SPI_DATA = ( uint16_t ) ( * ( ( uint8_t* ) Data + tmpNum ) );
;;;536            }
;;;537        }
;;;538    #elif defined(SC32f15xx)||defined(SC32R601)
;;;539        uint8_t tmpNum;
;;;540        /* Check the parameters */
;;;541        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;542        /* Transmit 16Bit Data */
;;;543        if ( SPIx == SPI0 )
;;;544        {
;;;545            if ( SPIx->SPI_CON & SPI0_CON_SPMD )
;;;546            {
;;;547                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;548                {
;;;549                    SPIx->SPI_DATA = ( uint16_t )( * ( ( uint16_t* ) Data + tmpNum ) );;
;;;550                }
;;;551            }
;;;552            /* Transmit 8 Bit Data */
;;;553            else
;;;554            {
;;;555                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;556                {
;;;557                    SPIx->SPI_DATA = ( uint16_t ) ( * ( ( uint8_t* ) Data + tmpNum ) );
;;;558                }
;;;559            }
;;;560        }
;;;561    #elif defined(SC32R803)
;;;562        uint8_t tmpNum;
;;;563        /* Check the parameters */
;;;564        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;565        /* Transmit 16Bit Data */
;;;566        if (( SPIx == SPI0 )||( SPIx == SPI1 ))
000002  4b19              LDR      r3,|L13.104|
000004  4298              CMP      r0,r3
000006  d002              BEQ      |L13.14|
000008  4b18              LDR      r3,|L13.108|
00000a  4298              CMP      r0,r3
00000c  d110              BNE      |L13.48|
                  |L13.14|
;;;567        {
;;;568    			  if ( ( SPIx->SPI_CON & TWI_QSPIx_CON_DWIDTH)>=SPI_DataSize_24B)
00000e  6803              LDR      r3,[r0,#0]
000010  2403              MOVS     r4,#3
000012  0724              LSLS     r4,r4,#28
000014  4023              ANDS     r3,r3,r4
000016  2401              MOVS     r4,#1
000018  0764              LSLS     r4,r4,#29
00001a  42a3              CMP      r3,r4
00001c  d309              BCC      |L13.50|
;;;569    				{
;;;570    						for ( tmpNum = 0; tmpNum < length; tmpNum++ )
00001e  2300              MOVS     r3,#0
000020  e004              B        |L13.44|
                  |L13.34|
;;;571    						{
;;;572    								SPIx->SPI_DATA = ( uint32_t ) ( * ( ( uint32_t* ) Data + tmpNum ) );
000022  009c              LSLS     r4,r3,#2
000024  590c              LDR      r4,[r1,r4]
000026  60c4              STR      r4,[r0,#0xc]
000028  1c5b              ADDS     r3,r3,#1              ;570
00002a  b2db              UXTB     r3,r3                 ;570
                  |L13.44|
00002c  4293              CMP      r3,r2                 ;570
00002e  d3f8              BCC      |L13.34|
                  |L13.48|
;;;573    							
;;;574    						}
;;;575    				}
;;;576            else if ( (SPIx->SPI_CON  & TWI_QSPIx_CON_DWIDTH )==SPI_DataSize_16B)
;;;577            {
;;;578                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;579                {
;;;580                    SPIx->SPI_DATA =( uint32_t ) ( * ( ( uint16_t* ) Data + tmpNum ) );
;;;581                }
;;;582            }
;;;583            /* Transmit 8 Bit Data */
;;;584            else if( (SPIx->SPI_CON  & TWI_QSPIx_CON_DWIDTH )==SPI_DataSize_8B)
;;;585            {
;;;586                for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;587                {
;;;588                    SPIx->SPI_DATA = ( uint32_t ) ( * ( ( uint8_t* ) Data + tmpNum ) );
;;;589                }
;;;590            }
;;;591    
;;;592        }		
;;;593    #endif
;;;594    }
000030  bd10              POP      {r4,pc}
                  |L13.50|
000032  6803              LDR      r3,[r0,#0]            ;576
000034  009b              LSLS     r3,r3,#2              ;576
000036  0f9b              LSRS     r3,r3,#30             ;576
000038  2b01              CMP      r3,#1                 ;576
00003a  d004              BEQ      |L13.70|
00003c  6803              LDR      r3,[r0,#0]            ;584
00003e  009b              LSLS     r3,r3,#2              ;584
000040  0f9b              LSRS     r3,r3,#30             ;584
000042  d1f5              BNE      |L13.48|
000044  e00d              B        |L13.98|
                  |L13.70|
000046  2300              MOVS     r3,#0                 ;578
000048  e004              B        |L13.84|
                  |L13.74|
00004a  005c              LSLS     r4,r3,#1              ;580
00004c  5b0c              LDRH     r4,[r1,r4]            ;580
00004e  60c4              STR      r4,[r0,#0xc]          ;580
000050  1c5b              ADDS     r3,r3,#1              ;578
000052  b2db              UXTB     r3,r3                 ;578
                  |L13.84|
000054  4293              CMP      r3,r2                 ;578
000056  d3f8              BCC      |L13.74|
000058  bd10              POP      {r4,pc}
                  |L13.90|
00005a  5ccc              LDRB     r4,[r1,r3]            ;588
00005c  60c4              STR      r4,[r0,#0xc]          ;588
00005e  1c5b              ADDS     r3,r3,#1              ;586
000060  b2db              UXTB     r3,r3                 ;586
                  |L13.98|
000062  4293              CMP      r3,r2                 ;586
000064  d3f9              BCC      |L13.90|
000066  bd10              POP      {r4,pc}
;;;595    
                          ENDP

                  |L13.104|
                          DCD      0x40020040
                  |L13.108|
                          DCD      0x40021040

                          AREA ||i.SPI_SetMode||, CODE, READONLY, ALIGN=1

                  SPI_SetMode PROC
;;;370     */
;;;371    void SPI_SetMode ( SPI_TypeDef* SPIx, SPI_Mode_TypeDef SPI_Mode )
000000  6802              LDR      r2,[r0,#0]
;;;372    {
;;;373    #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;374        uint32_t tmpreg;
;;;375        /* Check the parameters */
;;;376        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;377    
;;;378        tmpreg = SPIx->SPI_CON;
;;;379        /* Clear MSTR bit */
;;;380        tmpreg &= ( uint32_t ) ~SPI_CON_MSTR;
;;;381        /* Cogfig MSTR bit */
;;;382        tmpreg |= ( uint32_t ) SPI_Mode;
;;;383        /* Set new MSTR bit value */
;;;384        SPIx->SPI_CON |= tmpreg;
;;;385    #elif defined(SC32f15xx)||defined(SC32R601)
;;;386        uint32_t tmpreg;
;;;387        /* Check the parameters */
;;;388        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;389    
;;;390        tmpreg = SPIx->SPI_CON;
;;;391        /* Clear MSTR bit */
;;;392        tmpreg &= ( uint32_t ) ~SPI0_CON_MSTR;
;;;393        /* Cogfig MSTR bit */
;;;394        tmpreg |= ( uint32_t ) SPI_Mode;
;;;395        if ( SPIx == SPI0 )
;;;396        {
;;;397            /* Set new MSTR bit value */
;;;398            SPIx->SPI_CON |= tmpreg;
;;;399        }
;;;400        if ( SPIx == SPI1 )
;;;401        {
;;;402            /* Set new MSTR bit value */
;;;403            SPIx->SPI_CON |= ( tmpreg << 16 );
;;;404        }
;;;405    #elif defined(SC32R803)
;;;406        uint32_t tmpreg;
;;;407        /* Check the parameters */
;;;408        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;409    
;;;410        tmpreg = SPIx->SPI_CON;
;;;411        /* Clear MSTR bit */
;;;412        tmpreg &= ( uint32_t ) ~TWI_QSPIx_CON_SMSTR;
000002  2301              MOVS     r3,#1
000004  041b              LSLS     r3,r3,#16
000006  439a              BICS     r2,r2,r3
;;;413        /* Cogfig MSTR bit */
;;;414        tmpreg |= ( uint32_t ) SPI_Mode;
000008  430a              ORRS     r2,r2,r1
;;;415    
;;;416            /* Set new MSTR bit value */
;;;417        SPIx->SPI_CON |=  tmpreg ;		
00000a  6801              LDR      r1,[r0,#0]
00000c  4311              ORRS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;418    		
;;;419    #endif
;;;420    }
000010  4770              BX       lr
;;;421    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;121      */
;;;122    void SPI_StructInit ( SPI_InitTypeDef* SPI_InitStruct )
000000  2100              MOVS     r1,#0
;;;123    {
;;;124        /* Set the default configuration */
;;;125        SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000002  6001              STR      r1,[r0,#0]
;;;126        SPI_InitStruct->SPI_DataSize = SPI_DataSize_8B;
000004  6041              STR      r1,[r0,#4]
;;;127        SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_LSB;
000006  2201              MOVS     r2,#1
000008  0492              LSLS     r2,r2,#18
00000a  6102              STR      r2,[r0,#0x10]
;;;128        SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
00000c  6081              STR      r1,[r0,#8]
;;;129        SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
00000e  60c1              STR      r1,[r0,#0xc]
;;;130        SPI_InitStruct->SPI_Prescaler = SPI_Prescaler_1;
000010  6141              STR      r1,[r0,#0x14]
;;;131    }
000012  4770              BX       lr
;;;132    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_spi_c_a2ad70c2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_spi_c_a2ad70c2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_spi_c_a2ad70c2____REVSH|
#line 478
|__asm___15_sc32f1xxx_spi_c_a2ad70c2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
