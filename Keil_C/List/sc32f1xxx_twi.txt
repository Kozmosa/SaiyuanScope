; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_twi.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_twi.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_twi.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_twi.c]
                          THUMB

                          AREA ||i.TWI_AcknowledgeConfig||, CODE, READONLY, ALIGN=2

                  TWI_AcknowledgeConfig PROC
;;;322      */
;;;323    void TWI_AcknowledgeConfig ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;324    {
000002  d004              BEQ      |L1.14|
;;;325    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;326        /* Check the parameters */
;;;327        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;328        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;329        if ( NewState != DISABLE )
;;;330        {
;;;331            /* Enable the acknowledgement */
;;;332            TWIx->TWI_CON |= TWI_CON_AA;
;;;333        }
;;;334        else
;;;335        {
;;;336            /* Disable the acknowledgement */
;;;337            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_AA;
;;;338        }
;;;339    #elif  defined (SC32R803) 
;;;340        /* Check the parameters */
;;;341        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;342        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;343        if ( NewState != DISABLE )
;;;344        {
;;;345            /* Enable the acknowledgement */
;;;346            TWIx->TWI_CON |= TWI_SPIx_CON_AA;
000004  6801              LDR      r1,[r0,#0]
000006  2202              MOVS     r2,#2
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;347        }
;;;348        else
;;;349        {
;;;350            /* Disable the acknowledgement */
;;;351           TWIx->TWI_CON &= ( uint16_t ) ~TWI_SPIx_CON_AA;
;;;352        }		
;;;353    #endif
;;;354    }
00000c  4770              BX       lr
                  |L1.14|
00000e  6801              LDR      r1,[r0,#0]            ;351
000010  4a01              LDR      r2,|L1.24|
000012  4011              ANDS     r1,r1,r2              ;351
000014  6001              STR      r1,[r0,#0]            ;351
000016  4770              BX       lr
;;;355    
                          ENDP

                  |L1.24|
                          DCD      0x0000fffd

                          AREA ||i.TWI_ClearFlag||, CODE, READONLY, ALIGN=1

                  TWI_ClearFlag PROC
;;;909     */
;;;910    void TWI_ClearFlag ( TWI_TypeDef* TWIx, TWI_FLAG_TypeDef TWI_FLAG )
000000  6842              LDR      r2,[r0,#4]
;;;911    {
;;;912        /* Check the parameters */
;;;913        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;914        /* Clear the flags */
;;;915        TWIx->TWI_STS |= ( uint16_t ) TWI_FLAG;
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;916    }
000006  4770              BX       lr
;;;917    
                          ENDP


                          AREA ||i.TWI_Cmd||, CODE, READONLY, ALIGN=2

                  TWI_Cmd PROC
;;;273     */
;;;274    void TWI_Cmd ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;275    {
000002  d004              BEQ      |L3.14|
;;;276    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;277        /* Check the parameters */
;;;278        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;279        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;280        if ( NewState != DISABLE )
;;;281        {
;;;282            /* Enable the TWI Function */
;;;283            TWIx->TWI_CON |= TWI_CON_TWEN;
;;;284        }
;;;285        else
;;;286        {
;;;287            /* Disable the TWI Function */
;;;288            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_TWEN;
;;;289        }
;;;290    #elif  defined (SC32R803) 
;;;291        /* Check the parameters */
;;;292        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;293        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;294        if ( NewState != DISABLE )
;;;295        {
;;;296            /* Enable the TWI Function */
;;;297            TWIx->TWI_CON |= TWI_SPIx_CON_QTWEN;
000004  6801              LDR      r1,[r0,#0]
000006  2280              MOVS     r2,#0x80
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;298        }
;;;299        else
;;;300        {
;;;301            /* Disable the TWI Function */
;;;302            TWIx->TWI_CON &= ( uint16_t ) ~TWI_SPIx_CON_QTWEN;
;;;303        }		
;;;304    #endif
;;;305    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6801              LDR      r1,[r0,#0]            ;302
000010  4a01              LDR      r2,|L3.24|
000012  4011              ANDS     r1,r1,r2              ;302
000014  6001              STR      r1,[r0,#0]            ;302
000016  4770              BX       lr
;;;306    
                          ENDP

                  |L3.24|
                          DCD      0x0000ff7f

                          AREA ||i.TWI_DMACmd||, CODE, READONLY, ALIGN=1

                  TWI_DMACmd PROC
;;;976     */
;;;977    void TWI_DMACmd ( TWI_TypeDef* TWIx, TWI_DMAReq_TypeDef TWI_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;978    {
000002  d003              BEQ      |L4.12|
;;;979        /* Check the parameters */
;;;980        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;981        assert_param ( IS_TWI_DMAREQ ( TWI_DMAReq ) );
;;;982        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;983        if ( NewState != DISABLE )
;;;984        {
;;;985            /* Enable the selected TWI DMA requests */
;;;986            TWIx->TWI_IDE |= TWI_DMAReq;
000004  6902              LDR      r2,[r0,#0x10]
000006  430a              ORRS     r2,r2,r1
000008  6102              STR      r2,[r0,#0x10]
;;;987        }
;;;988        else
;;;989        {
;;;990            /* Disable the selected TWI DMA requests */
;;;991            TWIx->TWI_IDE &= ( uint16_t ) ~TWI_DMAReq;
;;;992        }
;;;993    }
00000a  4770              BX       lr
                  |L4.12|
00000c  6902              LDR      r2,[r0,#0x10]         ;991
00000e  43c9              MVNS     r1,r1                 ;991
000010  b289              UXTH     r1,r1                 ;991
000012  400a              ANDS     r2,r2,r1              ;991
000014  6102              STR      r2,[r0,#0x10]         ;991
000016  4770              BX       lr
;;;994    
                          ENDP


                          AREA ||i.TWI_DeInit||, CODE, READONLY, ALIGN=2

                  TWI_DeInit PROC
;;;52      */
;;;53     void TWI_DeInit ( TWI_TypeDef* TWIx )
000000  b510              PUSH     {r4,lr}
;;;54     {
;;;55     #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;56         /* Check the parameters */
;;;57         assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;58         if ( TWIx == TWI0 )
;;;59         {
;;;60             /* Enable TWI0 reset state */
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TWI0, ENABLE );
;;;62             /* Disable TWI0 reset state */
;;;63             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TWI0, DISABLE );
;;;64         }
;;;65         else if ( TWIx == TWI1 )
;;;66         {
;;;67     #if !(defined (SC32f15xx) || defined(SC32R601))
;;;68             /* Enable TWI1 reset state */
;;;69             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TWI1, ENABLE );
;;;70             /* Disable TWI1 reset state */
;;;71             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TWI1, DISABLE );
;;;72     #else
;;;73     			    /* Enable SPI0 reset state */
;;;74         RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI1_TWI1, ENABLE);
;;;75         /* Release SPI0 from reset state */
;;;76         RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI1_TWI1, DISABLE);		
;;;77     #endif
;;;78     		}	
;;;79     #elif defined (SC32R803)
;;;80         /* Check the parameters */
;;;81         assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;82         if ( TWIx == TWI0 )
000002  4919              LDR      r1,|L5.104|
000004  4288              CMP      r0,r1
000006  d108              BNE      |L5.26|
;;;83         {
;;;84             /* Enable TWI0 reset state */
;;;85             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI0, ENABLE );
000008  2101              MOVS     r1,#1
00000a  2010              MOVS     r0,#0x10
00000c  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;86             /* Disable TWI0 reset state */
;;;87             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI0, DISABLE );
000010  2100              MOVS     r1,#0
000012  2010              MOVS     r0,#0x10
000014  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;88         }
;;;89         else if ( TWIx == TWI1 )
;;;90         {
;;;91             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI1, ENABLE );
;;;92             /* Disable TWI0 reset state */
;;;93             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI1, DISABLE );
;;;94     			
;;;95         }
;;;96         else if ( TWIx == TWI2 )
;;;97         {
;;;98             /* Enable TWI0 reset state */
;;;99             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI2, ENABLE );
;;;100            /* Disable TWI0 reset state */
;;;101            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_QTWI2, DISABLE );
;;;102    			
;;;103        }
;;;104        else if ( TWIx == TWI3 )
;;;105        {
;;;106            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI3, ENABLE );
;;;107            /* Disable TWI0 reset state */
;;;108            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_QTWI3, DISABLE );
;;;109    			
;;;110        }			
;;;111    #endif
;;;112    			
;;;113        
;;;114    }
000018  bd10              POP      {r4,pc}
                  |L5.26|
00001a  4914              LDR      r1,|L5.108|
00001c  4288              CMP      r0,r1                 ;89
00001e  d108              BNE      |L5.50|
000020  2101              MOVS     r1,#1                 ;91
000022  2010              MOVS     r0,#0x10              ;91
000024  f7fffffe          BL       RCC_APB1PeriphResetCmd
000028  2100              MOVS     r1,#0                 ;93
00002a  2010              MOVS     r0,#0x10              ;93
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000030  bd10              POP      {r4,pc}
                  |L5.50|
000032  490d              LDR      r1,|L5.104|
000034  3120              ADDS     r1,r1,#0x20           ;96
000036  4288              CMP      r0,r1                 ;96
000038  d108              BNE      |L5.76|
00003a  2101              MOVS     r1,#1                 ;99
00003c  2020              MOVS     r0,#0x20              ;99
00003e  f7fffffe          BL       RCC_APB0PeriphResetCmd
000042  2100              MOVS     r1,#0                 ;101
000044  2020              MOVS     r0,#0x20              ;101
000046  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L5.74|
00004a  bd10              POP      {r4,pc}
                  |L5.76|
00004c  4907              LDR      r1,|L5.108|
00004e  3120              ADDS     r1,r1,#0x20           ;104
000050  4288              CMP      r0,r1                 ;104
000052  d1fa              BNE      |L5.74|
000054  2101              MOVS     r1,#1                 ;106
000056  2020              MOVS     r0,#0x20              ;106
000058  f7fffffe          BL       RCC_APB1PeriphResetCmd
00005c  2100              MOVS     r1,#0                 ;108
00005e  2020              MOVS     r0,#0x20              ;108
000060  f7fffffe          BL       RCC_APB1PeriphResetCmd
000064  bd10              POP      {r4,pc}
;;;115    
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      0x40020040
                  |L5.108|
                          DCD      0x40021040

                          AREA ||i.TWI_GeneralCallCmd||, CODE, READONLY, ALIGN=2

                  TWI_GeneralCallCmd PROC
;;;371      */
;;;372    void TWI_GeneralCallCmd ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;373    {
000002  d004              BEQ      |L6.14|
;;;374    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806) || defined (SC32f15xx) || defined(SC32R601)
;;;375        /* Check the parameters */
;;;376        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;377        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;378        if ( NewState != DISABLE )
;;;379        {
;;;380            /* Enable general call */
;;;381            TWIx->TWI_ADD |= TWI_ADD_GC;
;;;382        }
;;;383        else
;;;384        {
;;;385            /* Disable general call */
;;;386            TWIx->TWI_ADD &= ( uint16_t ) ~TWI_ADD_GC;
;;;387        }
;;;388    #elif  defined (SC32R803) 
;;;389        /* Check the parameters */
;;;390        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;391        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;392        if ( NewState != DISABLE )
;;;393        {
;;;394            /* Enable general call */
;;;395            TWIx->TWI_ADD|= TWI_QSPIx_ADD_GC;
000004  6881              LDR      r1,[r0,#8]
000006  2201              MOVS     r2,#1
000008  4311              ORRS     r1,r1,r2
00000a  6081              STR      r1,[r0,#8]
;;;396        }
;;;397        else
;;;398        {
;;;399            /* Disable general call */
;;;400            TWIx->TWI_ADD &= ( uint16_t ) ~TWI_QSPIx_ADD_GC;
;;;401        }
;;;402    #endif		
;;;403    }
00000c  4770              BX       lr
                  |L6.14|
00000e  6881              LDR      r1,[r0,#8]            ;400
000010  4a01              LDR      r2,|L6.24|
000012  4011              ANDS     r1,r1,r2              ;400
000014  6081              STR      r1,[r0,#8]            ;400
000016  4770              BX       lr
;;;404    
                          ENDP

                  |L6.24|
                          DCD      0x0000fffe

                          AREA ||i.TWI_GenerateSTART||, CODE, READONLY, ALIGN=2

                  TWI_GenerateSTART PROC
;;;547      */
;;;548    void TWI_GenerateSTART ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;549    {
000002  d004              BEQ      |L7.14|
;;;550    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;551        /* Check the parameters */
;;;552        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;553        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;554        if ( NewState != DISABLE )
;;;555        {
;;;556            /* Generate a START condition */
;;;557            TWIx->TWI_CON |= TWI_CON_STA;
;;;558        }
;;;559        else
;;;560        {
;;;561            /* Disable the START condition generation */
;;;562            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_STA;
;;;563        }
;;;564    #elif  defined (SC32R803)
;;;565        /* Check the parameters */
;;;566        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;567        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;568        if ( NewState != DISABLE )
;;;569        {
;;;570            /* Generate a START condition */
;;;571            TWIx->TWI_CON |= TWI_SPIx_CON_START;
000004  6801              LDR      r1,[r0,#0]
000006  2220              MOVS     r2,#0x20
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;572        }
;;;573        else
;;;574        {
;;;575            /* Disable the START condition generation */
;;;576           TWIx->TWI_CON &= ( uint16_t ) ~TWI_SPIx_CON_START;
;;;577        }		
;;;578    #endif
;;;579    }
00000c  4770              BX       lr
                  |L7.14|
00000e  6801              LDR      r1,[r0,#0]            ;576
000010  4a01              LDR      r2,|L7.24|
000012  4011              ANDS     r1,r1,r2              ;576
000014  6001              STR      r1,[r0,#0]            ;576
000016  4770              BX       lr
;;;580    
                          ENDP

                  |L7.24|
                          DCD      0x0000ffdf

                          AREA ||i.TWI_GenerateSTOP||, CODE, READONLY, ALIGN=2

                  TWI_GenerateSTOP PROC
;;;596      */
;;;597    void TWI_GenerateSTOP ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;598    {
000002  d004              BEQ      |L8.14|
;;;599    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;600        /* Check the parameters */
;;;601        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;602        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;603        if ( NewState != DISABLE )
;;;604        {
;;;605            /* Generate a STOP condition */
;;;606            TWIx->TWI_CON |= TWI_CON_STO;
;;;607        }
;;;608        else
;;;609        {
;;;610            /* Disable the STOP condition generation */
;;;611            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_STO;
;;;612        }
;;;613    #elif  defined (SC32R803)
;;;614        /* Check the parameters */
;;;615        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;616        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;617        if ( NewState != DISABLE )
;;;618        {
;;;619            /* Generate a STOP condition */
;;;620            TWIx->TWI_CON |= TWI_SPIx_CON_STOP;
000004  6801              LDR      r1,[r0,#0]
000006  2210              MOVS     r2,#0x10
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;621        }
;;;622        else
;;;623        {
;;;624            /* Disable the STOP condition generation */
;;;625            TWIx->TWI_CON &= ( uint16_t ) ~TWI_SPIx_CON_STOP;
;;;626        }		
;;;627    #endif
;;;628    }
00000c  4770              BX       lr
                  |L8.14|
00000e  6801              LDR      r1,[r0,#0]            ;625
000010  4a01              LDR      r2,|L8.24|
000012  4011              ANDS     r1,r1,r2              ;625
000014  6001              STR      r1,[r0,#0]            ;625
000016  4770              BX       lr
;;;629    
                          ENDP

                  |L8.24|
                          DCD      0x0000ffef

                          AREA ||i.TWI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TWI_GetFlagStatus PROC
;;;874     */
;;;875    FlagStatus TWI_GetFlagStatus ( TWI_TypeDef* TWIx, TWI_FLAG_TypeDef TWI_FLAG )
000000  4602              MOV      r2,r0
;;;876    {
;;;877        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;878        /* Check the parameters */
;;;879        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;880        assert_param ( IS_TWI_FLAG ( TWI_FLAG ) );
;;;881        if ( ( TWIx->TWI_STS & TWI_FLAG ) != ( uint16_t ) RESET )
000004  6852              LDR      r2,[r2,#4]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L9.12|
;;;882        {
;;;883            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;884        }
;;;885        else
;;;886        {
;;;887            bitstatus = RESET;
;;;888        }
;;;889        return bitstatus;
;;;890    }
00000c  4770              BX       lr
;;;891    
                          ENDP


                          AREA ||i.TWI_GetNbytes||, CODE, READONLY, ALIGN=1

                  TWI_GetNbytes PROC
;;;496      */
;;;497    uint8_t TWI_GetNbytes ( TWI_TypeDef* TWIx )
000000  6840              LDR      r0,[r0,#4]
;;;498    {
;;;499    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;500        uint8_t tmpnum;
;;;501    
;;;502        /* Check the parameters */
;;;503        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;504    
;;;505        tmpnum = ( uint8_t ) ( TWIx->TWI_STS >> TWI_STS_NBYTES_Pos );
;;;506    
;;;507        return tmpnum;
;;;508    #elif  defined (SC32R803)
;;;509        uint8_t tmpnum;
;;;510    
;;;511        /* Check the parameters */
;;;512        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;513    
;;;514        tmpnum = ( uint8_t ) ( TWIx->TWI_STS  >> TWI_QSPIx_STS_NBYTES_Pos );
000002  0200              LSLS     r0,r0,#8
000004  0e00              LSRS     r0,r0,#24
;;;515    
;;;516        return tmpnum;	
;;;517    #endif
;;;518    }
000006  4770              BX       lr
;;;519    
                          ENDP


                          AREA ||i.TWI_GetStateMachine||, CODE, READONLY, ALIGN=1

                  TWI_GetStateMachine PROC
;;;942     */
;;;943    TWI_StateMachine_TypeDef TWI_GetStateMachine ( TWI_TypeDef* TWIx )
000000  6840              LDR      r0,[r0,#4]
;;;944    {
;;;945    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806) || defined (SC32f15xx) || defined(SC32R601)
;;;946        /* Check the parameters */
;;;947        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;948    
;;;949        return ( TWI_StateMachine_TypeDef ) ( TWIx->TWI_STS & TWI_STS_STATE );
;;;950    #elif (SC32R803)
;;;951        /* Check the parameters */
;;;952        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;953    
;;;954        return ( TWI_StateMachine_TypeDef ) ( TWIx->TWI_STS & TWI_SPIx_STS_STATE );
000002  2107              MOVS     r1,#7
000004  0209              LSLS     r1,r1,#8
000006  4008              ANDS     r0,r0,r1
;;;955    #endif
;;;956    }
000008  4770              BX       lr
;;;957    
                          ENDP


                          AREA ||i.TWI_ITConfig||, CODE, READONLY, ALIGN=1

                  TWI_ITConfig PROC
;;;831     */
;;;832    void TWI_ITConfig ( TWI_TypeDef* TWIx, uint16_t TWI_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;833    {
000002  d003              BEQ      |L12.12|
;;;834        /* Check the parameters */
;;;835        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;836        assert_param ( IS_TWI_IT ( TWI_IT ) );
;;;837        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;838        if ( NewState != DISABLE )
;;;839        {
;;;840            /* Enable the Interrupt sources */
;;;841            TWIx->TWI_IDE |= TWI_IT;
000004  6902              LDR      r2,[r0,#0x10]
000006  430a              ORRS     r2,r2,r1
000008  6102              STR      r2,[r0,#0x10]
;;;842        }
;;;843        else
;;;844        {
;;;845            /* Disable the Interrupt sources */
;;;846            TWIx->TWI_IDE &= ( uint16_t ) ~TWI_IT;
;;;847        }
;;;848    }
00000a  4770              BX       lr
                  |L12.12|
00000c  6902              LDR      r2,[r0,#0x10]         ;846
00000e  43c9              MVNS     r1,r1                 ;846
000010  b289              UXTH     r1,r1                 ;846
000012  400a              ANDS     r2,r2,r1              ;846
000014  6102              STR      r2,[r0,#0x10]         ;846
000016  4770              BX       lr
;;;849    
                          ENDP


                          AREA ||i.TWI_Init||, CODE, READONLY, ALIGN=2

                  TWI_Init PROC
;;;145     */
;;;146    void TWI_Init ( TWI_TypeDef* TWIx, TWI_InitTypeDef* TWI_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)   
;;;149        uint32_t tmpreg;
;;;150        /* Check the parameters */
;;;151        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;152        assert_param ( IS_TWI_ACK ( TWI_InitStruct->TWI_Ack ) );
;;;153        assert_param ( IS_TWI_PRESCALER ( TWI_InitStruct->TWI_Prescaler ) );
;;;154        assert_param ( IS_TWI_STRETCH ( TWI_InitStruct->TWI_Stretch ) );
;;;155        assert_param ( IS_TWI_GENERALCALL ( TWI_InitStruct->TWI_GeneralCall ) );
;;;156        /*---------------------------- TWIx TWI_CON Configuration ------------------------*/
;;;157        /* Get the TWIx TWI_CON value */
;;;158        tmpreg = TWIx->TWI_CON;
;;;159        /* Clear AA, TWCK, STRETCH bits */
;;;160        tmpreg &= ( uint32_t ) ~ ( TWI_CON_AA | TWI_CON_SPOS | TWI_CON_STRETCH );
;;;161        /* Configure TWIx: Ack, Clock division and Slave Clock Stretch */
;;;162        /* Set AA bits to TWI_Ack value */
;;;163        /* Set TWCK bits according to TWI_DataSize value */
;;;164        /* Set STRETCH bit according to TWI_Stretch value */
;;;165        tmpreg |= ( uint32_t ) ( TWI_InitStruct->TWI_Ack | TWI_InitStruct->TWI_Prescaler |
;;;166                                 TWI_InitStruct->TWI_Stretch );
;;;167        /* Write to TWIx TWI_CON */
;;;168        TWIx->TWI_CON = tmpreg;
;;;169        /*---------------------------- TWIx TWI_ADD Configuration ------------------------*/
;;;170        /* Get the TWIx TWI_ADD value */
;;;171        tmpreg = TWIx->TWI_ADD;
;;;172        /* Clear GC, TWCK, STRETCH bits */
;;;173        tmpreg &= ( uint32_t ) ~ ( TWI_ADD_GC | TWI_ADD_TWA );
;;;174        /* Configure TWIx: General Call and Slave Slave Address */
;;;175        /* Set AA bits to TWI_GC value */
;;;176        /* Set TWA according to TWI_SlaveAdress value */
;;;177        tmpreg |= ( uint32_t ) ( TWI_InitStruct->TWI_GeneralCall | ( ( TWI_InitStruct->TWI_SlaveAdress << 1 ) & 0xFE ) );
;;;178    
;;;179        /* Write to TWIx TWI_ADD */
;;;180        TWIx->TWI_ADD = tmpreg;
;;;181    #elif defined (SC32f15xx) || defined(SC32R601)
;;;182      uint32_t tmpreg;
;;;183      /* Check the parameters */
;;;184      assert_param(IS_TWI_ALL_PERIPH(TWIx));
;;;185      assert_param(IS_TWI_ACK(TWI_InitStruct->TWI_Ack));
;;;186      assert_param(IS_TWI_PRESCALER(TWI_InitStruct->TWI_Prescaler));
;;;187      assert_param(IS_TWI_STRETCH(TWI_InitStruct->TWI_Stretch));
;;;188      assert_param(IS_TWI_GENERALCALL(TWI_InitStruct->TWI_GeneralCall));
;;;189    	/*---------------------------- TWIx TWI_CON Configuration ------------------------*/
;;;190    
;;;191    	/* Get the TWIx TWI_CON value */
;;;192      tmpreg = TWIx->TWI_CON;
;;;193      /* Clear AA, TWCK, STRETCH bits */
;;;194      tmpreg &= (uint32_t) ~(TWI_CON_AA | TWI_CON_SPOS | TWI_CON_STRETCH |TWI_CON_TWCK);
;;;195      /* Configure TWIx: Ack, Clock division and Slave Clock Stretch */
;;;196      /* Set AA bits to TWI_Ack value */
;;;197      /* Set TWCK bits according to TWI_DataSize value */
;;;198      /* Set STRETCH bit according to TWI_Stretch value */
;;;199      tmpreg |= (uint32_t)(TWI_InitStruct->TWI_Ack | TWI_InitStruct->TWI_Prescaler |
;;;200                           TWI_InitStruct->TWI_Stretch);
;;;201      if(TWIx == TWI1)
;;;202    	{
;;;203    		tmpreg &=~(0x00<<SPI1_TWI1_CON_MODE_Pos);
;;;204    	}
;;;205      /* Write to TWIx TWI_CON */
;;;206      TWIx->TWI_CON = tmpreg;
;;;207      /*---------------------------- TWIx TWI_ADD Configuration ------------------------*/
;;;208      /* Get the TWIx TWI_ADD value */
;;;209      tmpreg = TWIx->TWI_ADD;
;;;210      /* Clear GC, TWCK, STRETCH bits */
;;;211      tmpreg &= (uint32_t) ~(TWI_ADD_GC | TWI_ADD_TWA);
;;;212      /* Configure TWIx: General Call and Slave Slave Address */
;;;213      /* Set AA bits to TWI_GC value */
;;;214      /* Set TWA according to TWI_SlaveAdress value */
;;;215      tmpreg |= (uint32_t)(TWI_InitStruct->TWI_GeneralCall |  ( ( TWI_InitStruct->TWI_SlaveAdress << 1 ) & 0xFE ) );
;;;216    
;;;217      /* Write to TWIx TWI_ADD */
;;;218      TWIx->TWI_ADD = tmpreg;
;;;219    #elif  defined (SC32R803)
;;;220      uint32_t tmpreg;
;;;221      /* Check the parameters */
;;;222      assert_param(IS_TWI_ALL_PERIPH(TWIx));
;;;223      assert_param(IS_TWI_ACK(TWI_InitStruct->TWI_Ack));
;;;224      assert_param(IS_TWI_PRESCALER(TWI_InitStruct->TWI_Prescaler));
;;;225      assert_param(IS_TWI_STRETCH(TWI_InitStruct->TWI_Stretch));
;;;226      assert_param(IS_TWI_GENERALCALL(TWI_InitStruct->TWI_GeneralCall));
;;;227    	/*---------------------------- TWIx TWI_CON Configuration ------------------------*/
;;;228    
;;;229    	/* Get the TWIx TWI_CON value */
;;;230      tmpreg = TWIx->TWI_CON;
000002  6802              LDR      r2,[r0,#0]
;;;231      /* Clear AA, TWCK, STRETCH bits */
;;;232      tmpreg &= (uint32_t) ~(TWI_QSPIx_CON_AA | TWI_QSPIx_CON_SPOS | TWI_QSPIx_CON_STRETCH |TWI_QSPIx_CON_QTWCK);
000004  4b0b              LDR      r3,|L13.52|
000006  401a              ANDS     r2,r2,r3
;;;233      /* Configure TWIx: Ack, Clock division and Slave Clock Stretch */
;;;234      /* Set AA bits to TWI_Ack value */
;;;235      /* Set TWCK bits according to TWI_DataSize value */
;;;236      /* Set STRETCH bit according to TWI_Stretch value */
;;;237    
;;;238    
;;;239    	tmpreg &=~TWI_QSPIx_CON_MODE;
000008  2303              MOVS     r3,#3
00000a  059b              LSLS     r3,r3,#22
00000c  439a              BICS     r2,r2,r3
;;;240      tmpreg |= (uint32_t)(TWI_InitStruct->TWI_Ack | TWI_InitStruct->TWI_Prescaler |TWI_InitStruct->TWI_Stretch);
00000e  880b              LDRH     r3,[r1,#0]
000010  884c              LDRH     r4,[r1,#2]
000012  4323              ORRS     r3,r3,r4
000014  888c              LDRH     r4,[r1,#4]
000016  4314              ORRS     r4,r4,r2
000018  4323              ORRS     r3,r3,r4
;;;241      /* Write to TWIx TWI_CON */
;;;242      TWIx->TWI_CON = tmpreg;
00001a  6003              STR      r3,[r0,#0]
;;;243      /*---------------------------- TWIx TWI_ADD Configuration ------------------------*/
;;;244      /* Get the TWIx TWI_ADD value */
;;;245      tmpreg = TWIx->TWI_ADD;
00001c  6882              LDR      r2,[r0,#8]
;;;246      /* Clear GC, TWCK, STRETCH bits */
;;;247      tmpreg &= (uint32_t) ~(TWI_QSPIx_ADD_GC | TWI_QSPIx_ADD_QTWADD);
00001e  0a12              LSRS     r2,r2,#8
000020  0212              LSLS     r2,r2,#8
;;;248      /* Configure TWIx: General Call and Slave Slave Address */
;;;249      /* Set AA bits to TWI_GC value */
;;;250      /* Set TWA according to TWI_SlaveAdress value */
;;;251      tmpreg |= (uint32_t)(TWI_InitStruct->TWI_GeneralCall |  ( ( TWI_InitStruct->TWI_SlaveAdress << 1 ) & 0xFE ) );
000022  88cb              LDRH     r3,[r1,#6]
000024  7a09              LDRB     r1,[r1,#8]
000026  0649              LSLS     r1,r1,#25
000028  0e09              LSRS     r1,r1,#24
00002a  4311              ORRS     r1,r1,r2
00002c  430b              ORRS     r3,r3,r1
;;;252    
;;;253      /* Write to TWIx TWI_ADD */
;;;254      TWIx->TWI_ADD = tmpreg;	
00002e  6083              STR      r3,[r0,#8]
;;;255    #endif
;;;256    }
000030  bd10              POP      {r4,pc}
;;;257    
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      0xffff90fc

                          AREA ||i.TWI_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  TWI_PinRemapConfig PROC
;;;744     */
;;;745    void TWI_PinRemapConfig ( TWI_TypeDef* TWIx, TWI_PinRemap_TypeDef TWI_Remap )
000000  6802              LDR      r2,[r0,#0]
;;;746    {
;;;747    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)   
;;;748        uint32_t tmpreg ;
;;;749        /* Check the parameters */
;;;750        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;751        if ( TWIx == TWI0 )
;;;752        {
;;;753            assert_param ( IS_TWI_LIST1_PINREMAP ( TWI_Remap ) );
;;;754        }
;;;755        else
;;;756        {
;;;757            assert_param ( IS_TWI_LIST2_PINREMAP ( TWI_Remap ) );
;;;758        }
;;;759    
;;;760        tmpreg = TWIx->TWI_CON;
;;;761    
;;;762        tmpreg &= ( uint32_t ) ( ~TWI_CON_SPOS );
;;;763    
;;;764        tmpreg |= TWI_Remap;
;;;765    
;;;766        TWIx->TWI_CON = tmpreg;
;;;767    #elif defined (SC32f15xx) || defined(SC32R601) 
;;;768      uint32_t tmpreg ;
;;;769      /* Check the parameters */
;;;770      assert_param(IS_TWI_ALL_PERIPH(TWIx));
;;;771      
;;;772    	
;;;773    
;;;774      tmpreg = TWIx->TWI_CON;
;;;775    
;;;776      tmpreg &= (uint32_t)(~TWI_CON_SPOS);
;;;777    
;;;778      tmpreg |= TWI_Remap;
;;;779    
;;;780      TWIx->TWI_CON = tmpreg;
;;;781    #elif defined (SC32R803)
;;;782      uint32_t tmpreg ;
;;;783      /* Check the parameters */
;;;784      assert_param(IS_TWI_ALL_PERIPH(TWIx));
;;;785      
;;;786    	
;;;787    
;;;788      tmpreg = TWIx->TWI_CON;
;;;789    
;;;790      tmpreg &= (uint32_t)(~TWI_SPIx_CON_SPOS);
000002  2303              MOVS     r3,#3
000004  035b              LSLS     r3,r3,#13
000006  439a              BICS     r2,r2,r3
;;;791    
;;;792      tmpreg |= TWI_Remap;
000008  430a              ORRS     r2,r2,r1
;;;793    
;;;794      TWIx->TWI_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;795    #endif	
;;;796    }
00000c  4770              BX       lr
;;;797    
                          ENDP


                          AREA ||i.TWI_ReceiveData||, CODE, READONLY, ALIGN=1

                  TWI_ReceiveData PROC
;;;708     */
;;;709    uint8_t TWI_ReceiveData ( TWI_TypeDef* TWIx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;710    {
;;;711        /* Check the parameters */
;;;712        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;713        /* Receive Data */
;;;714        return ( uint8_t ) TWIx->TWI_DATA;
000002  b2c0              UXTB     r0,r0
;;;715    }
000004  4770              BX       lr
;;;716    
                          ENDP


                          AREA ||i.TWI_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  TWI_Send7bitAddress PROC
;;;646      */
;;;647    void TWI_Send7bitAddress ( TWI_TypeDef* TWIx, uint8_t Address, TWI_Command_TypeDef TWI_Command )
000000  0649              LSLS     r1,r1,#25
;;;648    {
;;;649        /* Check the parameters */
;;;650        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;651        assert_param ( IS_TWI_COMMAND ( TWI_Command ) );
;;;652        Address = ( Address << 1 );
000002  0e09              LSRS     r1,r1,#24
;;;653        /* Test on the direction to set/reset the read/write bit */
;;;654        if ( TWI_Command != TWI_Command_Write )
000004  2a00              CMP      r2,#0
000006  d002              BEQ      |L16.14|
;;;655        {
;;;656            /* Set the address bit0 for read */
;;;657            Address |= TWI_Command_Read;
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  e001              B        |L16.18|
                  |L16.14|
;;;658        }
;;;659        else
;;;660        {
;;;661            /* Reset the address bit0 for write */
;;;662            Address &= ( uint8_t ) ~ ( ( uint8_t ) TWI_Command_Read );
00000e  0849              LSRS     r1,r1,#1
000010  0049              LSLS     r1,r1,#1
                  |L16.18|
;;;663        }
;;;664    
;;;665        /* Send the address */
;;;666        TWIx->TWI_DATA = Address;
000012  60c1              STR      r1,[r0,#0xc]
;;;667    }
000014  4770              BX       lr
;;;668    
                          ENDP


                          AREA ||i.TWI_SendData||, CODE, READONLY, ALIGN=1

                  TWI_SendData PROC
;;;687     */
;;;688    void TWI_SendData ( TWI_TypeDef* TWIx, uint8_t Data )
000000  60c1              STR      r1,[r0,#0xc]
;;;689    {
;;;690        /* Check the parameters */
;;;691        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;692        /* Transmit Data */
;;;693        TWIx->TWI_DATA = Data;
;;;694    }
000002  4770              BX       lr
;;;695    
                          ENDP


                          AREA ||i.TWI_SetNbytes||, CODE, READONLY, ALIGN=1

                  TWI_SetNbytes PROC
;;;468      */
;;;469    void TWI_SetNbytes ( TWI_TypeDef* TWIx, uint8_t Nbytes )
000000  0409              LSLS     r1,r1,#16
;;;470    {
;;;471    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;472        /* Check the parameters */
;;;473        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;474    
;;;475        TWIx->TWI_STS = ( uint32_t ) ( Nbytes << TWI_STS_NBYTES_Pos );
;;;476    #elif  defined (SC32R803)
;;;477        /* Check the parameters */
;;;478        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;479    
;;;480        TWIx->TWI_STS = ( uint32_t ) ( Nbytes << TWI_QSPIx_STS_NBYTES_Pos );	
000002  6041              STR      r1,[r0,#4]
;;;481    #endif
;;;482    }
000004  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.TWI_StretchClockConfig||, CODE, READONLY, ALIGN=2

                  TWI_StretchClockConfig PROC
;;;420      */
;;;421    void TWI_StretchClockConfig ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;422    {
000002  d004              BEQ      |L19.14|
;;;423    #if defined (SC32f10xx) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)  || defined (SC32f15xx) || defined(SC32R601)
;;;424        /* Check the parameters */
;;;425        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;426        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;427        if ( NewState == DISABLE )
;;;428        {
;;;429            /* Enable the selected TWI Clock stretching */
;;;430            TWIx->TWI_CON |= TWI_CON_STRETCH;
;;;431        }
;;;432        else
;;;433        {
;;;434            /* Disable the selected TWI Clock stretching */
;;;435            TWIx->TWI_CON &= ( uint16_t ) ~ ( ( uint16_t ) TWI_CON_STRETCH );
;;;436        }
;;;437    #elif  defined (SC32R803) 
;;;438        /* Check the parameters */
;;;439        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;440        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;441        if ( NewState == DISABLE )
;;;442        {
;;;443            /* Enable the selected TWI Clock stretching */
;;;444            TWIx->TWI_CON|= TWI_QSPIx_CON_STRETCH;
;;;445        }
;;;446        else
;;;447        {
;;;448            /* Disable the selected TWI Clock stretching */
;;;449            TWIx->TWI_CON &= ( uint16_t ) ~ ( ( uint16_t ) TWI_QSPIx_CON_STRETCH );
000004  6801              LDR      r1,[r0,#0]
000006  4a04              LDR      r2,|L19.24|
000008  4011              ANDS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;450        }		
;;;451    #endif
;;;452    }
00000c  4770              BX       lr
                  |L19.14|
00000e  6801              LDR      r1,[r0,#0]            ;444
000010  2201              MOVS     r2,#1                 ;444
000012  4311              ORRS     r1,r1,r2              ;444
000014  6001              STR      r1,[r0,#0]            ;444
000016  4770              BX       lr
;;;453    
                          ENDP

                  |L19.24|
                          DCD      0x0000fffe

                          AREA ||i.TWI_StructInit||, CODE, READONLY, ALIGN=1

                  TWI_StructInit PROC
;;;120      */
;;;121    void TWI_StructInit ( TWI_InitTypeDef* TWI_InitStruct )
000000  2102              MOVS     r1,#2
;;;122    {
;;;123        /* Set the default configuration */
;;;124        TWI_InitStruct->TWI_Ack = TWI_Ack_Enable;
000002  8001              STRH     r1,[r0,#0]
;;;125        TWI_InitStruct->TWI_Prescaler = 0x00;
000004  2100              MOVS     r1,#0
000006  8041              STRH     r1,[r0,#2]
;;;126        TWI_InitStruct->TWI_Stretch = 0;
000008  8081              STRH     r1,[r0,#4]
;;;127    
;;;128        TWI_InitStruct->TWI_GeneralCall = TWI_GeneralCall_Disable;
00000a  80c1              STRH     r1,[r0,#6]
;;;129        TWI_InitStruct->TWI_SlaveAdress = 0x00;
00000c  6081              STR      r1,[r0,#8]
;;;130    }
00000e  4770              BX       lr
;;;131    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_twi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_twi_c_24100672____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_twi_c_24100672____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_twi_c_24100672____REVSH|
#line 478
|__asm___15_sc32f1xxx_twi_c_24100672____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
