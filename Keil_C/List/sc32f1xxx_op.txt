; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_op.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_op.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_op.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_op.c]
                          THUMB

                          AREA ||i.OP_Cmd||, CODE, READONLY, ALIGN=2

                  OP_Cmd PROC
;;;223     */
;;;224    void OP_Cmd ( OP_TypeDef* OPx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;225    {
000002  d004              BEQ      |L1.14|
;;;226    #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)|| defined (SC32R803)
;;;227        /* Check the parameters */
;;;228        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;229        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;230    
;;;231        if ( NewState != DISABLE )
;;;232        {
;;;233            /* Enable the OP Function */
;;;234            OPx->OP_CON |= OP_CON_ENOP;
000004  6801              LDR      r1,[r0,#0]
000006  2201              MOVS     r2,#1
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;235        }
;;;236        else
;;;237        {
;;;238            /* Disable the OP Function */
;;;239            OPx->OP_CON &= ( uint16_t ) ~OP_CON_ENOP;
;;;240        }
;;;241    #elif defined (SC32f15xx)
;;;242        /* Check the parameters */
;;;243        assert_param(IS_OP_ALL_PERIPH(OPx)); 
;;;244        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;245    
;;;246        if(NewState != DISABLE)
;;;247        {
;;;248    			/* Enable the OP Function */
;;;249    			if(OPx==OP_0)
;;;250    			{
;;;251    				 OP->OP0_CON |= (uint32_t)OP_CON_ENOP;
;;;252    			}
;;;253    			else if(OPx==OP_1)
;;;254    			{
;;;255    				 OP->OP1_CON |= (uint32_t)OP_CON_ENOP;
;;;256    			}
;;;257    			else if(OPx==OP_2)
;;;258    			{
;;;259    				 OP->OP2_CON |= (uint32_t)OP_CON_ENOP;
;;;260    			}
;;;261            
;;;262        }
;;;263        else
;;;264        {
;;;265            /* Disable the OP Function */
;;;266    			if(OPx==OP_0)
;;;267    			{
;;;268    				 OP->OP0_CON &= (uint32_t)~OP_CON_ENOP;
;;;269    			}
;;;270    			else if(OPx==OP_1)
;;;271    			{
;;;272    				 OP->OP1_CON &= (uint32_t)~OP_CON_ENOP;
;;;273    			}
;;;274    			else if(OPx==OP_2)
;;;275    			{
;;;276    				 OP->OP2_CON &= (uint32_t)~OP_CON_ENOP;
;;;277    			}
;;;278        }
;;;279    #endif
;;;280    }
00000c  4770              BX       lr
                  |L1.14|
00000e  6801              LDR      r1,[r0,#0]            ;239
000010  4a01              LDR      r2,|L1.24|
000012  4011              ANDS     r1,r1,r2              ;239
000014  6001              STR      r1,[r0,#0]            ;239
000016  4770              BX       lr
;;;281    
                          ENDP

                  |L1.24|
                          DCD      0x0000fffe

                          AREA ||i.OP_DeInit||, CODE, READONLY, ALIGN=2

                  OP_DeInit PROC
;;;50      */
;;;51     void OP_DeInit ( OP_TypeDef* OPx )
000000  4903              LDR      r1,|L2.16|
;;;52     {
;;;53     #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806) || defined (SC32R803)
;;;54         uint32_t tmpreg;
;;;55         /* Check the parameters */
;;;56         assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;57     
;;;58         if ( OPx == OP )
000002  4288              CMP      r0,r1
000004  d102              BNE      |L2.12|
;;;59         {
;;;60             /* Get the OPx OP_CON value */
;;;61             tmpreg = OPx->OP_CON;
000006  6801              LDR      r1,[r0,#0]
;;;62     
;;;63             /* Set OPFS bit to OP_FreqSelect value */
;;;64             tmpreg &= 0x00000000;
000008  2100              MOVS     r1,#0
;;;65     
;;;66             /* Write to OPx OP_CON */
;;;67             OPx->OP_CON = ( uint32_t ) tmpreg;
00000a  6001              STR      r1,[r0,#0]
                  |L2.12|
;;;68         }
;;;69     #elif defined (SC32f15xx)
;;;70     			/* Check the parameters */
;;;71     		assert_param(IS_OP_ALL_PERIPH(OPx)); 
;;;72     
;;;73     		if (OPx==OP_0)
;;;74     		{
;;;75     		 OP->OP0_CON = (uint32_t)0x00;
;;;76     		}       
;;;77     		else if (OPx==OP_1)
;;;78     		{
;;;79     		 OP->OP1_CON = (uint32_t)0x00;
;;;80     		}
;;;81     		else if (OPx==OP_2)
;;;82     		{
;;;83     		 OP->OP2_CON = (uint32_t)0x00;
;;;84     		}
;;;85     
;;;86     			OP->OPX_CFG = (uint32_t)0x00;
;;;87     			OP->OPX_IDE = (uint32_t)0x00;
;;;88     			OP->OPX_STS = (uint32_t)0x06;
;;;89     #endif
;;;90     }
00000c  4770              BX       lr
;;;91     
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40022140

                          AREA ||i.OP_GainSelection||, CODE, READONLY, ALIGN=1

                  OP_GainSelection PROC
;;;385      */
;;;386    void OP_GainSelection ( OP_TypeDef* OPx, OP_PGAGain_TypeDef PGAGain )
000000  6802              LDR      r2,[r0,#0]
;;;387    {
;;;388    #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)|| defined (SC32R803)
;;;389        /* Check the parameters */
;;;390        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;391        assert_param ( IS_OP_PGAGain ( PGAGain ) );
;;;392    
;;;393    
;;;394        OPx->OP_CON &= ~ ( OP_CON_PGAGAIN );
000002  2303              MOVS     r3,#3
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;395        OPx->OP_CON |= PGAGain;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;396    #elif defined (SC32f15xx)
;;;397      /* Check the parameters */
;;;398      assert_param(IS_OP_ALL_PERIPH(OPx)); 
;;;399      assert_param( IS_OP_GAN(PGAGain) );
;;;400    
;;;401      if(OPx==OP_0)
;;;402    	{
;;;403    			OP->OP0_CON &= ~OP_CON_PGAGAIN;
;;;404    			OP->OP0_CON |= PGAGain;
;;;405    	}
;;;406    	else if(OPx==OP_1)
;;;407    	{
;;;408    			OP->OP1_CON &= ~OP_CON_PGAGAIN;
;;;409    			OP->OP1_CON |=  PGAGain;
;;;410    	}
;;;411    	else if(OPx==OP_2)
;;;412    	{
;;;413    			OP->OP2_CON &= ~OP_CON_PGAGAIN;
;;;414    			OP->OP2_CON |= PGAGain;
;;;415    	}
;;;416    #endif
;;;417    
;;;418    }
000010  4770              BX       lr
;;;419    
                          ENDP


                          AREA ||i.OP_Init||, CODE, READONLY, ALIGN=2

                  OP_Init PROC
;;;105     */
;;;106    void OP_Init ( OP_TypeDef* OPx, OP_InitTypeDef* OP_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;107    {
;;;108    #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)|| defined (SC32R803)
;;;109        uint32_t tmpreg;
;;;110        /* Check the parameters */
;;;111        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;112        assert_param ( IS_OP_Output ( Output ) );
;;;113        assert_param ( IS_OP_Negative ( Negative ) );
;;;114        assert_param ( IS_OP_Posittive ( Posittive ) );
;;;115        assert_param ( IS_OP_PGAGain ( PGAGain ) );
;;;116        assert_param ( IS_OP_FDBResisrance ( FDBResisrance ) );
;;;117        assert_param ( IS_OP_ShortCircuit ( ShortCircuit ) );
;;;118    
;;;119        /*---------------------------- OPx OP_CON Configuration ------------------------*/
;;;120        /* Get the OPx OP_CON value */
;;;121        tmpreg = OPx->OP_CON;
000002  6802              LDR      r2,[r0,#0]
;;;122    
;;;123        /* Clear OPFS bits */
;;;124        tmpreg &= ( uint32_t ) ~ ( OP_CON_OPOSEL | OP_CON_OPNSEL | OP_CON_OPPSEL
000004  4b07              LDR      r3,|L4.36|
000006  401a              ANDS     r2,r2,r3
;;;125                                   | OP_CON_PGAGAIN | OP_CON_FDBRSEL | OP_CON_PGAOFC );
;;;126        /* Set OPFS bit to OP_FreqSelect value */
;;;127        tmpreg |= ( uint32_t ) ( OP_InitStruct->OP_FDBResisrance | OP_InitStruct->OP_Negative | OP_InitStruct->OP_Output |
000008  888b              LDRH     r3,[r1,#4]
00000a  894c              LDRH     r4,[r1,#0xa]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4323              ORRS     r3,r3,r4
000010  898c              LDRH     r4,[r1,#0xc]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  890c              LDRH     r4,[r1,#8]
000018  6809              LDR      r1,[r1,#0]
00001a  4323              ORRS     r3,r3,r4
00001c  430b              ORRS     r3,r3,r1
00001e  4313              ORRS     r3,r3,r2
;;;128                                 OP_InitStruct->OP_PGAGain | OP_InitStruct->OP_Posittive | OP_InitStruct->OP_ShortCircuit );
;;;129    
;;;130        /* Write to OPx OP_CON */
;;;131        OPx->OP_CON = tmpreg;
000020  6003              STR      r3,[r0,#0]
;;;132    #elif defined (SC32f15xx)
;;;133        uint32_t tmpreg;
;;;134       
;;;135        /* Check the parameters */
;;;136        assert_param(IS_OP_ALL_PERIPH(OPx));;
;;;137        assert_param(IS_OP_INVERTINPUT(OP_InitStruct->OP_NonInvertInput));
;;;138        assert_param(IS_OP_GAN(OP_InitStruct->OP_GAN));
;;;139    
;;;140        /*---------------------------- OPx_CON Configuration ------------------------*/
;;;141        /* Get the OPx OP_CON value */
;;;142        if(OPx==OP_0)  tmpreg =  OP->OP0_CON ;
;;;143    	  else if(OPx==OP_1)  tmpreg =  OP->OP1_CON ;
;;;144        else if(OPx==OP_2)  tmpreg =  OP->OP2_CON ;
;;;145        
;;;146        tmpreg &= (uint32_t)~(OP_CON_OPOSEL | OP_CON_OPNSEL | OP_CON_OPPSEL |
;;;147                              OP_CON_PGAGAIN | OP_CON_OPRF | OP_CON_FDBRSEL);
;;;148    
;;;149        tmpreg |= (uint32_t)(OP_InitStruct->OP_OutputPin | OP_InitStruct->OP_InvertInput |
;;;150                             OP_InitStruct->OP_NonInvertInput | OP_InitStruct->OP_PGAGain |
;;;151                             OP_InitStruct->OP_OPRF | OP_InitStruct->OP_FDBR);
;;;152    			
;;;153    	  if(OPx==OP_0)
;;;154    		{
;;;155          if(OP_InitStruct->OP_InvertInput == OP_InvertInput_Res )
;;;156    		  {
;;;157    				    GPIOB->PXCON &= (uint32_t)(~0x0002);
;;;158    	        	GPIOB->PXPH &= (uint32_t)(~0x0002);	
;;;159    		  }
;;;160    			 OP->OP0_CON = tmpreg ;
;;;161    
;;;162    		}
;;;163    	  else if(OPx==OP_1)
;;;164    		{
;;;165    			if(OP_InitStruct->OP_InvertInput == OP_InvertInput_Res )
;;;166    		  {
;;;167    				    GPIOB->PXCON &= (uint32_t)(~0x0010);
;;;168    	        	GPIOB->PXPH &= (uint32_t)(~0x0010);	
;;;169    		  }
;;;170    			 OP->OP1_CON = tmpreg;
;;;171    			 OP->OPX_CFG &= (uint32_t)~OP_CFG_OPCMPIM1;
;;;172           OP->OPX_CFG |= (OP_InitStruct->OP_CMPIM1 << OP_CFG_OPCMPIM1_Pos)|(OP_InitStruct->OP_REFSEL << OP_CFG_REFSEL_Pos);
;;;173    		
;;;174    		}
;;;175        else if(OPx==OP_2)
;;;176    		{
;;;177    			if(OP_InitStruct->OP_InvertInput == OP_InvertInput_Res )
;;;178    		  {
;;;179    				    GPIOB->PXCON &= (uint32_t)(~0x0800);
;;;180    	        	GPIOB->PXPH &= (uint32_t)(~0x0800);	
;;;181    		  }
;;;182    			 OP->OP2_CON = tmpreg;
;;;183    			 OP->OPX_CFG &= (uint32_t)~OP_CFG_OPCMPIM2;
;;;184           OP->OPX_CFG |= (OP_InitStruct->OP_CMPIM2 << OP_CFG_OPCMPIM2_Pos)|(OP_InitStruct->OP_REFSEL << OP_CFG_REFSEL_Pos);
;;;185    		}
;;;186    #endif
;;;187    }
000022  bd30              POP      {r4,r5,pc}
;;;188    #if defined (SC32f15xx)
                          ENDP

                  |L4.36|
                          DCD      0xff7c0c15

                          AREA ||i.OP_OffsetSet||, CODE, READONLY, ALIGN=2

                  OP_OffsetSet PROC
;;;476     */
;;;477    ErrorStatus OP_OffsetSet(OP_TypeDef* OPx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;478    {
;;;479    		uint8_t OPx_Readoffset0,OPx_Readoffset1,OPx_Readoffset2,OPx_Readoffset3;
;;;480    	  uint16_t OPx_offsetchecksum0,OPx_offsetchecksum1;
;;;481    	  OPx_Readoffset0 =  *((uint8_t *)0X08C00000+0x480);
000002  490f              LDR      r1,|L5.64|
000004  780b              LDRB     r3,[r1,#0]
;;;482    	  OPx_Readoffset1 =  *((uint8_t *)0X08C00000+0x481);
000006  784c              LDRB     r4,[r1,#1]
;;;483    	  OPx_Readoffset2 =  *((uint8_t *)0X08C00000+0x482);
000008  788d              LDRB     r5,[r1,#2]
;;;484    	  OPx_Readoffset3 =  *((uint8_t *)0X08C00000+0x483);
00000a  78ca              LDRB     r2,[r1,#3]
;;;485    	  OPx_offsetchecksum0 = (*((uint8_t *)0X08C00000+0x480))+(*((uint8_t *)0X08C00000+0x481))+(*((uint8_t *)0X08C00000+0x482))+(*((uint8_t *)0X08C00000+0x483));
00000c  191e              ADDS     r6,r3,r4
00000e  18af              ADDS     r7,r5,r2
000010  19f7              ADDS     r7,r6,r7
;;;486    	  OPx_offsetchecksum1 = ((*((uint8_t *)0X08C00000+0x484))<<8)|(*((uint8_t *)0X08C00000+0x485));
000012  790e              LDRB     r6,[r1,#4]
000014  7949              LDRB     r1,[r1,#5]
000016  0236              LSLS     r6,r6,#8
000018  430e              ORRS     r6,r6,r1
;;;487        if (( OPx_Readoffset0==0x55 )&&( OPx_Readoffset2==0x55 )&&(OPx_offsetchecksum0==OPx_offsetchecksum1))
00001a  2b55              CMP      r3,#0x55
00001c  d10d              BNE      |L5.58|
00001e  2d55              CMP      r5,#0x55
000020  d10b              BNE      |L5.58|
000022  42b7              CMP      r7,r6
000024  d109              BNE      |L5.58|
;;;488        {
;;;489    	      uint32_t tmpreg = 0;
;;;490            /*!< Get the OPAMPx_CSR register value */
;;;491           tmpreg = OPx->OP_CON;
000026  6801              LDR      r1,[r0,#0]
;;;492    
;;;493           /*!< Clear the trimming bits */
;;;494           tmpreg &= ( uint32_t ) ~ ( ( OP_CON_TRIMOFFSETN | OP_CON_TRIMOFFSETP ) );
000028  4b06              LDR      r3,|L5.68|
00002a  4019              ANDS     r1,r1,r3
;;;495    
;;;496           /*!< Configure the new trimming value */
;;;497           tmpreg |= ( uint32_t ) ( ( OPx_Readoffset3 << OP_CON_TRIMOFFSETN_Pos ) | ( OPx_Readoffset1 << OP_CON_TRIMOFFSETP_Pos ) );
00002c  0612              LSLS     r2,r2,#24
00002e  0423              LSLS     r3,r4,#16
000030  431a              ORRS     r2,r2,r3
000032  430a              ORRS     r2,r2,r1
;;;498    
;;;499           /*!< Write to OPAMPx_CSR register */
;;;500            OPx->OP_CON = tmpreg;
000034  6002              STR      r2,[r0,#0]
;;;501            return SUCCESS;
000036  2000              MOVS     r0,#0
;;;502        }
;;;503        else
;;;504        {
;;;505            return ERROR;
;;;506        }
;;;507    }
000038  bdf0              POP      {r4-r7,pc}
                  |L5.58|
00003a  2001              MOVS     r0,#1                 ;505
00003c  bdf0              POP      {r4-r7,pc}
;;;508    #elif defined(SC32f15xx)||defined(SC32R601)
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x08c00480
                  |L5.68|
                          DCD      0xe0e0ffff

                          AREA ||i.OP_OffsetTrimConfig||, CODE, READONLY, ALIGN=2

                  OP_OffsetTrimConfig PROC
;;;295      */
;;;296    void OP_OffsetTrimConfig ( OP_TypeDef* OPx,  uint32_t OP_TrimValueH, uint32_t OP_TrimValueL )
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298    #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)|| defined (SC32R803)
;;;299        uint32_t tmpreg = 0;
;;;300    
;;;301        /* Check the parameters */
;;;302        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;303    
;;;304    
;;;305        /*!< Get the OPAMPx_CSR register value */
;;;306        tmpreg = OPx->OP_CON;
000002  6803              LDR      r3,[r0,#0]
;;;307    
;;;308        /*!< Clear the trimming bits */
;;;309        tmpreg &= ( uint32_t ) ~ ( ( OP_CON_TRIMOFFSETP | OP_CON_TRIMOFFSETN ) );
000004  4c03              LDR      r4,|L6.20|
000006  4023              ANDS     r3,r3,r4
;;;310    
;;;311        /*!< Configure the new trimming value */
;;;312        tmpreg |= ( uint32_t ) ( ( OP_TrimValueL << OP_CON_TRIMOFFSETP_Pos ) | ( OP_TrimValueH << OP_CON_TRIMOFFSETN_Pos ) );
000008  0412              LSLS     r2,r2,#16
00000a  0609              LSLS     r1,r1,#24
00000c  430a              ORRS     r2,r2,r1
00000e  431a              ORRS     r2,r2,r3
;;;313    
;;;314        /*!< Write to OPAMPx_CSR register */
;;;315        OPx->OP_CON = tmpreg;
000010  6002              STR      r2,[r0,#0]
;;;316    #elif defined (SC32f15xx)
;;;317      uint32_t tmpreg = 0;
;;;318    
;;;319      /* Check the parameters */
;;;320      assert_param(IS_OP_ALL_PERIPH(OPx)); 
;;;321    	if(OPx==OP_0)
;;;322    	{
;;;323      tmpreg = OP->OP0_CON;
;;;324    
;;;325      /*!< Clear the trimming bits */
;;;326      tmpreg &= (uint32_t)~((OP_CON_TRIMOFFSETP | OP_CON_TRIMOFFSETN));
;;;327    
;;;328      /*!< Configure the new trimming value */
;;;329      tmpreg |= (uint32_t)((OP_TrimValueL<<OP_CON_TRIMOFFSETP_Pos)|(OP_TrimValueH<<OP_CON_TRIMOFFSETN_Pos));
;;;330    
;;;331      /*!< Write to OPAMPx_CSR register */
;;;332      OP->OP0_CON = tmpreg;
;;;333    	}
;;;334    	else if(OPx==OP_1)
;;;335    	{
;;;336      tmpreg = OP->OP1_CON;
;;;337    
;;;338      /*!< Clear the trimming bits */
;;;339      tmpreg &= (uint32_t)~((OP_CON_TRIMOFFSETP | OP_CON_TRIMOFFSETN));
;;;340    
;;;341      /*!< Configure the new trimming value */
;;;342      tmpreg |= (uint32_t)((OP_TrimValueL<<OP_CON_TRIMOFFSETP_Pos)|(OP_TrimValueH<<OP_CON_TRIMOFFSETN_Pos));
;;;343    
;;;344      /*!< Write to OPAMPx_CSR register */
;;;345      OP->OP1_CON = tmpreg;
;;;346    	}
;;;347    	else if(OPx==OP_2)
;;;348    	{
;;;349      tmpreg = OP->OP2_CON;
;;;350    
;;;351      /*!< Clear the trimming bits */
;;;352      tmpreg &= (uint32_t)~((OP_CON_TRIMOFFSETP | OP_CON_TRIMOFFSETN));
;;;353    
;;;354      /*!< Configure the new trimming value */
;;;355      tmpreg |= (uint32_t)((OP_TrimValueL<<OP_CON_TRIMOFFSETP_Pos)|(OP_TrimValueH<<OP_CON_TRIMOFFSETN_Pos));
;;;356    
;;;357      /*!< Write to OPAMPx_CSR register */
;;;358      OP->OP2_CON = tmpreg;
;;;359    	}
;;;360    
;;;361      /*!< Get the OPAMPx_CSR register value */
;;;362    #endif
;;;363    }
000012  bd10              POP      {r4,pc}
;;;364    
                          ENDP

                  |L6.20|
                          DCD      0xe0e0ffff

                          AREA ||i.OP_OutputSelection||, CODE, READONLY, ALIGN=1

                  OP_OutputSelection PROC
;;;437      */
;;;438    void OP_OutputSelection ( OP_TypeDef* OPx, OP_Output_TypeDef OPOutput )
000000  6802              LDR      r2,[r0,#0]
;;;439    {
;;;440    #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)|| defined (SC32R803)
;;;441        /* Check the parameters */
;;;442        assert_param ( IS_OP_ALL_PERIPH ( OPx ) );
;;;443        assert_param ( IS_OP_Output ( OPOutput ) );
;;;444    
;;;445    
;;;446        OPx->OP_CON &= ~ ( OP_CON_OPOSEL );
000002  2302              MOVS     r3,#2
000004  439a              BICS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;447        OPx->OP_CON |= OPOutput;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;448    #elif defined (SC32f15xx)
;;;449      /* Check the parameters */
;;;450      assert_param(IS_OP_ALL_PERIPH(OPx));
;;;451      assert_param( IS_OP_OUTPUTPIN(OPOutput) );
;;;452    
;;;453      if(OPx==OP_0)
;;;454    	{
;;;455    		OP->OP0_CON &= ~OP_CON_OPOSEL;
;;;456    		OP->OP0_CON |= OPOutput;
;;;457    	}
;;;458    	else if(OPx==OP_1)
;;;459    	{
;;;460    		OP->OP1_CON &= ~OP_CON_OPOSEL;
;;;461    		OP->OP1_CON |=  OPOutput;
;;;462    	}
;;;463    	else if(OPx==OP_2)
;;;464    	{
;;;465    		OP->OP2_CON &= ~OP_CON_OPOSEL;
;;;466    		OP->OP2_CON |= OPOutput;
;;;467    	}
;;;468    #endif
;;;469    }
00000e  4770              BX       lr
;;;470    #if defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806)|| defined (SC32R803)
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_op.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_sc32f1xxx_op_c_e58096f1____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___14_sc32f1xxx_op_c_e58096f1____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_sc32f1xxx_op_c_e58096f1____REVSH|
#line 478
|__asm___14_sc32f1xxx_op_c_e58096f1____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
