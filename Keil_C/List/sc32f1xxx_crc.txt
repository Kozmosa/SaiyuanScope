; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_crc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_crc.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\sc32f1xxx_crc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_crc.c]
                          THUMB

                          AREA ||i.CRC_Accumulate||, CODE, READONLY, ALIGN=2

                  CRC_Accumulate PROC
;;;232      */
;;;233    uint32_t CRC_Accumulate ( CRC_InputData_Format_TypeDef InputDataFormat, uint32_t pBuffer[], uint32_t BufferLength )
000000  b510              PUSH     {r4,lr}
;;;234    {
000002  460b              MOV      r3,r1
000004  4604              MOV      r4,r0
000006  4611              MOV      r1,r2
;;;235        uint32_t index;      /* CRC input data buffer index */
;;;236        uint32_t temp = 0U;  /* CRC output (read from CRC->CRC_DRregister) */
000008  2000              MOVS     r0,#0
;;;237    
;;;238    
;;;239        switch ( InputDataFormat )
00000a  2c01              CMP      r4,#1
00000c  d00d              BEQ      |L1.42|
00000e  2c02              CMP      r4,#2
000010  d00f              BEQ      |L1.50|
000012  2c03              CMP      r4,#3
000014  d108              BNE      |L1.40|
;;;240        {
;;;241        case CRC_InputData_Format_WORDS:
;;;242            /* Enter Data to the CRC calculator */
;;;243            for ( index = 0U; index < BufferLength; index++ )
;;;244            {
;;;245                CRC->CRC_DR = pBuffer[index];
000016  4a09              LDR      r2,|L1.60|
000018  e003              B        |L1.34|
                  |L1.26|
00001a  0084              LSLS     r4,r0,#2
00001c  591c              LDR      r4,[r3,r4]
00001e  6014              STR      r4,[r2,#0]
000020  1c40              ADDS     r0,r0,#1              ;243
                  |L1.34|
000022  4288              CMP      r0,r1                 ;243
000024  d3f9              BCC      |L1.26|
;;;246            }
;;;247            temp = CRC->CRC_DR;
000026  6810              LDR      r0,[r2,#0]
                  |L1.40|
;;;248            break;
;;;249    
;;;250        case CRC_InputData_Format_BYTES:
;;;251            temp = CRC_Handle_8 ( ( uint8_t* ) pBuffer, BufferLength );
;;;252            break;
;;;253    
;;;254        case CRC_InputData_Format_HALFWORDS:
;;;255            temp = CRC_Handle_16 ( ( uint16_t* ) ( void* ) pBuffer, BufferLength ); /* Derogation MisraC2012 R.11.5 */
;;;256            break;
;;;257        }
;;;258    
;;;259        /* Return the CRC computed value */
;;;260        return temp;
;;;261    }
000028  bd10              POP      {r4,pc}
                  |L1.42|
00002a  4618              MOV      r0,r3                 ;251
00002c  f7fffffe          BL       CRC_Handle_8
000030  bd10              POP      {r4,pc}
                  |L1.50|
000032  4618              MOV      r0,r3                 ;255
000034  f7fffffe          BL       CRC_Handle_16
000038  bd10              POP      {r4,pc}
;;;262    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40002000

                          AREA ||i.CRC_CalcCRC||, CODE, READONLY, ALIGN=2

                  CRC_CalcCRC PROC
;;;169      */
;;;170    uint32_t CRC_CalcCRC ( uint32_t CRC_Data )
000000  4901              LDR      r1,|L2.8|
;;;171    {
;;;172        /* Write to CRC_DR */
;;;173        CRC->CRC_DR = CRC_Data;
000002  6008              STR      r0,[r1,#0]
;;;174    
;;;175        return ( CRC->CRC_DR );
000004  6808              LDR      r0,[r1,#0]
;;;176    }
000006  4770              BX       lr
;;;177    
                          ENDP

                  |L2.8|
                          DCD      0x40002000

                          AREA ||i.CRC_CalcCRC16bits||, CODE, READONLY, ALIGN=2

                  CRC_CalcCRC16bits PROC
;;;182      */
;;;183    uint32_t CRC_CalcCRC16bits ( uint16_t CRC_Data )
000000  4901              LDR      r1,|L3.8|
;;;184    {
;;;185        * ( volatile uint16_t* ) ( &CRC->CRC_DR ) = ( uint16_t ) CRC_Data;
000002  8008              STRH     r0,[r1,#0]
;;;186    
;;;187        return ( CRC->CRC_DR );
000004  6808              LDR      r0,[r1,#0]
;;;188    }
000006  4770              BX       lr
;;;189    
                          ENDP

                  |L3.8|
                          DCD      0x40002000

                          AREA ||i.CRC_CalcCRC8bits||, CODE, READONLY, ALIGN=2

                  CRC_CalcCRC8bits PROC
;;;194      */
;;;195    uint32_t CRC_CalcCRC8bits ( uint8_t CRC_Data )
000000  4901              LDR      r1,|L4.8|
;;;196    {
;;;197        * ( volatile uint8_t* ) ( &CRC->CRC_DR ) = ( uint8_t ) CRC_Data;
000002  7008              STRB     r0,[r1,#0]
;;;198        return ( CRC->CRC_DR );
000004  6808              LDR      r0,[r1,#0]
;;;199    }
000006  4770              BX       lr
;;;200    
                          ENDP

                  |L4.8|
                          DCD      0x40002000

                          AREA ||i.CRC_Calculate||, CODE, READONLY, ALIGN=2

                  CRC_Calculate PROC
;;;275      */
;;;276    uint32_t CRC_Calculate ( CRC_InputData_Format_TypeDef InputDataFormat, uint32_t pBuffer[], uint32_t BufferLength )
000000  b570              PUSH     {r4-r6,lr}
;;;277    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;278        uint32_t index;      /* CRC input data buffer index */
;;;279        uint32_t temp = 0U;  /* CRC output (read from CRC->CRC_DRregister) */
000008  2600              MOVS     r6,#0
;;;280    
;;;281    
;;;282        /* Reset CRC Calculation Unit */
;;;283        CRC_ResetDR();
00000a  f7fffffe          BL       CRC_ResetDR
;;;284    
;;;285        switch ( InputDataFormat )
00000e  2b01              CMP      r3,#1
000010  d00e              BEQ      |L5.48|
000012  2b02              CMP      r3,#2
000014  d012              BEQ      |L5.60|
000016  2b03              CMP      r3,#3
000018  d115              BNE      |L5.70|
;;;286        {
;;;287        case CRC_InputData_Format_WORDS:
;;;288            /* Enter 32-bit input data to the CRC calculator */
;;;289            for ( index = 0U; index < BufferLength; index++ )
00001a  2000              MOVS     r0,#0
;;;290            {
;;;291                CRC->CRC_DR = pBuffer[index];
00001c  490b              LDR      r1,|L5.76|
00001e  e003              B        |L5.40|
                  |L5.32|
000020  0082              LSLS     r2,r0,#2
000022  58a2              LDR      r2,[r4,r2]
000024  600a              STR      r2,[r1,#0]
000026  1c40              ADDS     r0,r0,#1              ;289
                  |L5.40|
000028  42a8              CMP      r0,r5                 ;289
00002a  d3f9              BCC      |L5.32|
;;;292            }
;;;293            temp = CRC->CRC_DR;
00002c  680e              LDR      r6,[r1,#0]
;;;294            break;
00002e  e00a              B        |L5.70|
                  |L5.48|
;;;295    
;;;296        case CRC_InputData_Format_BYTES:
;;;297            /* Specific 8-bit input data handling  */
;;;298            temp = CRC_Handle_8 ( ( uint8_t* ) pBuffer, BufferLength );
000030  4629              MOV      r1,r5
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       CRC_Handle_8
000038  4606              MOV      r6,r0
;;;299            break;
00003a  e004              B        |L5.70|
                  |L5.60|
;;;300    
;;;301        case CRC_InputData_Format_HALFWORDS:
;;;302            /* Specific 16-bit input data handling  */
;;;303            temp = CRC_Handle_16 ( ( uint16_t* ) ( void* ) pBuffer, BufferLength ); /* Derogation MisraC2012 R.11.5 */
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       CRC_Handle_16
000044  4606              MOV      r6,r0
                  |L5.70|
;;;304            break;
;;;305        }
;;;306    
;;;307        /* Return the CRC computed value */
;;;308        return temp;
000046  4630              MOV      r0,r6
;;;309    }
000048  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x40002000

                          AREA ||i.CRC_DeInit||, CODE, READONLY, ALIGN=1

                  CRC_DeInit PROC
;;;46      */
;;;47     void CRC_DeInit ( void )
000000  b510              PUSH     {r4,lr}
;;;48     {
;;;49         RCC_AHBPeriphResetCmd ( RCC_AHBPeriph_CRC, ENABLE );
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;50         RCC_AHBPeriphResetCmd ( RCC_AHBPeriph_CRC, DISABLE );
00000a  2100              MOVS     r1,#0
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;51     }
000012  bd10              POP      {r4,pc}
;;;52     
                          ENDP


                          AREA ||i.CRC_GetCRC||, CODE, READONLY, ALIGN=2

                  CRC_GetCRC PROC
;;;210     */
;;;211    uint32_t CRC_GetCRC ( void )
000000  4801              LDR      r0,|L7.8|
;;;212    {
;;;213        return ( CRC->CRC_DR );
000002  6800              LDR      r0,[r0,#0]
;;;214    }
000004  4770              BX       lr
;;;215    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x40002000

                          AREA ||i.CRC_Handle_16||, CODE, READONLY, ALIGN=2

                  CRC_Handle_16 PROC
;;;367      */
;;;368    static uint32_t CRC_Handle_16 ( uint16_t pBuffer[], uint32_t BufferLength )
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
;;;370        uint32_t i;  /* input data buffer index */
;;;371        __IO uint16_t* pReg;
;;;372    
;;;373        /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
;;;374         * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
;;;375         * a correct type handling by the peripheral */
;;;376        for ( i = 0U; i < ( BufferLength / 2U ); i++ )
000002  2200              MOVS     r2,#0
;;;377        {
;;;378            CRC->CRC_DR = ( ( uint32_t ) pBuffer[2U * i] << 16U ) | ( uint32_t ) pBuffer[ ( 2U * i ) + 1U];
000004  4d0a              LDR      r5,|L8.48|
000006  084c              LSRS     r4,r1,#1              ;376
000008  e009              B        |L8.30|
                  |L8.10|
00000a  0093              LSLS     r3,r2,#2
00000c  5ac3              LDRH     r3,[r0,r3]
00000e  0056              LSLS     r6,r2,#1
000010  041b              LSLS     r3,r3,#16
000012  1c76              ADDS     r6,r6,#1
000014  0076              LSLS     r6,r6,#1
000016  5b86              LDRH     r6,[r0,r6]
000018  4333              ORRS     r3,r3,r6
00001a  602b              STR      r3,[r5,#0]
00001c  1c52              ADDS     r2,r2,#1              ;376
                  |L8.30|
00001e  4294              CMP      r4,r2                 ;376
000020  d8f3              BHI      |L8.10|
;;;379        }
;;;380        if ( ( BufferLength % 2U ) != 0U )
000022  07c9              LSLS     r1,r1,#31
000024  d002              BEQ      |L8.44|
;;;381        {
;;;382            pReg = ( __IO uint16_t* ) ( __IO void* ) ( &CRC->CRC_DR );           /* Derogation MisraC2012 R.11.5 */
;;;383            *pReg = pBuffer[2U * i];
000026  0091              LSLS     r1,r2,#2
000028  5a40              LDRH     r0,[r0,r1]
00002a  8028              STRH     r0,[r5,#0]
                  |L8.44|
;;;384        }
;;;385    
;;;386        /* Return the CRC computed value */
;;;387        return CRC->CRC_DR;
00002c  6828              LDR      r0,[r5,#0]
;;;388    }
00002e  bd70              POP      {r4-r6,pc}
;;;389    
                          ENDP

                  |L8.48|
                          DCD      0x40002000

                          AREA ||i.CRC_Handle_8||, CODE, READONLY, ALIGN=2

                  CRC_Handle_8 PROC
;;;317      */
;;;318    static uint32_t CRC_Handle_8 ( uint8_t pBuffer[], uint32_t BufferLength )
000000  b5f0              PUSH     {r4-r7,lr}
;;;319    {
;;;320        uint32_t i; /* input data buffer index */
;;;321        uint16_t data;
;;;322        __IO uint16_t* pReg;
;;;323    
;;;324        /* Processing time optimization: 4 bytes are entered in a row with a single word write,
;;;325         * last bytes must be carefully fed to the CRC calculator to ensure a correct type
;;;326         * handling by the peripheral */
;;;327        for ( i = 0U; i < ( BufferLength / 4U ); i++ )
000002  2200              MOVS     r2,#0
;;;328        {
;;;329            CRC->CRC_DR = ( ( uint32_t ) pBuffer[4U * i] << 24U ) | \
000004  4e19              LDR      r6,|L9.108|
000006  088f              LSRS     r7,r1,#2              ;327
000008  e00d              B        |L9.38|
                  |L9.10|
00000a  0094              LSLS     r4,r2,#2
00000c  1823              ADDS     r3,r4,r0
00000e  5d04              LDRB     r4,[r0,r4]
000010  78dd              LDRB     r5,[r3,#3]
000012  0624              LSLS     r4,r4,#24
000014  4325              ORRS     r5,r5,r4
000016  785c              LDRB     r4,[r3,#1]
000018  789b              LDRB     r3,[r3,#2]
00001a  0424              LSLS     r4,r4,#16
00001c  021b              LSLS     r3,r3,#8
00001e  431c              ORRS     r4,r4,r3
000020  4325              ORRS     r5,r5,r4
000022  6035              STR      r5,[r6,#0]
000024  1c52              ADDS     r2,r2,#1              ;327
                  |L9.38|
000026  4297              CMP      r7,r2                 ;327
000028  d8ef              BHI      |L9.10|
;;;330                          ( ( uint32_t ) pBuffer[ ( 4U * i ) + 1U] << 16U ) | \
;;;331                          ( ( uint32_t ) pBuffer[ ( 4U * i ) + 2U] << 8U )  | \
;;;332                          ( uint32_t ) pBuffer[ ( 4U * i ) + 3U];
;;;333        }
;;;334        /* last bytes specific handling */
;;;335        if ( ( BufferLength % 4U ) != 0U )
00002a  078b              LSLS     r3,r1,#30
00002c  d01b              BEQ      |L9.102|
;;;336        {
;;;337            if ( ( BufferLength % 4U ) == 1U )
00002e  078b              LSLS     r3,r1,#30
000030  0f9b              LSRS     r3,r3,#30
000032  2b01              CMP      r3,#1
000034  d102              BNE      |L9.60|
;;;338            {
;;;339                * ( __IO uint8_t* ) ( __IO void* ) ( &CRC->CRC_DR ) = pBuffer[4U * i];  /* Derogation MisraC2012 R.11.5 */
000036  0094              LSLS     r4,r2,#2
000038  5d04              LDRB     r4,[r0,r4]
00003a  7034              STRB     r4,[r6,#0]
                  |L9.60|
;;;340            }
;;;341            if ( ( BufferLength % 4U ) == 2U )
00003c  2b02              CMP      r3,#2
00003e  d106              BNE      |L9.78|
;;;342            {
;;;343                data = ( uint16_t ) ( ( ( uint16_t ) ( pBuffer[4U * i] ) << 8U ) | ( uint16_t ) pBuffer[ ( 4U * i ) + 1U] );
000040  0093              LSLS     r3,r2,#2
000042  5cc4              LDRB     r4,[r0,r3]
000044  0224              LSLS     r4,r4,#8
000046  181b              ADDS     r3,r3,r0
000048  785b              LDRB     r3,[r3,#1]
00004a  431c              ORRS     r4,r4,r3
;;;344                pReg = ( __IO uint16_t* ) ( __IO void* ) ( &CRC->CRC_DR );              /* Derogation MisraC2012 R.11.5 */
;;;345                *pReg = data;
00004c  8034              STRH     r4,[r6,#0]
                  |L9.78|
;;;346            }
;;;347            if ( ( BufferLength % 4U ) == 3U )
00004e  43c9              MVNS     r1,r1
000050  0789              LSLS     r1,r1,#30
000052  d108              BNE      |L9.102|
;;;348            {
;;;349                data = ( uint16_t ) ( ( ( uint16_t ) ( pBuffer[4U * i] ) << 8U ) | ( uint16_t ) pBuffer[ ( 4U * i ) + 1U] );
000054  0091              LSLS     r1,r2,#2
000056  5c42              LDRB     r2,[r0,r1]
000058  0212              LSLS     r2,r2,#8
00005a  1808              ADDS     r0,r1,r0
00005c  7841              LDRB     r1,[r0,#1]
00005e  430a              ORRS     r2,r2,r1
;;;350                pReg = ( __IO uint16_t* ) ( __IO void* ) ( &CRC->CRC_DR );              /* Derogation MisraC2012 R.11.5 */
;;;351                *pReg = data;
000060  8032              STRH     r2,[r6,#0]
;;;352    
;;;353                * ( __IO uint8_t* ) ( __IO void* ) ( &CRC->CRC_DR ) = pBuffer[ ( 4U * i ) + 2U]; /* Derogation MisraC2012 R.11.5 */
000062  7880              LDRB     r0,[r0,#2]
000064  7030              STRB     r0,[r6,#0]
                  |L9.102|
;;;354            }
;;;355        }
;;;356    
;;;357        /* Return the CRC computed value */
;;;358        return CRC->CRC_DR;
000066  6830              LDR      r0,[r6,#0]
;;;359    }
000068  bdf0              POP      {r4-r7,pc}
;;;360    
                          ENDP

00006a  0000              DCW      0x0000
                  |L9.108|
                          DCD      0x40002000

                          AREA ||i.CRC_Init||, CODE, READONLY, ALIGN=2

                  CRC_Init PROC
;;;57      */
;;;58     void CRC_Init ( CRC_InitTypeDef* CRC_InitStruct )
000000  8803              LDRH     r3,[r0,#0]
;;;59     {
;;;60         /*---------------------------- CRC_CON Configuration ------------------------*/
;;;61         /* check whether or not non-default generating polynomial has been
;;;62         * picked up by user */
;;;63         assert_param ( IS_CRC_POLYSIZE ( CRC_InitStruct->DefaultPolynomialUse ) );
;;;64         if ( CRC_InitStruct->DefaultPolynomialUse == DEFAULT_Polynomial_Enable )
;;;65         {
;;;66             /* initialize peripheral with default generating polynomial */
;;;67             CRC->CRC_POL = DEFAULT_CRC32_POLY;
;;;68     
;;;69             CRC->CRC_CON &= ( uint32_t ) ~CRC_CON_POLYSIZE;
000002  22c0              MOVS     r2,#0xc0
000004  490d              LDR      r1,|L10.60|
000006  2b00              CMP      r3,#0                 ;64
000008  d00e              BEQ      |L10.40|
;;;70         }
;;;71         else
;;;72         {
;;;73             /* Check the parameters */
;;;74             assert_param ( IS_CRC_POLYSIZE ( CRC_InitStruct->CRCSize ) );
;;;75     
;;;76             /* initialize CRC peripheral with generating polynomial defined by user */
;;;77             CRC->CRC_POL = CRC_InitStruct->GeneratingPolynomial;
00000a  6843              LDR      r3,[r0,#4]
00000c  60cb              STR      r3,[r1,#0xc]
;;;78     
;;;79             CRC->CRC_CON &= ( uint32_t ) ~CRC_CON_POLYSIZE;
00000e  684b              LDR      r3,[r1,#4]
000010  4393              BICS     r3,r3,r2
000012  604b              STR      r3,[r1,#4]
;;;80     
;;;81             /* Set CRC_CON bit to CRCSize value */
;;;82             CRC->CRC_CON |= ( uint32_t ) CRC_InitStruct->CRCSize ;
000014  684a              LDR      r2,[r1,#4]
000016  68c3              LDR      r3,[r0,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  604a              STR      r2,[r1,#4]
                  |L10.28|
;;;83         }
;;;84     
;;;85         /* check whether or not non-default CRC initial value has been
;;;86          * picked up by user */
;;;87         assert_param ( IS_DEFAULT_INITVALUE ( CRC_InitStruct->DefaultInitValueUse ) );
;;;88         if ( CRC_InitStruct->DefaultInitValueUse == DEFAULT_InitValue_Enable )
00001c  8842              LDRH     r2,[r0,#2]
00001e  2a00              CMP      r2,#0
000020  d008              BEQ      |L10.52|
;;;89         {
;;;90             CRC->CRC_INT = DEFAULT_CRC_INITVALUE;
;;;91         }
;;;92         else
;;;93         {
;;;94             CRC->CRC_INT = CRC_InitStruct->InitValue;
000022  6880              LDR      r0,[r0,#8]
000024  6088              STR      r0,[r1,#8]
;;;95         }
;;;96     
;;;97     }
000026  4770              BX       lr
                  |L10.40|
000028  4b05              LDR      r3,|L10.64|
00002a  60cb              STR      r3,[r1,#0xc]          ;67
00002c  684b              LDR      r3,[r1,#4]            ;69
00002e  4393              BICS     r3,r3,r2              ;69
000030  604b              STR      r3,[r1,#4]            ;69
000032  e7f3              B        |L10.28|
                  |L10.52|
000034  2000              MOVS     r0,#0                 ;90
000036  43c0              MVNS     r0,r0                 ;90
000038  6088              STR      r0,[r1,#8]            ;90
00003a  4770              BX       lr
;;;98     
                          ENDP

                  |L10.60|
                          DCD      0x40002000
                  |L10.64|
                          DCD      0x04c11db7

                          AREA ||i.CRC_PolynomialSizeSelect||, CODE, READONLY, ALIGN=2

                  CRC_PolynomialSizeSelect PROC
;;;107      */
;;;108    void CRC_PolynomialSizeSelect ( CRC_POLYSIZE_TypeDef CRC_PolSize )
000000  4904              LDR      r1,|L11.20|
;;;109    {
;;;110        /* Check the parameter */
;;;111        assert_param ( IS_CRC_POLYSIZE ( CRC_PolSize ) );
;;;112    
;;;113        /* Reset POL_SIZE bits */
;;;114        CRC->CRC_CON &= ( uint32_t ) ~ ( ( uint32_t ) CRC_CON_POLYSIZE );
000002  684a              LDR      r2,[r1,#4]
000004  23c0              MOVS     r3,#0xc0
000006  439a              BICS     r2,r2,r3
000008  604a              STR      r2,[r1,#4]
;;;115        /* Set the polynomial size */
;;;116        CRC->CRC_CON |= ( uint32_t ) CRC_PolSize;
00000a  684a              LDR      r2,[r1,#4]
00000c  4302              ORRS     r2,r2,r0
00000e  604a              STR      r2,[r1,#4]
;;;117    }
000010  4770              BX       lr
;;;118    
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40002000

                          AREA ||i.CRC_ResetDR||, CODE, READONLY, ALIGN=2

                  CRC_ResetDR PROC
;;;155     */
;;;156    void CRC_ResetDR ( void )
000000  4802              LDR      r0,|L12.12|
;;;157    {
;;;158        /* Set CRCRST bit to CRC_CON */
;;;159        CRC->CRC_CON |= CRC_CON_CRCRST;
000002  6841              LDR      r1,[r0,#4]
000004  2201              MOVS     r2,#1
000006  4311              ORRS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;160    }
00000a  4770              BX       lr
;;;161    /**
                          ENDP

                  |L12.12|
                          DCD      0x40002000

                          AREA ||i.CRC_SetInitRegister||, CODE, READONLY, ALIGN=2

                  CRC_SetInitRegister PROC
;;;124      */
;;;125    void CRC_SetInitRegister ( uint32_t CRC_InitValue )
000000  4901              LDR      r1,|L13.8|
;;;126    {
;;;127        CRC->CRC_INT = CRC_InitValue;
000002  6088              STR      r0,[r1,#8]
;;;128    }
000004  4770              BX       lr
;;;129    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40002000

                          AREA ||i.CRC_SetPolynomial||, CODE, READONLY, ALIGN=2

                  CRC_SetPolynomial PROC
;;;134      */
;;;135    void CRC_SetPolynomial ( uint32_t CRC_Pol )
000000  4901              LDR      r1,|L14.8|
;;;136    {
;;;137        CRC->CRC_POL = CRC_Pol;
000002  60c8              STR      r0,[r1,#0xc]
;;;138    }
000004  4770              BX       lr
;;;139    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      0x40002000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_crc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_crc_c_3a35c564____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_crc_c_3a35c564____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_crc_c_3a35c564____REVSH|
#line 478
|__asm___15_sc32f1xxx_crc_c_3a35c564____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
