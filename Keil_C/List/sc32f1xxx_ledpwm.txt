; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_ledpwm.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_ledpwm.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\sc32f1xxx_ledpwm.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_ledpwm.c]
                          THUMB

                          AREA ||i.LEDPWM_ClearFlag||, CODE, READONLY, ALIGN=2

                  LEDPWM_ClearFlag PROC
;;;481     */
;;;482    void LEDPWM_ClearFlag ( uint16_t LEDPWM_FLAG )
000000  4901              LDR      r1,|L1.8|
;;;483    {
;;;484        /* Check the parameters */
;;;485        assert_param ( IS_GET_LEDPWM_FLAG ( LEDPWM_FLAG ) );
;;;486    
;;;487        /* Clear the flags */
;;;488        LEDPWM->LEDPWM_STS = ( uint16_t ) LEDPWM_FLAG;
000002  6088              STR      r0,[r1,#8]
;;;489    }
000004  4770              BX       lr
;;;490    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_Cmd||, CODE, READONLY, ALIGN=2

                  LEDPWM_Cmd PROC
;;;129     */
;;;130    void LEDPWM_Cmd ( FunctionalState NewState )
000000  4906              LDR      r1,|L2.28|
;;;131    {
;;;132        /* Check the parameters */
;;;133        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;134    
;;;135        if ( NewState != DISABLE )
000002  2800              CMP      r0,#0
000004  d004              BEQ      |L2.16|
;;;136        {
;;;137            /* Enable the LEDPWM Counter */
;;;138            LEDPWM->LEDPWM_CON |= LEDPWM_CON_ENPWM;
000006  6808              LDR      r0,[r1,#0]
000008  2280              MOVS     r2,#0x80
00000a  4310              ORRS     r0,r0,r2
00000c  6008              STR      r0,[r1,#0]
;;;139        }
;;;140        else
;;;141        {
;;;142            /* Disable the LEDPWM Counter */
;;;143            LEDPWM->LEDPWM_CON &= ( uint16_t ) ~LEDPWM_CON_ENPWM;
;;;144        }
;;;145    }
00000e  4770              BX       lr
                  |L2.16|
000010  6808              LDR      r0,[r1,#0]            ;143
000012  4a03              LDR      r2,|L2.32|
000014  4010              ANDS     r0,r0,r2              ;143
000016  6008              STR      r0,[r1,#0]            ;143
000018  4770              BX       lr
;;;146    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40022300
                  |L2.32|
                          DCD      0x0000ff7f

                          AREA ||i.LEDPWM_DeInit||, CODE, READONLY, ALIGN=1

                  LEDPWM_DeInit PROC
;;;44      */
;;;45     void LEDPWM_DeInit ( void )
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47         /* Enable LEDPWM reset state */
;;;48         RCC_APB2PeriphResetCmd ( RCC_APB2Periph_LEDPWM, ENABLE );
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;49         /* Disable LEDPWM reset state */
;;;50         RCC_APB2PeriphResetCmd ( RCC_APB2Periph_LEDPWM, DISABLE );
00000a  2100              MOVS     r1,#0
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;51     }
000012  bd10              POP      {r4,pc}
;;;52     
                          ENDP


                          AREA ||i.LEDPWM_GetCycle||, CODE, READONLY, ALIGN=2

                  LEDPWM_GetCycle PROC
;;;207     */
;;;208    uint8_t LEDPWM_GetCycle()
000000  4801              LDR      r0,|L4.8|
;;;209    {
;;;210        /* Get the period value of LEDPWM */
;;;211        return ( uint8_t ) LEDPWM->LEDPWM_CYCLE;
000002  6980              LDR      r0,[r0,#0x18]
000004  b2c0              UXTB     r0,r0
;;;212    }
000006  4770              BX       lr
;;;213    
                          ENDP

                  |L4.8|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_GetDuty||, CODE, READONLY, ALIGN=2

                  LEDPWM_GetDuty PROC
;;;356     */
;;;357    uint8_t LEDPWM_GetDuty ( LEDPWM_Channel_Typedef LEDPWM_Channel )
000000  b510              PUSH     {r4,lr}
;;;358    {
;;;359        uint8_t tmpvalue ;
;;;360        uint32_t tmpchannel;
;;;361        /* Check the parameters */
;;;362        assert_param ( IS_LEDPWM_CHANNEL ( LEDPWM_Channel ) );
;;;363    
;;;364        tmpchannel = 1;
000002  2101              MOVS     r1,#1
;;;365    #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;366        for ( tmpvalue = 0; tmpvalue < 32; tmpvalue++ )
;;;367        {
;;;368            if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;369            {
;;;370                return ( uint16_t ) ( LEDPWM->LEDPWM_DT[tmpvalue] );
;;;371            }
;;;372            tmpchannel = tmpchannel << 1;
;;;373        }
;;;374    #elif defined (SC32R803)
;;;375        if ( LEDPWM_Channel <= 0x80000000 )
000004  07ca              LSLS     r2,r1,#31
;;;376        {
;;;377            for ( tmpvalue = 0; tmpvalue < 32; tmpvalue++ )
;;;378            {
;;;379                if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;380                {
;;;381                    return ( uint16_t ) ( LEDPWM->LEDPWM_DT[tmpvalue] );
000006  4b17              LDR      r3,|L5.100|
000008  4290              CMP      r0,r2                 ;375
00000a  d80d              BHI      |L5.40|
00000c  2200              MOVS     r2,#0                 ;377
                  |L5.14|
00000e  4208              TST      r0,r1                 ;379
000010  d004              BEQ      |L5.28|
000012  0090              LSLS     r0,r2,#2
000014  18c0              ADDS     r0,r0,r3
000016  6b00              LDR      r0,[r0,#0x30]
000018  b2c0              UXTB     r0,r0
;;;382                }
;;;383                tmpchannel = tmpchannel << 1;
;;;384            }
;;;385        }
;;;386        else
;;;387        {
;;;388            for ( tmpvalue = 0; tmpvalue < 32; tmpvalue++ )
;;;389            {
;;;390                if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;391                {
;;;392                    return ( uint16_t ) ( LEDPWM->LEDPWM_DT[tmpvalue] );
;;;393                }
;;;394                tmpchannel = tmpchannel << 1;
;;;395            }
;;;396            for ( tmpvalue = 0; tmpvalue < 7; tmpvalue++ )
;;;397            {
;;;398                if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;399                {
;;;400                    return ( uint16_t ) ( LEDPWM->LEDPWM_DT[tmpvalue + 31] );
;;;401                }
;;;402                tmpchannel = tmpchannel << 1;
;;;403            }
;;;404        }
;;;405    #endif
;;;406        return 0;
;;;407    }
00001a  bd10              POP      {r4,pc}
                  |L5.28|
00001c  0049              LSLS     r1,r1,#1              ;383
00001e  1c52              ADDS     r2,r2,#1              ;377
000020  b2d2              UXTB     r2,r2                 ;377
000022  2a20              CMP      r2,#0x20              ;377
000024  d3f3              BCC      |L5.14|
000026  e01a              B        |L5.94|
                  |L5.40|
000028  2200              MOVS     r2,#0                 ;388
                  |L5.42|
00002a  4208              TST      r0,r1                 ;390
00002c  d004              BEQ      |L5.56|
00002e  0090              LSLS     r0,r2,#2              ;392
000030  18c0              ADDS     r0,r0,r3              ;392
000032  6b00              LDR      r0,[r0,#0x30]         ;392
000034  b2c0              UXTB     r0,r0                 ;392
000036  bd10              POP      {r4,pc}
                  |L5.56|
000038  0049              LSLS     r1,r1,#1              ;394
00003a  1c52              ADDS     r2,r2,#1              ;388
00003c  b2d2              UXTB     r2,r2                 ;388
00003e  2a20              CMP      r2,#0x20              ;388
000040  d3f3              BCC      |L5.42|
000042  2200              MOVS     r2,#0                 ;396
                  |L5.68|
000044  4208              TST      r0,r1                 ;398
000046  d005              BEQ      |L5.84|
000048  321f              ADDS     r2,r2,#0x1f           ;400
00004a  0090              LSLS     r0,r2,#2              ;400
00004c  18c0              ADDS     r0,r0,r3              ;400
00004e  6b00              LDR      r0,[r0,#0x30]         ;400
000050  b2c0              UXTB     r0,r0                 ;400
000052  bd10              POP      {r4,pc}
                  |L5.84|
000054  0049              LSLS     r1,r1,#1              ;402
000056  1c52              ADDS     r2,r2,#1              ;396
000058  b2d2              UXTB     r2,r2                 ;396
00005a  2a07              CMP      r2,#7                 ;396
00005c  d3f2              BCC      |L5.68|
                  |L5.94|
00005e  2000              MOVS     r0,#0                 ;406
000060  bd10              POP      {r4,pc}
;;;408    
                          ENDP

000062  0000              DCW      0x0000
                  |L5.100|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  LEDPWM_GetFlagStatus PROC
;;;458     */
;;;459    FlagStatus LEDPWM_GetFlagStatus ( uint16_t LEDPWM_FLAG )
000000  4601              MOV      r1,r0
;;;460    {
;;;461        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;462        /* Check the parameters */
;;;463        assert_param ( IS_LEDPWM_FLAG ( LEDPWM_FLAG ) );
;;;464    
;;;465        if ( ( LEDPWM->LEDPWM_STS & LEDPWM_FLAG ) != ( uint16_t ) RESET )
000004  4a02              LDR      r2,|L6.16|
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L6.14|
;;;466        {
;;;467            bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L6.14|
;;;468        }
;;;469        else
;;;470        {
;;;471            bitstatus = RESET;
;;;472        }
;;;473        return bitstatus;
;;;474    }
00000e  4770              BX       lr
;;;475    
                          ENDP

                  |L6.16|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_GetPrescaler||, CODE, READONLY, ALIGN=2

                  LEDPWM_GetPrescaler PROC
;;;185     */
;;;186    LEDPWM_Prescaler_TypeDef LEDPWM_GetPrescaler ( void )
000000  4802              LDR      r0,|L7.12|
;;;187    {
;;;188        /* Get the CKD value */
;;;189        return ( LEDPWM_Prescaler_TypeDef ) ( LEDPWM->LEDPWM_CON & LEDPWM_CON_PWMCLK );
000002  6800              LDR      r0,[r0,#0]
000004  0700              LSLS     r0,r0,#28
000006  0f00              LSRS     r0,r0,#28
;;;190    }
000008  4770              BX       lr
;;;191    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_ITConfig||, CODE, READONLY, ALIGN=2

                  LEDPWM_ITConfig PROC
;;;432     */
;;;433    void LEDPWM_ITConfig ( uint16_t LEDPWM_IT, FunctionalState NewState )
000000  4a06              LDR      r2,|L8.28|
;;;434    {
;;;435        /* Check the parameters */
;;;436        assert_param ( IS_LEDPWM_IT ( LEDPWM_IT ) );
;;;437        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;438    
;;;439        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L8.14|
;;;440        {
;;;441            /* Enable the Interrupt sources */
;;;442            LEDPWM->LEDPWM_CON |= LEDPWM_IT;
000006  6811              LDR      r1,[r2,#0]
000008  4301              ORRS     r1,r1,r0
00000a  6011              STR      r1,[r2,#0]
;;;443        }
;;;444        else
;;;445        {
;;;446            /* Disable the Interrupt sources */
;;;447            LEDPWM->LEDPWM_CON &= ( uint16_t ) ~LEDPWM_IT;
;;;448        }
;;;449    }
00000c  4770              BX       lr
                  |L8.14|
00000e  6811              LDR      r1,[r2,#0]            ;447
000010  43c0              MVNS     r0,r0                 ;447
000012  b280              UXTH     r0,r0                 ;447
000014  4001              ANDS     r1,r1,r0              ;447
000016  6011              STR      r1,[r2,#0]            ;447
000018  4770              BX       lr
;;;450    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_Init||, CODE, READONLY, ALIGN=2

                  LEDPWM_Init PROC
;;;80      */
;;;81     void LEDPWM_Init ( LEDPWM_InitTypeDef* LEDPWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83         uint32_t tmpreg;
;;;84     
;;;85         /*---------------------------- LEDPWM LEDPWM_CON Configuration ------------------------*/
;;;86         /* Get the LEDPWM LEDPWM_CON value */
;;;87         tmpreg = LEDPWM->LEDPWM_CON;
000002  4a0d              LDR      r2,|L9.56|
000004  6811              LDR      r1,[r2,#0]
;;;88         /* Clear LEDPWMCLK, LEDPWMMD0 and LEDPWMMD1 SPR bits */
;;;89         tmpreg &= ( uint32_t ) ~ ( LEDPWM_CON_PWMCLK | LEDPWM_CON_PWMMD0 );
000006  234f              MOVS     r3,#0x4f
000008  4399              BICS     r1,r1,r3
;;;90         /* Configure LEDPWM: Prescaler, AlignedMode and WorkMode */
;;;91         /* Set LEDPWMCLK bits according to Prescaler value */
;;;92         /* Set LEDPWMMD0 bit according to AlignedMode value */
;;;93         /* Set LEDPWMMD1 bit according to WorkMode value */
;;;94         tmpreg |= ( uint32_t ) ( LEDPWM_InitStruct->LEDPWM_Prescaler | LEDPWM_InitStruct->LEDPWM_AlignedMode );
00000a  8803              LDRH     r3,[r0,#0]
00000c  8844              LDRH     r4,[r0,#2]
00000e  4323              ORRS     r3,r3,r4
000010  430b              ORRS     r3,r3,r1
;;;95     
;;;96         /* Write to LEDPWM LEDPWM_CON */
;;;97         LEDPWM->LEDPWM_CON = tmpreg;
000012  6013              STR      r3,[r2,#0]
;;;98     #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;99         /* Write to LEDPWM LEDPWM_CHN */
;;;100        LEDPWM->LEDPWM_CHN = LEDPWM_InitStruct->LEDPWM_OutputChannel;
;;;101    
;;;102        /* Write to LEDPWM LEDPWM_INV */
;;;103        LEDPWM->LEDPWM_INV = LEDPWM_InitStruct->LEDPWM_LowPolarityChannl;
;;;104    #elif defined(SC32R803)
;;;105        if ( LEDPWM_InitStruct->LEDPWM_OutputChannel0 <= (uint32_t)LEDPWM_Channel_0_31 )
;;;106        {
;;;107            LEDPWM->LEDPWM_CHN0 = LEDPWM_InitStruct->LEDPWM_OutputChannel0;
000014  6981              LDR      r1,[r0,#0x18]
000016  6051              STR      r1,[r2,#4]
;;;108            /* Write to LEDPWM LEDPWM_INV */
;;;109            LEDPWM->LEDPWM_INV0 = LEDPWM_InitStruct->LEDPWM_LowPolarityChannl0;
000018  6a01              LDR      r1,[r0,#0x20]
00001a  60d1              STR      r1,[r2,#0xc]
;;;110        }
;;;111        /* Write to LEDPWM LEDPWM_CYCLE */
;;;112    
;;;113        if ( LEDPWM_InitStruct->LEDPWM_OutputChannel1 <=(uint32_t) LEDPWM_Channel_32_38 )
00001c  4b07              LDR      r3,|L9.60|
00001e  69c1              LDR      r1,[r0,#0x1c]
000020  4299              CMP      r1,r3
000022  d806              BHI      |L9.50|
;;;114        {
;;;115            LEDPWM->LEDPWM_CHN1 = LEDPWM_InitStruct->LEDPWM_OutputChannel1 & 0x7FFFFFFF;
000024  0049              LSLS     r1,r1,#1
000026  0849              LSRS     r1,r1,#1
000028  61d1              STR      r1,[r2,#0x1c]
;;;116            LEDPWM->LEDPWM_INV1 = LEDPWM_InitStruct->LEDPWM_LowPolarityChannl1 & 0x7FFFFFFF;
00002a  6a41              LDR      r1,[r0,#0x24]
00002c  0049              LSLS     r1,r1,#1
00002e  0849              LSRS     r1,r1,#1
000030  6211              STR      r1,[r2,#0x20]
                  |L9.50|
;;;117        }
;;;118    #endif
;;;119        /* Write to LEDPWM LEDPWM_CYCLE */
;;;120        LEDPWM->LEDPWM_CYCLE = LEDPWM_InitStruct->LEDPWM_Cycle;
000032  7900              LDRB     r0,[r0,#4]
000034  6190              STR      r0,[r2,#0x18]
;;;121    }
000036  bd10              POP      {r4,pc}
;;;122    
                          ENDP

                  |L9.56|
                          DCD      0x40022300
                  |L9.60|
                          DCD      0x8000007f

                          AREA ||i.LEDPWM_SetCycle||, CODE, READONLY, ALIGN=2

                  LEDPWM_SetCycle PROC
;;;197     */
;;;198    void LEDPWM_SetCycle ( uint8_t LEDPWM_Cycle )
000000  4901              LDR      r1,|L10.8|
;;;199    {
;;;200        /* Set the ReloadData Register value */
;;;201        LEDPWM->LEDPWM_CYCLE = LEDPWM_Cycle;
000002  6188              STR      r0,[r1,#0x18]
;;;202    }
000004  4770              BX       lr
;;;203    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_SetDuty||, CODE, READONLY, ALIGN=2

                  LEDPWM_SetDuty PROC
;;;264     */
;;;265    void LEDPWM_SetDuty ( LEDPWM_Channel_Typedef LEDPWM_Channel, uint8_t LEDPWM_Duty )
000000  b530              PUSH     {r4,r5,lr}
;;;266    {
;;;267        uint8_t tmpvalue;
;;;268        uint32_t tmpchannel;
;;;269        /* Check the parameters */
;;;270        assert_param ( IS_LEDPWM_CHANNEL ( LEDPWM_Channel ) );
;;;271    #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;272        tmpchannel = 1;
;;;273        for ( tmpvalue = 0; tmpvalue < 32; tmpvalue++ )
;;;274        {
;;;275            if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;276            {
;;;277                LEDPWM->LEDPWM_DT[tmpvalue] = LEDPWM_Duty;
;;;278            }
;;;279            tmpchannel = tmpchannel << 1;
;;;280        }
;;;281    #elif defined (SC32R803)
;;;282        if ( LEDPWM_Channel <= 0x80000000 )
000002  2301              MOVS     r3,#1
000004  07db              LSLS     r3,r3,#31
;;;283        {
;;;284            for ( tmpvalue = 0; tmpvalue < 32; tmpvalue++ )
;;;285            {
;;;286                if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;287                {
;;;288                    LEDPWM->LEDPWM_DT[tmpvalue] = LEDPWM_Duty;
000006  4c0e              LDR      r4,|L11.64|
000008  4298              CMP      r0,r3                 ;282
00000a  d80b              BHI      |L11.36|
00000c  2300              MOVS     r3,#0                 ;284
                  |L11.14|
00000e  4210              TST      r0,r2                 ;286
000010  d002              BEQ      |L11.24|
000012  009d              LSLS     r5,r3,#2
000014  192d              ADDS     r5,r5,r4
000016  6329              STR      r1,[r5,#0x30]
                  |L11.24|
;;;289                }
;;;290                tmpchannel = tmpchannel << 1;
000018  0052              LSLS     r2,r2,#1
00001a  1c5b              ADDS     r3,r3,#1              ;284
00001c  b2db              UXTB     r3,r3                 ;284
00001e  2b20              CMP      r3,#0x20              ;284
000020  d3f5              BCC      |L11.14|
;;;291            }
;;;292        }
;;;293        else
;;;294        {
;;;295            for ( tmpvalue = 0; tmpvalue < 7; tmpvalue++ )
;;;296            {
;;;297                if ( ( uint32_t ) LEDPWM_Channel & tmpchannel )
;;;298                {
;;;299                    LEDPWM->LEDPWM_DT[tmpvalue + 31] = LEDPWM_Duty;
;;;300                }
;;;301                tmpchannel = tmpchannel << 1;
;;;302            }
;;;303        }
;;;304    #endif
;;;305    }
000022  bd30              POP      {r4,r5,pc}
                  |L11.36|
000024  2300              MOVS     r3,#0                 ;295
                  |L11.38|
000026  4210              TST      r0,r2                 ;297
000028  d004              BEQ      |L11.52|
00002a  461d              MOV      r5,r3                 ;299
00002c  351f              ADDS     r5,r5,#0x1f           ;299
00002e  00ad              LSLS     r5,r5,#2              ;299
000030  192d              ADDS     r5,r5,r4              ;299
000032  6329              STR      r1,[r5,#0x30]         ;299
                  |L11.52|
000034  0052              LSLS     r2,r2,#1              ;301
000036  1c5b              ADDS     r3,r3,#1              ;295
000038  b2db              UXTB     r3,r3                 ;295
00003a  2b07              CMP      r3,#7                 ;295
00003c  d3f3              BCC      |L11.38|
00003e  bd30              POP      {r4,r5,pc}
;;;306    
                          ENDP

                  |L11.64|
                          DCD      0x40022300

                          AREA ||i.LEDPWM_SetPrescaler||, CODE, READONLY, ALIGN=2

                  LEDPWM_SetPrescaler PROC
;;;160     */
;;;161    void LEDPWM_SetPrescaler ( LEDPWM_Prescaler_TypeDef LEDPWM_Prescaler )
000000  4904              LDR      r1,|L12.20|
;;;162    {
;;;163        /* Check the parameters */
;;;164        assert_param ( IS_LEDPWM_PRESCALER ( LEDPWM_Prescaler ) );
;;;165    
;;;166        /* Reset the CKD Bits */
;;;167        LEDPWM->LEDPWM_CON &= ( uint16_t ) ~ ( LEDPWM_CON_PWMCLK );
000002  680a              LDR      r2,[r1,#0]
000004  4b04              LDR      r3,|L12.24|
000006  401a              ANDS     r2,r2,r3
000008  600a              STR      r2,[r1,#0]
;;;168    
;;;169        /* Set the CKD value */
;;;170        LEDPWM->LEDPWM_CON |= LEDPWM_Prescaler;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;171    }
000010  4770              BX       lr
;;;172    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40022300
                  |L12.24|
                          DCD      0x0000fff0

                          AREA ||i.LEDPWM_StructInit||, CODE, READONLY, ALIGN=1

                  LEDPWM_StructInit PROC
;;;57       */
;;;58     void LEDPWM_StructInit ( LEDPWM_InitTypeDef* LEDPWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;59     {
;;;60         /* Set the default configuration */
;;;61         LEDPWM_InitStruct->LEDPWM_AlignedMode = LEDPWM_AlignmentMode_Edge;
000002  8041              STRH     r1,[r0,#2]
;;;62         LEDPWM_InitStruct->LEDPWM_Cycle = 0x0000;
000004  7101              STRB     r1,[r0,#4]
;;;63     #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;64         LEDPWM_InitStruct->LEDPWM_LowPolarityChannl = LEDPWMChannel_Less;
;;;65         LEDPWM_InitStruct->LEDPWM_OutputChannel = LEDPWMChannel_Less;
;;;66     #elif defined(SC32R803)
;;;67         LEDPWM_InitStruct->LEDPWM_LowPolarityChannl0 = LEDPWMChannel_Less;
000006  6201              STR      r1,[r0,#0x20]
;;;68         LEDPWM_InitStruct->LEDPWM_OutputChannel0 = LEDPWMChannel_Less;
000008  6181              STR      r1,[r0,#0x18]
;;;69     
;;;70         LEDPWM_InitStruct->LEDPWM_LowPolarityChannl1 = LEDPWMChannel_Less;
00000a  6241              STR      r1,[r0,#0x24]
;;;71         LEDPWM_InitStruct->LEDPWM_OutputChannel1 = LEDPWMChannel_Less;
00000c  61c1              STR      r1,[r0,#0x1c]
;;;72     #endif
;;;73         LEDPWM_InitStruct->LEDPWM_Prescaler = LEDPWM_PRESCALER_DIV1;
00000e  8001              STRH     r1,[r0,#0]
;;;74     }
000010  4770              BX       lr
;;;75     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_ledpwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_sc32f1xxx_ledpwm_c_ac2904db____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___18_sc32f1xxx_ledpwm_c_ac2904db____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_sc32f1xxx_ledpwm_c_ac2904db____REVSH|
#line 478
|__asm___18_sc32f1xxx_ledpwm_c_ac2904db____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
