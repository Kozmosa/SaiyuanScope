; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_tim.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_tim.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\sc32f1xxx_tim.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_tim.c]
                          THUMB

                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;995     */
;;;996    void TIM_ClearFlag ( TIM_TypeDef* TIMx, uint16_t TIM_FLAG )
000000  60c1              STR      r1,[r0,#0xc]
;;;997    {
;;;998        /* Check the parameters */
;;;999        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;1000   
;;;1001       /* Clear the flags */
;;;1002       TIMx->TIM_STS = ( uint16_t ) TIM_FLAG;
;;;1003   }
000002  4770              BX       lr
;;;1004   
                          ENDP


                          AREA ||i.TIM_ClockOutputCmd||, CODE, READONLY, ALIGN=1

                  TIM_ClockOutputCmd PROC
;;;807     */
;;;808    void TIM_ClockOutputCmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;809    {
;;;810        /* Check the parameters */
;;;811        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;812        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;813    
;;;814        if ( NewState != DISABLE )
;;;815        {
;;;816            /* Enable the TIM Clock Output */
;;;817            TIMx->TIM_CON |= TIM_CON_TXOE;
000002  03d2              LSLS     r2,r2,#15
000004  2900              CMP      r1,#0                 ;814
000006  d003              BEQ      |L2.16|
000008  6801              LDR      r1,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;818        }
;;;819        else
;;;820        {
;;;821            /* Disable the TIM Clock Output */
;;;822            TIMx->TIM_CON &= ( uint32_t ) ~TIM_CON_TXOE;
;;;823        }
;;;824    }
00000e  4770              BX       lr
                  |L2.16|
000010  6801              LDR      r1,[r0,#0]            ;822
000012  4391              BICS     r1,r1,r2              ;822
000014  6001              STR      r1,[r0,#0]            ;822
000016  4770              BX       lr
;;;825    
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=2

                  TIM_Cmd PROC
;;;201     */
;;;202    void TIM_Cmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;203    {
000002  d004              BEQ      |L3.14|
;;;204        /* Check the parameters */
;;;205        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;206        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;207    
;;;208        if ( NewState != DISABLE )
;;;209        {
;;;210            /* Enable the TIM Counter */
;;;211            TIMx->TIM_CON |= TIM_CON_TR;
000004  6801              LDR      r1,[r0,#0]
000006  2280              MOVS     r2,#0x80
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;212        }
;;;213        else
;;;214        {
;;;215            /* Disable the TIM Counter */
;;;216            TIMx->TIM_CON &= ( uint16_t ) ~TIM_CON_TR;
;;;217        }
;;;218    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6801              LDR      r1,[r0,#0]            ;216
000010  4a01              LDR      r2,|L3.24|
000012  4011              ANDS     r1,r1,r2              ;216
000014  6001              STR      r1,[r0,#0]            ;216
000016  4770              BX       lr
;;;219    
                          ENDP

                  |L3.24|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;1028    */
;;;1029   void TIM_DMACmd ( TIM_TypeDef* TIMx, uint16_t TIM_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;1030   {
000002  d003              BEQ      |L4.12|
;;;1031       /* Check the parameters */
;;;1032       assert_param ( IS_TIM_DMA_PERIPH ( TIMx ) );
;;;1033       assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;1034   
;;;1035       if ( NewState != DISABLE )
;;;1036       {
;;;1037           /* Enable the TIM DMA */
;;;1038           TIMx->TIM_IDE |= TIM_DMAReq;
000004  6982              LDR      r2,[r0,#0x18]
000006  430a              ORRS     r2,r2,r1
000008  6182              STR      r2,[r0,#0x18]
;;;1039       }
;;;1040       else
;;;1041       {
;;;1042           /* Disable the TIM DMA */
;;;1043           TIMx->TIM_IDE &= ( uint16_t ) ~TIM_DMAReq;
;;;1044       }
;;;1045   }
00000a  4770              BX       lr
                  |L4.12|
00000c  6982              LDR      r2,[r0,#0x18]         ;1043
00000e  43c9              MVNS     r1,r1                 ;1043
000010  b289              UXTH     r1,r1                 ;1043
000012  400a              ANDS     r2,r2,r1              ;1043
000014  6182              STR      r2,[r0,#0x18]         ;1043
000016  4770              BX       lr
;;;1046   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;56      */
;;;57     void TIM_DeInit ( TIM_TypeDef* TIMx )
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59         assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;60     
;;;61         if ( TIMx == TIM0 )
000002  4933              LDR      r1,|L5.208|
000004  4288              CMP      r0,r1
000006  d108              BNE      |L5.26|
;;;62         {
;;;63             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM0, ENABLE );
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;64             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM0, DISABLE );
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;65         }
;;;66         else if ( TIMx == TIM1 )
;;;67         {
;;;68             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM1, ENABLE );
;;;69             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM1, DISABLE );
;;;70         }
;;;71     #if !(defined(SC32f15xx)||defined(SC32R601))
;;;72         else if ( TIMx == TIM2 )
;;;73         {
;;;74             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM2, ENABLE );
;;;75             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM2, DISABLE );
;;;76         }
;;;77     
;;;78         else if ( TIMx == TIM3 )
;;;79         {
;;;80             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM3, ENABLE );
;;;81             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TIM3, DISABLE );
;;;82         }
;;;83     #else
;;;84       else if(TIMx == TIM2)
;;;85       {
;;;86         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;87         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;88       }
;;;89       else if(TIMx == TIM3)
;;;90       {
;;;91         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
;;;92         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
;;;93       }
;;;94     #endif	
;;;95     #if !(defined(SC32f15xx)||defined(SC32R601))
;;;96         else if ( TIMx == TIM4 )
;;;97         {
;;;98             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM4, ENABLE );
;;;99             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM4, DISABLE );
;;;100        }
;;;101        else if ( TIMx == TIM5 )
;;;102        {
;;;103            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM5, ENABLE );
;;;104            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM5, DISABLE );
;;;105        }
;;;106        else if ( TIMx == TIM6 )
;;;107        {
;;;108            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM6, ENABLE );
;;;109            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM6, DISABLE );
;;;110        }
;;;111        else if ( TIMx == TIM7 )
;;;112        {
;;;113            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM7, ENABLE );
;;;114            RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TIM7, DISABLE );
;;;115        }
;;;116    #endif
;;;117    }
000018  bd10              POP      {r4,pc}
                  |L5.26|
00001a  492d              LDR      r1,|L5.208|
00001c  3140              ADDS     r1,r1,#0x40           ;66
00001e  4288              CMP      r0,r1                 ;66
000020  d108              BNE      |L5.52|
000022  2101              MOVS     r1,#1                 ;68
000024  2002              MOVS     r0,#2                 ;68
000026  f7fffffe          BL       RCC_APB0PeriphResetCmd
00002a  2100              MOVS     r1,#0                 ;69
00002c  2002              MOVS     r0,#2                 ;69
00002e  f7fffffe          BL       RCC_APB0PeriphResetCmd
000032  bd10              POP      {r4,pc}
                  |L5.52|
000034  4926              LDR      r1,|L5.208|
000036  3180              ADDS     r1,r1,#0x80           ;72
000038  4288              CMP      r0,r1                 ;72
00003a  d108              BNE      |L5.78|
00003c  2101              MOVS     r1,#1                 ;74
00003e  2004              MOVS     r0,#4                 ;74
000040  f7fffffe          BL       RCC_APB0PeriphResetCmd
000044  2100              MOVS     r1,#0                 ;75
000046  2004              MOVS     r0,#4                 ;75
000048  f7fffffe          BL       RCC_APB0PeriphResetCmd
00004c  bd10              POP      {r4,pc}
                  |L5.78|
00004e  4920              LDR      r1,|L5.208|
000050  31c0              ADDS     r1,r1,#0xc0           ;78
000052  4288              CMP      r0,r1                 ;78
000054  d108              BNE      |L5.104|
000056  2101              MOVS     r1,#1                 ;80
000058  2008              MOVS     r0,#8                 ;80
00005a  f7fffffe          BL       RCC_APB0PeriphResetCmd
00005e  2100              MOVS     r1,#0                 ;81
000060  2008              MOVS     r0,#8                 ;81
000062  f7fffffe          BL       RCC_APB0PeriphResetCmd
000066  bd10              POP      {r4,pc}
                  |L5.104|
000068  491a              LDR      r1,|L5.212|
00006a  4288              CMP      r0,r1                 ;96
00006c  d108              BNE      |L5.128|
00006e  2101              MOVS     r1,#1                 ;98
000070  4608              MOV      r0,r1                 ;98
000072  f7fffffe          BL       RCC_APB1PeriphResetCmd
000076  2100              MOVS     r1,#0                 ;99
000078  2001              MOVS     r0,#1                 ;99
00007a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007e  bd10              POP      {r4,pc}
                  |L5.128|
000080  4914              LDR      r1,|L5.212|
000082  3140              ADDS     r1,r1,#0x40           ;101
000084  4288              CMP      r0,r1                 ;101
000086  d108              BNE      |L5.154|
000088  2101              MOVS     r1,#1                 ;103
00008a  2002              MOVS     r0,#2                 ;103
00008c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000090  2100              MOVS     r1,#0                 ;104
000092  2002              MOVS     r0,#2                 ;104
000094  f7fffffe          BL       RCC_APB1PeriphResetCmd
000098  bd10              POP      {r4,pc}
                  |L5.154|
00009a  490e              LDR      r1,|L5.212|
00009c  3180              ADDS     r1,r1,#0x80           ;106
00009e  4288              CMP      r0,r1                 ;106
0000a0  d108              BNE      |L5.180|
0000a2  2101              MOVS     r1,#1                 ;108
0000a4  2004              MOVS     r0,#4                 ;108
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  2100              MOVS     r1,#0                 ;109
0000ac  2004              MOVS     r0,#4                 ;109
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.178|
0000b2  bd10              POP      {r4,pc}
                  |L5.180|
0000b4  4907              LDR      r1,|L5.212|
0000b6  31c0              ADDS     r1,r1,#0xc0           ;111
0000b8  4288              CMP      r0,r1                 ;111
0000ba  d1fa              BNE      |L5.178|
0000bc  2101              MOVS     r1,#1                 ;113
0000be  2008              MOVS     r0,#8                 ;113
0000c0  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000c4  2100              MOVS     r1,#0                 ;114
0000c6  2008              MOVS     r0,#8                 ;114
0000c8  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000cc  bd10              POP      {r4,pc}
;;;118    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L5.208|
                          DCD      0x40020100
                  |L5.212|
                          DCD      0x40021100

                          AREA ||i.TIM_GetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_GetAutoreload PROC
;;;316     */
;;;317    uint16_t TIM_GetAutoreload ( TIM_TypeDef* TIMx )
000000  6880              LDR      r0,[r0,#8]
;;;318    {
;;;319        /* Check the parameters */
;;;320        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;321    
;;;322        /* Get the ReloadData Register value */
;;;323        return TIMx->TIM_RLD;
000002  b280              UXTH     r0,r0
;;;324    }
000004  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;263     */
;;;264    uint32_t TIM_GetCounter ( TIM_TypeDef* TIMx )
000000  6840              LDR      r0,[r0,#4]
;;;265    {
;;;266        /* Check the parameters */
;;;267        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;268    
;;;269        /* Get the Counter Register value */
;;;270        return TIMx->TIM_CNT;
;;;271    }
000002  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.TIM_GetFailingCapture||, CODE, READONLY, ALIGN=1

                  TIM_GetFailingCapture PROC
;;;570      */
;;;571    uint32_t TIM_GetFailingCapture ( TIM_TypeDef* TIMx )
000000  6940              LDR      r0,[r0,#0x14]
;;;572    {
;;;573        /* Check the parameters */
;;;574        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;575    
;;;576        /* Get the Failing Capture Register value */
;;;577        return TIMx->TIM_PDTB_FCAP;
;;;578    }
000002  4770              BX       lr
;;;579    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;956     */
;;;957    FlagStatus TIM_GetFlagStatus ( TIM_TypeDef* TIMx, TIM_Flag_TypeDef TIM_FLAG )
000000  4602              MOV      r2,r0
;;;958    {
;;;959        FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;960        /* Check the parameters */
;;;961        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;962        assert_param ( IS_GET_TIM_FLAG ( TIM_FLAG ) );
;;;963    
;;;964        if ( ( TIMx->TIM_STS & TIM_FLAG ) != ( uint16_t ) RESET )
000004  68d2              LDR      r2,[r2,#0xc]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L9.12|
;;;965        {
;;;966            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;967        }
;;;968        else
;;;969        {
;;;970            bitstatus = RESET;
;;;971        }
;;;972        return bitstatus;
;;;973    }
00000c  4770              BX       lr
;;;974    
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;390     */
;;;391    TIM_Prescaler_TypeDef TIM_GetPrescaler ( TIM_TypeDef* TIMx )
000000  6800              LDR      r0,[r0,#0]
;;;392    {
;;;393        /* Check the parameters */
;;;394        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;395    
;;;396        /* Get the CKD value */
;;;397        return ( TIM_Prescaler_TypeDef ) ( TIMx->TIM_CON & TIM_CON_TIMCLK );
000002  2107              MOVS     r1,#7
000004  0209              LSLS     r1,r1,#8
000006  4008              ANDS     r0,r0,r1
;;;398    }
000008  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.TIM_GetRisingCapture||, CODE, READONLY, ALIGN=1

                  TIM_GetRisingCapture PROC
;;;544      */
;;;545    uint32_t TIM_GetRisingCapture ( TIM_TypeDef* TIMx )
000000  6900              LDR      r0,[r0,#0x10]
;;;546    {
;;;547        /* Check the parameters */
;;;548        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;549    
;;;550        /* Get the Rising Capture Register value */
;;;551        return TIMx->TIM_PDTA_RCAP;
;;;552    }
000002  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.TIM_ICCmd||, CODE, READONLY, ALIGN=2

                  TIM_ICCmd PROC
;;;509     */
;;;510    void TIM_ICCmd ( TIM_TypeDef* TIMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;511    {
000002  d004              BEQ      |L12.14|
;;;512        /* Check the parameters */
;;;513        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;514        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;515    
;;;516        if ( NewState != DISABLE )
;;;517        {
;;;518            /* Enable the capture function of TIMx */
;;;519            TIMx->TIM_CON |= TIM_CON_CPRL;
000004  6801              LDR      r1,[r0,#0]
000006  2201              MOVS     r2,#1
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;520        }
;;;521        else
;;;522        {
;;;523            /* Disable the capture function of TIMx */
;;;524            TIMx->TIM_CON &= ( uint16_t ) ~TIM_CON_CPRL;
;;;525        }
;;;526    }
00000c  4770              BX       lr
                  |L12.14|
00000e  6801              LDR      r1,[r0,#0]            ;524
000010  4a01              LDR      r2,|L12.24|
000012  4011              ANDS     r1,r1,r2              ;524
000014  6001              STR      r1,[r0,#0]            ;524
000016  4770              BX       lr
;;;527    
                          ENDP

                  |L12.24|
                          DCD      0x0000fffe

                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;432     */
;;;433    void TIM_ICInit ( TIM_TypeDef* TIMx, TIM_IC_InitTypeDef* TIM_IC_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;434    {
;;;435        uint16_t tmpreg;
;;;436        /* Check the parameters */
;;;437    
;;;438    #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806) ||defined(SC32R803)
;;;439        if ( TIM_IC_InitStruct->TIM_FICPIN == TIM_FICPin_TnEx )
000002  884a              LDRH     r2,[r1,#2]
;;;440            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;441        if ( ( TIM_IC_InitStruct->TIM_FICPIN == TIM_FICPin_Tn ) ||
;;;442                ( TIM_IC_InitStruct->TIM_RICPIN == TIM_RICPin_Tn ) )
000004  8809              LDRH     r1,[r1,#0]
;;;443            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;444    #elif  defined(SC32f15xx)||defined(SC32R601)
;;;445        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;446    #endif
;;;447    
;;;448    
;;;449        /* Get the TIMx TIM_CON register value */
;;;450        tmpreg = ( uint16_t ) TIMx->TIM_CON;
000006  6803              LDR      r3,[r0,#0]
000008  b29b              UXTH     r3,r3
;;;451    
;;;452        /* Clear EXENR, EXENF and EXENX SPR bits */
;;;453        tmpreg &= ~ ( TIM_CON_EXENR | TIM_CON_EXENF | TIM_CON_FSEL | TIM_CON_EXENX );
00000a  243c              MOVS     r4,#0x3c
00000c  43a3              BICS     r3,r3,r4
;;;454    
;;;455    
;;;456    #if defined(SC32f10xx)
;;;457        if ( TIMx == TIM0 )
;;;458        {
;;;459            if ( TIM_IC_InitStruct->TIM_FICPIN != TIM_FICPin_Tn )
;;;460            {
;;;461                tmpreg |= TIM_IC_InitStruct->TIM_FICPIN;
;;;462            }
;;;463    
;;;464        }
;;;465        else
;;;466        {
;;;467            tmpreg |= ( TIM_IC_InitStruct->TIM_FICPIN | TIM_IC_InitStruct->TIM_RICPIN );
;;;468        }
;;;469    #elif defined(SC32R803) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806) ||defined(SC32f15xx)||defined(SC32R601)
;;;470    
;;;471        tmpreg |= ( TIM_IC_InitStruct->TIM_FICPIN | TIM_IC_InitStruct->TIM_RICPIN );
00000e  430a              ORRS     r2,r2,r1
000010  431a              ORRS     r2,r2,r3
;;;472    #endif
;;;473    
;;;474    
;;;475        TIMx->TIM_CON = ( uint32_t ) tmpreg;
000012  6002              STR      r2,[r0,#0]
;;;476    }
000014  bd10              POP      {r4,pc}
;;;477    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;482      */
;;;483    void TIM_ICStructInit ( TIM_IC_InitTypeDef* TIM_IC_InitStruct )
000000  2100              MOVS     r1,#0
;;;484    {
;;;485        /* Set the default configuration */
;;;486        TIM_IC_InitStruct->TIM_FICPIN = TIM_FICPin_Disable;
000002  8041              STRH     r1,[r0,#2]
;;;487        TIM_IC_InitStruct->TIM_RICPIN = TIM_RICPin_Disable;
000004  8001              STRH     r1,[r0,#0]
;;;488    }
000006  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;914     */
;;;915    void TIM_ITConfig ( TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;916    {
000002  d003              BEQ      |L15.12|
;;;917        /* Check the parameters */
;;;918        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;919        assert_param ( IS_TIM_IT ( TIM_IT ) );
;;;920        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;921    
;;;922        if ( NewState != DISABLE )
;;;923        {
;;;924            /* Enable the Interrupt sources */
;;;925            TIMx->TIM_IDE |= TIM_IT;
000004  6982              LDR      r2,[r0,#0x18]
000006  430a              ORRS     r2,r2,r1
000008  6182              STR      r2,[r0,#0x18]
;;;926        }
;;;927        else
;;;928        {
;;;929            /* Disable the Interrupt sources */
;;;930            TIMx->TIM_IDE &= ( uint16_t ) ~TIM_IT;
;;;931        }
;;;932    }
00000a  4770              BX       lr
                  |L15.12|
00000c  6982              LDR      r2,[r0,#0x18]         ;930
00000e  43c9              MVNS     r1,r1                 ;930
000010  b289              UXTH     r1,r1                 ;930
000012  400a              ANDS     r2,r2,r1              ;930
000014  6182              STR      r2,[r0,#0x18]         ;930
000016  4770              BX       lr
;;;933    
                          ENDP


                          AREA ||i.TIM_PWMGetDuty||, CODE, READONLY, ALIGN=1

                  TIM_PWMGetDuty PROC
;;;751     */
;;;752    uint16_t TIM_PWMGetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel )
000000  2902              CMP      r1,#2
;;;753    {
000002  d002              BEQ      |L16.10|
;;;754        uint16_t tmpduty = 0;
;;;755    
;;;756        /* Check the parameters */
;;;757        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;758    
;;;759        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;760        {
;;;761            tmpduty = ( uint16_t ) TIMx->TIM_PDTA_RCAP;
;;;762        }
;;;763        else
;;;764        {
;;;765            tmpduty = ( uint16_t ) TIMx->TIM_PDTB_FCAP;
000004  6940              LDR      r0,[r0,#0x14]
000006  b280              UXTH     r0,r0
;;;766        }
;;;767    
;;;768        return tmpduty;
;;;769    }
000008  4770              BX       lr
                  |L16.10|
00000a  6900              LDR      r0,[r0,#0x10]         ;761
00000c  b280              UXTH     r0,r0                 ;761
00000e  4770              BX       lr
;;;770    
                          ENDP


                          AREA ||i.TIM_PWMInit||, CODE, READONLY, ALIGN=1

                  TIM_PWMInit PROC
;;;613     */
;;;614    void TIM_PWMInit ( TIM_TypeDef* TIMx, TIM_PWM_InitTypeDef* TIM_PWM_InitStruct )
000000  6802              LDR      r2,[r0,#0]
;;;615    {
;;;616        uint32_t tmpreg;
;;;617        /* Check the parameters */
;;;618    #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;619        if ( ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl == TIM_PWMChannel_PWMA ) ||
;;;620                ( TIM_PWM_InitStruct->TIM_PWMOutputChannl == TIM_PWMChannel_PWMA ) )
;;;621            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;622        if ( ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl == TIM_PWMChannel_PWMB ) ||
;;;623                ( TIM_PWM_InitStruct->TIM_PWMOutputChannl == TIM_PWMChannel_PWMB ) )
;;;624            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;625    #elif defined(SC32R803)|| defined(SC32f15xx)||defined(SC32R601)
;;;626        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;627    #endif
;;;628        /* Get the TIMx TIM_CON value */
;;;629        tmpreg = TIMx->TIM_CON;
;;;630    
;;;631        /* Clear EPWMNA,EPWMNB,INVNA and INVNB bit */
;;;632        tmpreg &= ( uint32_t ) ~ ( TIM_CON_EPWMNA | TIM_CON_EPWMNB | TIM_CON_INVNA | TIM_CON_INVNB );
000002  230f              MOVS     r3,#0xf
000004  02db              LSLS     r3,r3,#11
000006  439a              BICS     r2,r2,r3
;;;633    
;;;634        /* TIM0 has no TnPWMA and TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;635    #if defined(SC32f10xx)
;;;636        /* TIM0 has no TnPWMA and TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;637        if ( ( ( TIMx == TIM0 ) && ( TIM_PWM_InitStruct->TIM_PWMOutputChannl != TIM_PWMChannel_PWMA ) &&
;;;638                ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl != TIM_PWMChannel_PWMA ) ) ||
;;;639                ( ( TIMx != TIM0 ) && ( TIM_PWM_InitStruct->TIM_PWMOutputChannl != TIM_PWMChannel_PWMB ) &&
;;;640                  ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl != TIM_PWMChannel_PWMB ) ) )
;;;641        {
;;;642            /* Set EPWMNA and EPWMNB bit to PWM Output Channl value */
;;;643            /* Set INVNA and INVNB bit to PWM Low Polarity Channl value */
;;;644            tmpreg |= ( uint32_t ) ( ( TIM_PWM_InitStruct->TIM_PWMOutputChannl << ( 13U ) )
;;;645                                     | ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl ) << ( 11U ) );
;;;646        }
;;;647    #elif defined(SC32R803)|| defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)|| defined(SC32f15xx)||defined(SC32R601)
;;;648        {
;;;649            /* Set EPWMNA and EPWMNB bit to PWM Output Channl value */
;;;650            /* Set INVNA and INVNB bit to PWM Low Polarity Channl value */
;;;651            tmpreg |= ( uint32_t ) ( ( TIM_PWM_InitStruct->TIM_PWMOutputChannl << ( 13U ) )
000008  880b              LDRH     r3,[r1,#0]
00000a  8849              LDRH     r1,[r1,#2]
00000c  035b              LSLS     r3,r3,#13
00000e  02c9              LSLS     r1,r1,#11
000010  430b              ORRS     r3,r3,r1
000012  4313              ORRS     r3,r3,r2
;;;652                                     | ( TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl ) << ( 11U ) );
;;;653        }
;;;654    
;;;655    #endif
;;;656    
;;;657        /* Write to TIMx TIM_CON */
;;;658        TIMx->TIM_CON = tmpreg;
000014  6003              STR      r3,[r0,#0]
;;;659    }
000016  4770              BX       lr
;;;660    
                          ENDP


                          AREA ||i.TIM_PWMSetDuty||, CODE, READONLY, ALIGN=1

                  TIM_PWMSetDuty PROC
;;;694     */
;;;695    void TIM_PWMSetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel, uint16_t PWM_DutyValue )
000000  2902              CMP      r1,#2
;;;696    {
000002  d003              BEQ      |L18.12|
;;;697    #if defined(SC32f10xx)
;;;698        /* Check the parameters */
;;;699        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;700            assert_param ( IS_TIM_TN_PERIPH ( TIMx ) );
;;;701        if ( TIM_PWMChannel == TIM_PWMChannel_PWMB )
;;;702            assert_param ( IS_TIM_TNEX_PERIPH ( TIMx ) );
;;;703    
;;;704        /* TIM0 has no TnPWMA */
;;;705        if ( ( TIMx != TIM0 ) && ( TIM_PWMChannel == TIM_PWMChannel_PWMA ) )
;;;706        {
;;;707            TIMx->TIM_PDTA_RCAP = PWM_DutyValue;
;;;708        }
;;;709        /* TIM1,2,3,4,5,6,7 has no TnPWMB */
;;;710        else if ( ( TIMx == TIM0 ) && ( TIM_PWMChannel == TIM_PWMChannel_PWMB ) )
;;;711        {
;;;712            TIMx->TIM_PDTB_FCAP = PWM_DutyValue;
;;;713        }
;;;714    #elif defined(SC32R803)|| defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)|| defined(SC32f15xx)||defined(SC32R601)
;;;715        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;716    
;;;717        if ( TIM_PWMChannel == TIM_PWMChannel_PWMA )
;;;718        {
;;;719            TIMx->TIM_PDTA_RCAP = PWM_DutyValue;
;;;720        }
;;;721        else if ( TIM_PWMChannel == TIM_PWMChannel_PWMB )
000004  2901              CMP      r1,#1
000006  d100              BNE      |L18.10|
;;;722        {
;;;723            TIMx->TIM_PDTB_FCAP = PWM_DutyValue;
000008  6142              STR      r2,[r0,#0x14]
                  |L18.10|
;;;724        }
;;;725    
;;;726    #endif
;;;727    
;;;728    
;;;729    }
00000a  4770              BX       lr
                  |L18.12|
00000c  6102              STR      r2,[r0,#0x10]         ;719
00000e  4770              BX       lr
;;;730    
                          ENDP


                          AREA ||i.TIM_PWMStructInit||, CODE, READONLY, ALIGN=1

                  TIM_PWMStructInit PROC
;;;665      */
;;;666    void TIM_PWMStructInit ( TIM_PWM_InitTypeDef* TIM_PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;667    {
;;;668        /* Set the default configuration */
;;;669        TIM_PWM_InitStruct->TIM_PWMLowPolarityChannl = TIM_PWMChannel_Less;
000002  8041              STRH     r1,[r0,#2]
;;;670        TIM_PWM_InitStruct->TIM_PWMOutputChannl = TIM_PWMChannel_Less;
000004  8001              STRH     r1,[r0,#0]
;;;671    }
000006  4770              BX       lr
;;;672    
                          ENDP


                          AREA ||i.TIM_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_PinRemapConfig PROC
;;;857    #if defined(SC32f10xx) || defined(SC32R803)|| defined(SC32f15xx)||defined(SC32R601)
;;;858    void TIM_PinRemapConfig ( TIM_TypeDef* TIMx, TIM_PinRemap_TypeDef TIM_Remap )
000000  6802              LDR      r2,[r0,#0]
;;;859    {
;;;860        uint32_t tmpreg ;
;;;861        /* Check the parameters */
;;;862        assert_param ( IS_TIM_REMAP_PERIPH ( TIMx ) );
;;;863        assert_param ( IS_TIM_PINREMAP ( TIM_Remap ) );
;;;864    
;;;865        tmpreg = TIMx->TIM_CON;
;;;866    
;;;867        tmpreg &= ( uint32_t ) ( ~TIM_CON_SPOS );
000002  2301              MOVS     r3,#1
000004  04db              LSLS     r3,r3,#19
000006  439a              BICS     r2,r2,r3
;;;868    
;;;869        tmpreg |= TIM_Remap;
000008  430a              ORRS     r2,r2,r1
;;;870    
;;;871        TIMx->TIM_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;872    }
00000c  4770              BX       lr
;;;873    #endif
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;290     */
;;;291    void TIM_SetAutoreload ( TIM_TypeDef* TIMx, uint16_t Autoreload )
000000  6081              STR      r1,[r0,#8]
;;;292    {
;;;293        /* Check the parameters */
;;;294        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;295    
;;;296        /* Set the ReloadData Register value */
;;;297        TIMx->TIM_RLD = Autoreload;
;;;298    }
000002  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;237     */
;;;238    void TIM_SetCounter ( TIM_TypeDef* TIMx, uint32_t Counter )
000000  6041              STR      r1,[r0,#4]
;;;239    {
;;;240        /* Check the parameters */
;;;241        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;242    
;;;243        /* Set the Counter Register value */
;;;244        TIMx->TIM_CNT = ( uint32_t ) Counter;
;;;245    }
000002  4770              BX       lr
;;;246    
                          ENDP


                          AREA ||i.TIM_SetPerscaler||, CODE, READONLY, ALIGN=1

                  TIM_SetPerscaler PROC
;;;351     */
;;;352    void TIM_SetPerscaler ( TIM_TypeDef* TIMx, TIM_Prescaler_TypeDef TIM_Perscaler )
000000  6802              LDR      r2,[r0,#0]
;;;353    {
;;;354    
;;;355        /* Check the parameters */
;;;356        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;357        assert_param ( IS_TIM_PRESCALER ( TIM_Perscaler ) );
;;;358    
;;;359        /* Reset the CKD Bits */
;;;360        TIMx->TIM_CON &= ( uint32_t ) ( ~TIM_CON_TIMCLK );
000002  2307              MOVS     r3,#7
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;361    
;;;362        /* Set the CKD value */
;;;363        TIMx->TIM_CON |= TIM_Perscaler;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;364    }
000010  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.TIM_TIMBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TIMBaseInit PROC
;;;137     */
;;;138    void TIM_TIMBaseInit ( TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;139    {
;;;140        /* Check the parameters */
;;;141        uint32_t tmpreg;
;;;142        assert_param ( IS_TIM_ALL_PERIPH ( TIMx ) );
;;;143        assert_param ( IS_TIM_PRESCALER ( TIM_TimeBaseInitStruct->TIM_EXENX ) );
;;;144        assert_param ( IS_TIM_WORKMODE ( TIM_TimeBaseInitStruct->TIM_WorkMode ) );
;;;145        assert_param ( IS_TIM_COUNTERMODE ( TIM_TimeBaseInitStruct->TIM_CounterMode ) );
;;;146        assert_param ( IS_TIM_RICPin ( TIM_TimeBaseInitStruct->TIM_Prescaler ) );
;;;147    
;;;148        /*---------------------------- TIMx TIM_CON Configuration ------------------------*/
;;;149        /* Get the TIMx TIM_CON value */
;;;150        tmpreg = TIMx->TIM_CON;
000002  6802              LDR      r2,[r0,#0]
;;;151        /* Clear TIMCK, DEC, CTSEL and EXENX SPR bits */
;;;152        tmpreg &= ( uint32_t ) ~ ( TIM_CON_TIMCLK | TIM_CON_CTSEL | TIM_CON_DEC | TIM_CON_EXENX );
000004  4b07              LDR      r3,|L24.36|
000006  401a              ANDS     r2,r2,r3
;;;153        /* Configure TIMx: Prescaler, AlignedMode and WorkMode */
;;;154        /* Set TIMCK bits according to Prescaler value */
;;;155        /* Set DEC bit according to CounterMode value */
;;;156        /* Set CTSEL bit according to WorkMode value */
;;;157        /* Set EXENX bit according to EXENX value */
;;;158        tmpreg |= ( uint32_t ) ( TIM_TimeBaseInitStruct->TIM_Prescaler | TIM_TimeBaseInitStruct->TIM_CounterMode |
000008  880b              LDRH     r3,[r1,#0]
00000a  888c              LDRH     r4,[r1,#4]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4323              ORRS     r3,r3,r4
000010  884c              LDRH     r4,[r1,#2]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  4313              ORRS     r3,r3,r2
;;;159                                 TIM_TimeBaseInitStruct->TIM_WorkMode | ( TIM_TimeBaseInitStruct->TIM_EXENX ) );
;;;160        /* Write to TIMx TIM_CON */
;;;161        TIMx->TIM_CON = tmpreg;
000018  6003              STR      r3,[r0,#0]
;;;162        /* Write to TIMx TIM_CYCLE */
;;;163        TIMx->TIM_CNT = TIMx->TIM_RLD = TIM_TimeBaseInitStruct->TIM_Preload;
00001a  8909              LDRH     r1,[r1,#8]
00001c  6081              STR      r1,[r0,#8]
00001e  6041              STR      r1,[r0,#4]
;;;164    
;;;165    }
000020  bd30              POP      {r4,r5,pc}
;;;166    
                          ENDP

000022  0000              DCW      0x0000
                  |L24.36|
                          DCD      0xfffff89d

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;171      */
;;;172    void TIM_TimeBaseStructInit ( TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct )
000000  2100              MOVS     r1,#0
;;;173    {
;;;174        /* Set the default configuration */
;;;175        TIM_TimeBaseInitStruct->TIM_Prescaler = TIM_PRESCALER_1;
000002  8001              STRH     r1,[r0,#0]
;;;176        TIM_TimeBaseInitStruct->TIM_WorkMode = TIM_WorkMode_Timer;
000004  8041              STRH     r1,[r0,#2]
;;;177        TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
000006  8081              STRH     r1,[r0,#4]
;;;178        TIM_TimeBaseInitStruct->TIM_Preload = 0x0000;
000008  8101              STRH     r1,[r0,#8]
;;;179        TIM_TimeBaseInitStruct->TIM_EXENX = TIM_EXENX_Disable;
00000a  80c1              STRH     r1,[r0,#6]
;;;180    }
00000c  4770              BX       lr
;;;181    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_tim_c_c458916b____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_tim_c_c458916b____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_tim_c_c458916b____REVSH|
#line 478
|__asm___15_sc32f1xxx_tim_c_c458916b____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
