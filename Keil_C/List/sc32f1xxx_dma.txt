; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_dma.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_dma.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_dma.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_dma.c]
                          THUMB

                          AREA ||i.DMA_CHRQCmd||, CODE, READONLY, ALIGN=1

                  DMA_CHRQCmd PROC
;;;232      */
;;;233    void DMA_CHRQCmd ( DMA_TypeDef* DMAx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;234    {
;;;235        /* Check the parameters */
;;;236        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;237        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;238    
;;;239        if ( NewState != DISABLE )
;;;240        {
;;;241            /* Enable the selected DMAy Streamx by setting CHRQ bit */
;;;242            DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_CHRQ;
000002  05d2              LSLS     r2,r2,#23
000004  2900              CMP      r1,#0                 ;239
000006  d003              BEQ      |L1.16|
000008  6881              LDR      r1,[r0,#8]
00000a  4311              ORRS     r1,r1,r2
00000c  6081              STR      r1,[r0,#8]
;;;243        }
;;;244        else
;;;245        {
;;;246            /* Enable the selected DMAy Streamx by clearing CHRQ bit */
;;;247            DMAx->DMA_CFG &= ( uint32_t ) ~DMA_CFG_CHRQ;
;;;248        }
;;;249    }
00000e  4770              BX       lr
                  |L1.16|
000010  6881              LDR      r1,[r0,#8]            ;247
000012  4391              BICS     r1,r1,r2              ;247
000014  6081              STR      r1,[r0,#8]            ;247
000016  4770              BX       lr
;;;250    
                          ENDP


                          AREA ||i.DMA_ChannelReset||, CODE, READONLY, ALIGN=1

                  DMA_ChannelReset PROC
;;;263      */
;;;264    void DMA_ChannelReset ( DMA_TypeDef* DMAx )
000000  6881              LDR      r1,[r0,#8]
;;;265    {
;;;266        /* Check the parameters */
;;;267        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;268    
;;;269        DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_CHRST;
000002  2240              MOVS     r2,#0x40
000004  4311              ORRS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;270    }
000008  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.DMA_ClearFlag||, CODE, READONLY, ALIGN=1

                  DMA_ClearFlag PROC
;;;553      */
;;;554    void DMA_ClearFlag ( DMA_TypeDef* DMAx, uint32_t DMA_FLAG )
000000  6101              STR      r1,[r0,#0x10]
;;;555    {
;;;556        /* Check the parameters */
;;;557        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;558        assert_param ( IS_GET_DMA_FLAG ( DMA_FLAG ) );
;;;559    
;;;560        /* Set DMAy STS register clear flag bits */
;;;561        DMAx->DMA_STS = ( uint32_t ) ( DMA_FLAG );
;;;562    }
000002  4770              BX       lr
;;;563    
                          ENDP


                          AREA ||i.DMA_Cmd||, CODE, READONLY, ALIGN=1

                  DMA_Cmd PROC
;;;164      */
;;;165    void DMA_Cmd ( DMA_TypeDef* DMAx, FunctionalState NewState )
000000  2280              MOVS     r2,#0x80
;;;166    {
;;;167        /* Check the parameters */
;;;168        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;169        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;170    
;;;171        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L4.14|
;;;172        {
;;;173            /* Enable the selected DMAy Streamx by setting EN bit */
;;;174            DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_CHEN;
000006  6881              LDR      r1,[r0,#8]
000008  4311              ORRS     r1,r1,r2
00000a  6081              STR      r1,[r0,#8]
;;;175        }
;;;176        else
;;;177        {
;;;178            /* Disable the selected DMAy Streamx by clearing EN bit */
;;;179            DMAx->DMA_CFG &= ~ ( uint32_t ) DMA_CFG_CHEN;
;;;180        }
;;;181    }
00000c  4770              BX       lr
                  |L4.14|
00000e  6881              LDR      r1,[r0,#8]            ;179
000010  4391              BICS     r1,r1,r2              ;179
000012  6081              STR      r1,[r0,#8]            ;179
000014  4770              BX       lr
;;;182    
                          ENDP


                          AREA ||i.DMA_DMACmd||, CODE, READONLY, ALIGN=1

                  DMA_DMACmd PROC
;;;581      */
;;;582    void DMA_DMACmd ( DMA_TypeDef* DMAx, uint32_t DMA_DMARequest, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;583    {
000002  d003              BEQ      |L5.12|
;;;584        /* Check the parameters */
;;;585        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;586        assert_param ( IS_DMA_DMAREQ ( DMA_DMARequest ) );
;;;587    
;;;588        /* Config DMA Request */
;;;589        if ( NewState != DISABLE )
;;;590        {
;;;591            /* Enable the selected DMA Request */
;;;592            DMAx->DMA_CFG |= ( uint32_t ) ( DMA_DMARequest );
000004  6882              LDR      r2,[r0,#8]
000006  430a              ORRS     r2,r2,r1
000008  6082              STR      r2,[r0,#8]
;;;593        }
;;;594        else
;;;595        {
;;;596            /* Disable the selected DMA Request */
;;;597            DMAx->DMA_CFG &= ( uint32_t ) ~ ( DMA_DMARequest );
;;;598        }
;;;599    }
00000a  4770              BX       lr
                  |L5.12|
00000c  6882              LDR      r2,[r0,#8]            ;597
00000e  438a              BICS     r2,r2,r1              ;597
000010  6082              STR      r2,[r0,#8]            ;597
000012  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.DMA_DeInit||, CODE, READONLY, ALIGN=1

                  DMA_DeInit PROC
;;;57      */
;;;58     void DMA_DeInit ( DMA_TypeDef* DMAx )
000000  b510              PUSH     {r4,lr}
;;;59     {
;;;60         /* Check the parameters */
;;;61         assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;62     
;;;63         if ( DMAx != 0x00 )
000002  2800              CMP      r0,#0
000004  d007              BEQ      |L6.22|
;;;64         {
;;;65             /* Enable DMA reset state */
;;;66             RCC_AHBPeriphResetCmd ( RCC_AHBPeriph_DMA, ENABLE );
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;67             /* Release DMA from reset state */
;;;68             RCC_AHBPeriphResetCmd ( RCC_AHBPeriph_DMA, DISABLE );
00000e  2100              MOVS     r1,#0
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       RCC_AHBPeriphResetCmd
                  |L6.22|
;;;69         }
;;;70     }
000016  bd10              POP      {r4,pc}
;;;71     
                          ENDP


                          AREA ||i.DMA_GetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_GetCurrDataCounter PROC
;;;371      */
;;;372    uint32_t DMA_GetCurrDataCounter ( DMA_TypeDef* DMAx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;373    {
;;;374        /* Check the parameters */
;;;375        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;376    
;;;377        /* Return The number of DMA transfers */
;;;378        return ( ( uint32_t ) ( DMAx->DMA_CNT ) );
;;;379    }
000002  4770              BX       lr
;;;380    
                          ENDP


                          AREA ||i.DMA_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  DMA_GetFlagStatus PROC
;;;510      */
;;;511    FlagStatus DMA_GetFlagStatus ( DMA_TypeDef* DMAx, DMA_Flag_TypeDef DMA_FLAG )
000000  4602              MOV      r2,r0
;;;512    {
;;;513        FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;514    
;;;515        /* Check the parameters */
;;;516        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;517        assert_param ( IS_GET_DMA_FLAG ( DMA_FLAG ) );
;;;518    
;;;519    
;;;520        /* Check the status of the specified DMA flag */
;;;521        if ( ( DMAx->DMA_STS & DMA_FLAG ) != ( uint32_t ) RESET )
000004  6912              LDR      r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;522        {
;;;523            /* DMA_FLAG is set */
;;;524            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;525        }
;;;526        else
;;;527        {
;;;528            /* DMA_FLAG is reset */
;;;529            bitstatus = RESET;
;;;530        }
;;;531    
;;;532        /* Return the DMA_FLAG status */
;;;533        return  bitstatus;
;;;534    }
00000c  4770              BX       lr
;;;535    
                          ENDP


                          AREA ||i.DMA_GetStatus||, CODE, READONLY, ALIGN=1

                  DMA_GetStatus PROC
;;;438      */
;;;439    DMA_State_TypeDef DMA_GetStatus ( DMA_TypeDef* DMAx )
000000  6900              LDR      r0,[r0,#0x10]
;;;440    {
;;;441        DMA_State_TypeDef Status;
;;;442    
;;;443        /* Check the parameters */
;;;444        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;445    
;;;446        Status = ( DMA_State_TypeDef ) ( DMAx->DMA_STS & DMA_STS_STATUS );
000002  21f0              MOVS     r1,#0xf0
000004  4008              ANDS     r0,r0,r1
;;;447        return Status;
;;;448    }
000006  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.DMA_ITConfig||, CODE, READONLY, ALIGN=1

                  DMA_ITConfig PROC
;;;471      */
;;;472    void DMA_ITConfig ( DMA_TypeDef* DMAx, uint32_t DMA_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;473    {
000002  d003              BEQ      |L10.12|
;;;474        /* Check the parameters */
;;;475        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;476        assert_param ( IS_DMA_IT ( DMA_IT ) );
;;;477        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;478    
;;;479        if ( NewState != DISABLE )
;;;480        {
;;;481            /* Enable the selected DMA transfer interrupts */
;;;482            DMAx->DMA_CFG |= ( uint32_t ) ( DMA_IT );
000004  6882              LDR      r2,[r0,#8]
000006  430a              ORRS     r2,r2,r1
000008  6082              STR      r2,[r0,#8]
;;;483        }
;;;484        else
;;;485        {
;;;486            /* Disable the selected DMA transfer interrupts */
;;;487            DMAx->DMA_CFG &= ~ ( uint32_t ) ( DMA_IT );
;;;488        }
;;;489    }
00000a  4770              BX       lr
                  |L10.12|
00000c  6882              LDR      r2,[r0,#8]            ;487
00000e  438a              BICS     r2,r2,r1              ;487
000010  6082              STR      r2,[r0,#8]            ;487
000012  4770              BX       lr
;;;490    
                          ENDP


                          AREA ||i.DMA_Init||, CODE, READONLY, ALIGN=2

                  DMA_Init PROC
;;;86      */
;;;87     void DMA_Init ( DMA_TypeDef* DMAx, DMA_InitTypeDef* DMA_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;88     {
;;;89         uint32_t tmpreg;
;;;90         /* Check the parameters */
;;;91         assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;92         assert_param ( IS_DMA_PROIORITY ( DMA_InitStruct->DMA_Priority ) );
;;;93         assert_param ( IS_DMA_CIRCULARMODE ( DMA_InitStruct->DMA_CircularMode ) );
;;;94         assert_param ( IS_DMA_DATASIZE ( DMA_InitStruct->DMA_DataSize ) );
;;;95         assert_param ( IS_DMA_TARGERT_MODE ( DMA_InitStruct->DMA_TargetMode ) );
;;;96         assert_param ( IS_DMA_SOURCE_MODE ( DMA_InitStruct->DMA_SourceMode ) );
;;;97         assert_param ( IS_DMA_BURST ( DMA_InitStruct->DMA_Burst ) );
;;;98     
;;;99         tmpreg = DMAx->DMA_CFG;
000002  6882              LDR      r2,[r0,#8]
;;;100    
;;;101        tmpreg &=
000004  4b0b              LDR      r3,|L11.52|
000006  401a              ANDS     r2,r2,r3
;;;102            ( uint32_t ) ~ ( DMA_CFG_PL | DMA_CFG_TXWIDTH | DMA_CFG_CIRC |
;;;103                             DMA_CFG_CHRST | DMA_CFG_CHEN | DMA_CFG_DAINC | DMA_CFG_SAINC |
;;;104                             DMA_CFG_BURSIZE | DMA_CFG_TPTYPE |
;;;105                             DMA_CFG_REQSRC );
;;;106        tmpreg |=
000008  880b              LDRH     r3,[r1,#0]
00000a  884c              LDRH     r4,[r1,#2]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4323              ORRS     r3,r3,r4
000010  888c              LDRH     r4,[r1,#4]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  890c              LDRH     r4,[r1,#8]
000018  4323              ORRS     r3,r3,r4
00001a  894c              LDRH     r4,[r1,#0xa]
00001c  4323              ORRS     r3,r3,r4
00001e  690c              LDR      r4,[r1,#0x10]
000020  4323              ORRS     r3,r3,r4
000022  4313              ORRS     r3,r3,r2
;;;107            ( uint32_t ) ( DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_CircularMode |
;;;108                           DMA_InitStruct->DMA_DataSize | DMA_InitStruct->DMA_TargetMode |
;;;109                           DMA_InitStruct->DMA_SourceMode | DMA_InitStruct->DMA_Burst |
;;;110                           DMA_InitStruct->DMA_Request );
;;;111    
;;;112        DMAx->DMA_CFG = tmpreg;
000024  6083              STR      r3,[r0,#8]
;;;113    
;;;114        DMAx->DMA_SADR = DMA_InitStruct->DMA_SrcAddress;
000026  694a              LDR      r2,[r1,#0x14]
000028  6002              STR      r2,[r0,#0]
;;;115        DMAx->DMA_DADR = DMA_InitStruct->DMA_DstAddress;
00002a  698a              LDR      r2,[r1,#0x18]
00002c  6042              STR      r2,[r0,#4]
;;;116        DMAx->DMA_CNT = DMA_InitStruct->DMA_BufferSize;
00002e  68c9              LDR      r1,[r1,#0xc]
000030  60c1              STR      r1,[r0,#0xc]
;;;117    }
000032  bd30              POP      {r4,r5,pc}
;;;118    
                          ENDP

                  |L11.52|
                          DCD      0xc0ff0020

                          AREA ||i.DMA_PauseCmd||, CODE, READONLY, ALIGN=1

                  DMA_PauseCmd PROC
;;;198      */
;;;199    void DMA_PauseCmd ( DMA_TypeDef* DMAx, FunctionalState NewState )
000000  2220              MOVS     r2,#0x20
;;;200    {
;;;201        /* Check the parameters */
;;;202        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;203        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;204    
;;;205        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L12.14|
;;;206        {
;;;207            /* Enable the selected DMAy Streamx by setting PAUSE bit */
;;;208            DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_PAUSE;
000006  6881              LDR      r1,[r0,#8]
000008  4311              ORRS     r1,r1,r2
00000a  6081              STR      r1,[r0,#8]
;;;209        }
;;;210        else
;;;211        {
;;;212            /* Enable the selected DMAy Streamx by clearing EN bit */
;;;213            DMAx->DMA_CFG = ( uint32_t ) ( ( DMAx->DMA_CFG | DMA_CFG_CHEN ) & ( ~DMA_CFG_PAUSE ) );
;;;214        }
;;;215    }
00000c  4770              BX       lr
                  |L12.14|
00000e  6881              LDR      r1,[r0,#8]            ;213
000010  2380              MOVS     r3,#0x80              ;213
000012  4319              ORRS     r1,r1,r3              ;213
000014  4391              BICS     r1,r1,r2              ;213
000016  6081              STR      r1,[r0,#8]            ;213
000018  4770              BX       lr
;;;216    
                          ENDP


                          AREA ||i.DMA_SetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_SetCurrDataCounter PROC
;;;349      */
;;;350    void DMA_SetCurrDataCounter ( DMA_TypeDef* DMAx, uint32_t Counter )
000000  60c1              STR      r1,[r0,#0xc]
;;;351    {
;;;352        /* Check the parameters */
;;;353        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;354    
;;;355        /* Write the number of data units to be transferred */
;;;356        DMAx->DMA_CNT = ( uint32_t ) Counter;
;;;357    }
000002  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.DMA_SetDstAddress||, CODE, READONLY, ALIGN=1

                  DMA_SetDstAddress PROC
;;;324      */
;;;325    void DMA_SetDstAddress ( DMA_TypeDef* DMAx, uint32_t DstAddress )
000000  6041              STR      r1,[r0,#4]
;;;326    {
;;;327        /* Check the parameters */
;;;328        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;329    
;;;330        /* Write the number of data units to be transferred */
;;;331        DMAx->DMA_DADR = ( uint32_t ) DstAddress;
;;;332    }
000002  4770              BX       lr
;;;333    
                          ENDP


                          AREA ||i.DMA_SetSrcAddress||, CODE, READONLY, ALIGN=1

                  DMA_SetSrcAddress PROC
;;;301      */
;;;302    void DMA_SetSrcAddress ( DMA_TypeDef* DMAx, uint32_t SrcAddress )
000000  6001              STR      r1,[r0,#0]
;;;303    {
;;;304        /* Check the parameters */
;;;305        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;306    
;;;307        /* Write the number of data units to be transferred */
;;;308        DMAx->DMA_SADR = ( uint32_t ) SrcAddress;
;;;309    }
000002  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.DMA_SoftwareTrigger||, CODE, READONLY, ALIGN=1

                  DMA_SoftwareTrigger PROC
;;;393      */
;;;394    void DMA_SoftwareTrigger ( DMA_TypeDef* DMAx )
000000  21ff              MOVS     r1,#0xff
;;;395    {
;;;396        /* Check the parameters */
;;;397        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;398    
;;;399        /* Set DMA STS SWREQ Bit */
;;;400        DMAx->DMA_STS = DMA_STS_SWREQ;
000002  3101              ADDS     r1,#1
000004  6101              STR      r1,[r0,#0x10]
;;;401    }
000006  4770              BX       lr
;;;402    /**
                          ENDP


                          AREA ||i.DMA_StructInit||, CODE, READONLY, ALIGN=1

                  DMA_StructInit PROC
;;;123      */
;;;124    void DMA_StructInit ( DMA_InitTypeDef* DMA_InitStruct )
000000  2100              MOVS     r1,#0
;;;125    {
;;;126        /* Initialize the DMA_Priority member */
;;;127        DMA_InitStruct->DMA_Priority = DMA_Priority_LOW;
000002  8001              STRH     r1,[r0,#0]
;;;128    
;;;129        /* Initialize the DMA_CircularMode member */
;;;130        DMA_InitStruct->DMA_CircularMode = DMA_CircularMode_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;131    
;;;132        /* Initialize the DMA_DataSize member */
;;;133        DMA_InitStruct->DMA_DataSize = DMA_DataSize_Byte;
000006  8081              STRH     r1,[r0,#4]
;;;134    
;;;135        /* Initialize the DMA_TargetMode member */
;;;136        DMA_InitStruct->DMA_TargetMode = DMA_TargetMode_FIXED;
000008  80c1              STRH     r1,[r0,#6]
;;;137    
;;;138        /* Initialize the DMA_SourceMode member */
;;;139        DMA_InitStruct->DMA_SourceMode = DMA_SourceMode_FIXED;
00000a  8101              STRH     r1,[r0,#8]
;;;140    
;;;141        /* Initialize the DMA_Burst member */
;;;142        DMA_InitStruct->DMA_Burst = DMA_Burst_Disable;
00000c  8141              STRH     r1,[r0,#0xa]
;;;143    
;;;144        /* Initialize the DMA_Request member */
;;;145        DMA_InitStruct->DMA_Request = DMA_Request_Null;
00000e  6101              STR      r1,[r0,#0x10]
;;;146    }
000010  4770              BX       lr
;;;147    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_dma_c_e9b554c0____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_dma_c_e9b554c0____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_dma_c_e9b554c0____REVSH|
#line 478
|__asm___15_sc32f1xxx_dma_c_e9b554c0____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
