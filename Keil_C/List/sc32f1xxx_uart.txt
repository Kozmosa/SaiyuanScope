; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_uart.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_uart.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\sc32f1xxx_uart.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_uart.c]
                          THUMB

                          AREA ||i.LINCalChecksum||, CODE, READONLY, ALIGN=1

                  LINCalChecksum PROC
;;;731     */
;;;732    uint8_t LINCalChecksum ( uint8_t id, uint8_t *data, uint8_t len )
000000  b530              PUSH     {r4,r5,lr}
;;;733    {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;734        uint32_t sum = LIN_CalID ( id );
000006  f7fffffe          BL       LIN_CalID
;;;735        uint8_t i;
;;;736    
;;;737        for ( i = 0; i < len; i++ )
00000a  2300              MOVS     r3,#0
00000c  e008              B        |L1.32|
                  |L1.14|
;;;738        {
;;;739            sum += data[i];
00000e  5ce1              LDRB     r1,[r4,r3]
000010  1808              ADDS     r0,r1,r0
;;;740            if ( sum & 0xFF00 )
000012  0401              LSLS     r1,r0,#16
000014  0e09              LSRS     r1,r1,#24
000016  d001              BEQ      |L1.28|
;;;741            {
;;;742                sum = ( sum & 0x00FF ) + 1;
000018  b2c0              UXTB     r0,r0
00001a  1c40              ADDS     r0,r0,#1
                  |L1.28|
00001c  1c5b              ADDS     r3,r3,#1              ;737
00001e  b2db              UXTB     r3,r3                 ;737
                  |L1.32|
000020  42ab              CMP      r3,r5                 ;737
000022  d3f4              BCC      |L1.14|
;;;743            }
;;;744        }
;;;745    
;;;746        sum ^= 0x00FF;
000024  21ff              MOVS     r1,#0xff
000026  4048              EORS     r0,r0,r1
;;;747        return ( uint8_t ) sum;
000028  b2c0              UXTB     r0,r0
;;;748    }
00002a  bd30              POP      {r4,r5,pc}
;;;749    #endif
                          ENDP


                          AREA ||i.LIN_CalID||, CODE, READONLY, ALIGN=1

                  LIN_CalID PROC
;;;712     */
;;;713    uint8_t LIN_CalID ( uint8_t id )
000000  b510              PUSH     {r4,lr}
;;;714    {
;;;715        uint8_t parity, p0, p1;
;;;716    
;;;717        parity = id;
;;;718        p0 = ( BIT ( parity, 0 ) ^ BIT ( parity, 1 ) ^ BIT ( parity, 2 ) ^ BIT ( parity, 4 ) ) << 6;
000002  07c3              LSLS     r3,r0,#31
000004  0781              LSLS     r1,r0,#30
000006  0fdb              LSRS     r3,r3,#31
000008  0fc9              LSRS     r1,r1,#31
00000a  0742              LSLS     r2,r0,#29
00000c  404b              EORS     r3,r3,r1
00000e  0fd2              LSRS     r2,r2,#31
000010  4053              EORS     r3,r3,r2
000012  06c2              LSLS     r2,r0,#27
000014  0fd2              LSRS     r2,r2,#31
000016  4053              EORS     r3,r3,r2
000018  019b              LSLS     r3,r3,#6
;;;719        p1 = ( ! ( BIT ( parity, 1 ) ^ BIT ( parity, 3 ) ^ BIT ( parity, 4 ) ^ BIT ( parity, 5 ) ) ) << 7;
00001a  0704              LSLS     r4,r0,#28
00001c  0fe4              LSRS     r4,r4,#31
00001e  4061              EORS     r1,r1,r4
000020  4051              EORS     r1,r1,r2
000022  0682              LSLS     r2,r0,#26
000024  0fd2              LSRS     r2,r2,#31
000026  4051              EORS     r1,r1,r2
000028  2201              MOVS     r2,#1
00002a  4051              EORS     r1,r1,r2
00002c  01c9              LSLS     r1,r1,#7
;;;720    
;;;721        parity |= ( p0 | p1 );
00002e  430b              ORRS     r3,r3,r1
000030  4303              ORRS     r3,r3,r0
;;;722    
;;;723        return parity;
000032  4618              MOV      r0,r3
;;;724    }
000034  bd10              POP      {r4,pc}
;;;725    /**
                          ENDP


                          AREA ||i.Printf_UartInit||, CODE, READONLY, ALIGN=2

                  Printf_UartInit PROC
;;;780     */
;;;781    __attribute__((weak)) void Printf_UartInit ( UART_TypeDef* UARTx )
000000  4901              LDR      r1,|L3.8|
;;;782    {
;;;783    
;;;784        Printf_Uart = UARTx;
000002  6008              STR      r0,[r1,#0]  ; Printf_Uart
;;;785    }
000004  4770              BX       lr
;;;786    /*printf mapping function*/
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.UART_ClearFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearFlag PROC
;;;519     */
;;;520    void UART_ClearFlag ( UART_TypeDef* UARTx, uint16_t UART_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;521    {
;;;522        /* Check the parameters */
;;;523        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;524    
;;;525        /* Clear the flags */
;;;526        UARTx->UART_STS = ( uint16_t ) UART_FLAG;
;;;527    }
000002  4770              BX       lr
;;;528    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;546     */
;;;547    void UART_DMACmd ( UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;548    {
000002  d003              BEQ      |L5.12|
;;;549        /* Check the parameters */
;;;550        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;551        assert_param ( IS_UART_DMAREQ ( UART_DMAReq ) );
;;;552        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;553    
;;;554        if ( NewState != DISABLE )
;;;555        {
;;;556            /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;557               DMAR bits in the UART IDE register */
;;;558            UARTx->UART_IDE |= UART_DMAReq;
000004  6902              LDR      r2,[r0,#0x10]
000006  430a              ORRS     r2,r2,r1
000008  6102              STR      r2,[r0,#0x10]
;;;559        }
;;;560        else
;;;561        {
;;;562            /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;563               DMAR bits in the UART IDE register */
;;;564            UARTx->UART_IDE &= ( uint16_t ) ~UART_DMAReq;
;;;565        }
;;;566    }
00000a  4770              BX       lr
                  |L5.12|
00000c  6902              LDR      r2,[r0,#0x10]         ;564
00000e  43c9              MVNS     r1,r1                 ;564
000010  b289              UXTH     r1,r1                 ;564
000012  400a              ANDS     r2,r2,r1              ;564
000014  6102              STR      r2,[r0,#0x10]         ;564
000016  4770              BX       lr
;;;567    /* End of UART_Group3.	*/
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;54      */
;;;55     void UART_DeInit ( UART_TypeDef* UARTx )
000000  b510              PUSH     {r4,lr}
;;;56     {
000002  4604              MOV      r4,r0
;;;57         assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;58     
;;;59         if ( UARTx == UART0 )
000004  4825              LDR      r0,|L6.156|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L6.28|
;;;60         {
;;;61             /* Enable UART0 reset state */
;;;62             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;63             /* Release UART0 from reset state */
;;;64             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, DISABLE );
000012  2100              MOVS     r1,#0
000014  2040              MOVS     r0,#0x40
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
00001a  e023              B        |L6.100|
                  |L6.28|
;;;65         }
;;;66         else if ( UARTx == UART1 )
00001c  481f              LDR      r0,|L6.156|
00001e  3060              ADDS     r0,r0,#0x60
000020  4284              CMP      r4,r0
000022  d108              BNE      |L6.54|
;;;67         {
;;;68             /* Enable UART1 reset state */
;;;69             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, ENABLE );
000024  2101              MOVS     r1,#1
000026  2080              MOVS     r0,#0x80
000028  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;70             /* Release UART1 from reset state */
;;;71             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, DISABLE );
00002c  2100              MOVS     r1,#0
00002e  2080              MOVS     r0,#0x80
000030  f7fffffe          BL       RCC_APB0PeriphResetCmd
000034  e016              B        |L6.100|
                  |L6.54|
;;;72         }
;;;73         else if ( UARTx == UART2 )
000036  481a              LDR      r0,|L6.160|
000038  4284              CMP      r4,r0
00003a  d108              BNE      |L6.78|
;;;74         {
;;;75             /* Enable UART2 reset state */
;;;76             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, ENABLE );
00003c  2101              MOVS     r1,#1
00003e  2080              MOVS     r0,#0x80
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;77             /* Release UART2 from reset state */
;;;78             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, DISABLE );
000044  2100              MOVS     r1,#0
000046  2080              MOVS     r0,#0x80
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004c  e00a              B        |L6.100|
                  |L6.78|
;;;79         }
;;;80     #if !(defined(SC32f15xx)||defined(SC32R601))
;;;81         else if ( UARTx == UART3 )
00004e  4815              LDR      r0,|L6.164|
000050  4284              CMP      r4,r0
000052  d107              BNE      |L6.100|
;;;82         {
;;;83             /* Enable UART3 reset state */
;;;84             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, ENABLE );
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;85             /* Release UART3 from reset state */
;;;86             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, DISABLE );
00005c  2100              MOVS     r1,#0
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L6.100|
;;;87         }
;;;88     #endif
;;;89     #if  defined(SC32R803) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;90         if ( UARTx == UART4 )
000064  480e              LDR      r0,|L6.160|
000066  3060              ADDS     r0,r0,#0x60
000068  4284              CMP      r4,r0
00006a  d108              BNE      |L6.126|
;;;91         {
;;;92             /* Enable UART0 reset state */
;;;93             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, ENABLE );
00006c  2101              MOVS     r1,#1
00006e  2040              MOVS     r0,#0x40
000070  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;94             /* Release UART0 from reset state */
;;;95             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, DISABLE );
000074  2100              MOVS     r1,#0
000076  2040              MOVS     r0,#0x40
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L6.124|
;;;96         }
;;;97         else if ( UARTx == UART5 )
;;;98         {
;;;99             /* Enable UART5 reset state */
;;;100            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, ENABLE );
;;;101            /* Release UART5 from reset state */
;;;102            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, DISABLE );
;;;103        }
;;;104    #endif
;;;105    }
00007c  bd10              POP      {r4,pc}
                  |L6.126|
00007e  4807              LDR      r0,|L6.156|
000080  3080              ADDS     r0,r0,#0x80           ;97
000082  4284              CMP      r4,r0                 ;97
000084  d1fa              BNE      |L6.124|
000086  1544              ASRS     r4,r0,#21             ;100
000088  2101              MOVS     r1,#1                 ;100
00008a  4620              MOV      r0,r4                 ;100
00008c  f7fffffe          BL       RCC_APB0PeriphResetCmd
000090  2100              MOVS     r1,#0                 ;102
000092  4620              MOV      r0,r4                 ;102
000094  f7fffffe          BL       RCC_APB0PeriphResetCmd
000098  bd10              POP      {r4,pc}
;;;106    
                          ENDP

00009a  0000              DCW      0x0000
                  |L6.156|
                          DCD      0x40020020
                  |L6.160|
                          DCD      0x40021020
                  |L6.164|
                          DCD      0x40022020

                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;475     */
;;;476    FlagStatus UART_GetFlagStatus ( UART_TypeDef* UARTx, UART_FLAG_TypeDef UART_FLAG )
000000  4602              MOV      r2,r0
;;;477    {
;;;478        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;479        /* Check the parameters */
;;;480        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;481        assert_param ( IS_GET_UART_FLAG ( UART_FLAG ) );
;;;482    
;;;483        if ( ( UARTx->UART_STS & UART_FLAG ) != ( uint16_t ) RESET )
000004  6852              LDR      r2,[r2,#4]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L7.12|
;;;484        {
;;;485            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;486        }
;;;487        else
;;;488        {
;;;489            bitstatus = RESET;
;;;490        }
;;;491        return bitstatus;
;;;492    }
00000c  4770              BX       lr
;;;493    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;432     */
;;;433    void UART_ITConfig ( UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;434    {
000002  d003              BEQ      |L8.12|
;;;435        /* Check the parameters */
;;;436        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;437        assert_param ( IS_UART_IT ( UART_IT ) );
;;;438        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;439    
;;;440        if ( NewState != DISABLE )
;;;441        {
;;;442            /* Enable the Interrupt sources */
;;;443            UARTx->UART_IDE |= UART_IT;
000004  6902              LDR      r2,[r0,#0x10]
000006  430a              ORRS     r2,r2,r1
000008  6102              STR      r2,[r0,#0x10]
;;;444        }
;;;445        else
;;;446        {
;;;447            /* Disable the Interrupt sources */
;;;448            UARTx->UART_IDE &= ( uint16_t ) ~UART_IT;
;;;449        }
;;;450    }
00000a  4770              BX       lr
                  |L8.12|
00000c  6902              LDR      r2,[r0,#0x10]         ;448
00000e  43c9              MVNS     r1,r1                 ;448
000010  b289              UXTH     r1,r1                 ;448
000012  400a              ANDS     r2,r2,r1              ;448
000014  6102              STR      r2,[r0,#0x10]         ;448
000016  4770              BX       lr
;;;451    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;124     */
;;;125    void UART_Init ( UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct )
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127        uint32_t tmpreg;
;;;128        /* Check the parameters */
;;;129        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;130        assert_param ( IS_UART_Mode ( UART_InitStruct->UART_Mode ) );
;;;131    
;;;132        tmpreg = UARTx->UART_CON;
000004  6820              LDR      r0,[r4,#0]
;;;133        tmpreg &= ( uint32_t ) ~ ( UART_CON_SM01 | UART_CON_SM2 );
000006  08c0              LSRS     r0,r0,#3
000008  00c0              LSLS     r0,r0,#3
;;;134        tmpreg |= ( uint32_t ) ( UART_InitStruct->UART_Mode );
00000a  688a              LDR      r2,[r1,#8]
00000c  4302              ORRS     r2,r2,r0
;;;135        UARTx->UART_CON = tmpreg;
00000e  6022              STR      r2,[r4,#0]
;;;136    
;;;137        if ( UART_InitStruct->UART_Mode == UART_Mode_8B )
000010  6888              LDR      r0,[r1,#8]
;;;138        {
;;;139            assert_param ( IS_UART_PRESCALER ( UART_InitStruct->UART_BaudRate ) );
;;;140    
;;;141            UARTx->UART_CON &= ~ ( uint32_t ) UART_CON_PERSCALER;
000012  2510              MOVS     r5,#0x10
000014  2800              CMP      r0,#0                 ;137
000016  d00e              BEQ      |L9.54|
;;;142            UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
;;;143        }
;;;144        else
;;;145        {
;;;146            tmpreg = ( UART_InitStruct->UART_ClockFrequency / UART_InitStruct->UART_BaudRate );
000018  6848              LDR      r0,[r1,#4]
00001a  680a              LDR      r2,[r1,#0]
00001c  4601              MOV      r1,r0
00001e  4610              MOV      r0,r2
000020  f7fffffe          BL       __aeabi_uidivmod
;;;147            if ( tmpreg > 65535 )
000024  4907              LDR      r1,|L9.68|
000026  4288              CMP      r0,r1
000028  d903              BLS      |L9.50|
;;;148            {
;;;149                UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
00002a  6821              LDR      r1,[r4,#0]
00002c  4329              ORRS     r1,r1,r5
00002e  6021              STR      r1,[r4,#0]
;;;150                tmpreg = tmpreg / 16;
000030  0900              LSRS     r0,r0,#4
                  |L9.50|
;;;151            }
;;;152            UARTx->UART_BAUD = tmpreg;
000032  60a0              STR      r0,[r4,#8]
;;;153        }
;;;154    }
000034  bd70              POP      {r4-r6,pc}
                  |L9.54|
000036  6820              LDR      r0,[r4,#0]            ;141
000038  43a8              BICS     r0,r0,r5              ;141
00003a  6020              STR      r0,[r4,#0]            ;141
00003c  6820              LDR      r0,[r4,#0]            ;142
00003e  4328              ORRS     r0,r0,r5              ;142
000040  6020              STR      r0,[r4,#0]            ;142
000042  bd70              POP      {r4-r6,pc}
;;;155    
                          ENDP

                  |L9.68|
                          DCD      0x0000ffff

                          AREA ||i.UART_LIN_BKSIZE||, CODE, READONLY, ALIGN=2

                  UART_LIN_BKSIZE PROC
;;;615     */
;;;616    void UART_LIN_BKSIZE ( UART_TypeDef* UARTx, UART_BKSIZE_TypeDef BKSIZE )
000000  4a05              LDR      r2,|L10.24|
;;;617    {
;;;618        uint32_t temp;
;;;619        /* Check the parameters */
;;;620        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;621        assert_param ( IS_UART_BKSIZE ( BKSIZE ) );
;;;622    
;;;623        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d107              BNE      |L10.22|
;;;624        {
;;;625            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L10.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;626            temp &= ~UART_CON_BKSIZE;
00000c  2301              MOVS     r3,#1
00000e  069b              LSLS     r3,r3,#26
000010  4398              BICS     r0,r0,r3
;;;627            temp |= BKSIZE;
000012  4308              ORRS     r0,r0,r1
;;;628            /**/
;;;629            UART2->UART_CON = temp;
000014  6210              STR      r0,[r2,#0x20]
                  |L10.22|
;;;630        }
;;;631    
;;;632    }
000016  4770              BX       lr
;;;633    
                          ENDP

                  |L10.24|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_LBDL||, CODE, READONLY, ALIGN=2

                  UART_LIN_LBDL PROC
;;;687     */
;;;688    void UART_LIN_LBDL ( UART_TypeDef* UARTx, UART_LBDL_TypeDef LBDL )
000000  4a05              LDR      r2,|L11.24|
;;;689    {
;;;690        uint32_t temp;
;;;691        /* Check the parameters */
;;;692        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;693        assert_param ( IS_UART_LBDL ( LBDL ) );
;;;694    
;;;695        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d107              BNE      |L11.22|
;;;696        {
;;;697            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L11.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;698            temp &= ~UART_CON_LBDL;
00000c  2301              MOVS     r3,#1
00000e  049b              LSLS     r3,r3,#18
000010  4398              BICS     r0,r0,r3
;;;699            temp |= LBDL;
000012  4308              ORRS     r0,r0,r1
;;;700            UART2->UART_CON = temp;
000014  6210              STR      r0,[r2,#0x20]
                  |L11.22|
;;;701        }
;;;702    
;;;703    
;;;704    
;;;705    
;;;706    }
000016  4770              BX       lr
;;;707    
                          ENDP

                  |L11.24|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_MODE||, CODE, READONLY, ALIGN=2

                  UART_LIN_MODE PROC
;;;591    
;;;592    void UART_LIN_MODE ( UART_TypeDef* UARTx, UART_LINMODE_TypeDef UART_LINMODE )
000000  4a05              LDR      r2,|L12.24|
;;;593    {
;;;594        uint32_t temp;
;;;595        /* Check the parameters */
;;;596        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;597        assert_param ( IS_UART_LINMODE ( UART_LINMODE ) );
;;;598    
;;;599        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d106              BNE      |L12.20|
;;;600        {
;;;601            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L12.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;602            temp &= ~ ( UART_CON_SLVEN | UART_CON_FUNCSEL );
00000c  4b03              LDR      r3,|L12.28|
00000e  4018              ANDS     r0,r0,r3
;;;603            temp |= UART_LINMODE;
000010  4308              ORRS     r0,r0,r1
;;;604            UART2->UART_CON = temp;
000012  6210              STR      r0,[r2,#0x20]
                  |L12.20|
;;;605        }
;;;606    }
000014  4770              BX       lr
;;;607    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40021020
                  |L12.28|
                          DCD      0xfffefeff

                          AREA ||i.UART_LIN_SLVARENE||, CODE, READONLY, ALIGN=2

                  UART_LIN_SLVARENE PROC
;;;652     */
;;;653    void UART_LIN_SLVARENE ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  4a08              LDR      r2,|L13.36|
;;;654    {
;;;655    
;;;656        /* Check the parameters */
;;;657        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;658    
;;;659        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d108              BNE      |L13.24|
;;;660        {
;;;661            if ( NewState != DISABLE )
;;;662            {
;;;663                /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;664                   DMAR bits in the UART IDE register */
;;;665                UART2->UART_CON |= UART_CON_SLVAREN;
000006  4807              LDR      r0,|L13.36|
000008  2201              MOVS     r2,#1
00000a  3820              SUBS     r0,r0,#0x20
00000c  0452              LSLS     r2,r2,#17
00000e  2900              CMP      r1,#0                 ;661
000010  d003              BEQ      |L13.26|
000012  6a01              LDR      r1,[r0,#0x20]
000014  4311              ORRS     r1,r1,r2
000016  6201              STR      r1,[r0,#0x20]
                  |L13.24|
;;;666            }
;;;667            else
;;;668            {
;;;669                /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;670                   DMAR bits in the UART IDE register */
;;;671                UART2->UART_CON &= ( uint32_t ) ~UART_CON_SLVAREN;
;;;672            }
;;;673    
;;;674    
;;;675        }
;;;676    
;;;677    }
000018  4770              BX       lr
                  |L13.26|
00001a  6a01              LDR      r1,[r0,#0x20]         ;671
00001c  4391              BICS     r1,r1,r2              ;671
00001e  6201              STR      r1,[r0,#0x20]         ;671
000020  4770              BX       lr
;;;678    
                          ENDP

000022  0000              DCW      0x0000
                  |L13.36|
                          DCD      0x40021020

                          AREA ||i.UART_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  UART_PinRemapConfig PROC
;;;352     */
;;;353    void UART_PinRemapConfig ( UART_TypeDef* UARTx, UART_PinRemap_TypeDef UART_Remap )
000000  6802              LDR      r2,[r0,#0]
;;;354    {
;;;355        uint32_t tmpreg;
;;;356    
;;;357        /* Check the parameters */
;;;358    #if defined(SC32f10xx)
;;;359        if ( UARTx == UART2 )
;;;360        {
;;;361            tmpreg = UARTx->UART_CON;
;;;362    
;;;363            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;364    
;;;365            tmpreg |= UART_Remap;
;;;366    
;;;367            UARTx->UART_CON = tmpreg;
;;;368        }
;;;369    #elif defined(SC32R803)
;;;370    
;;;371            tmpreg = UARTx->UART_CON;
;;;372    
;;;373            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
000002  2303              MOVS     r3,#3
000004  035b              LSLS     r3,r3,#13
000006  439a              BICS     r2,r2,r3
;;;374    
;;;375            tmpreg |= UART_Remap;
000008  430a              ORRS     r2,r2,r1
;;;376    
;;;377            UARTx->UART_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;378    
;;;379    #elif defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806) ||defined(SC32f15xx)||defined(SC32R601)
;;;380        tmpreg = UARTx->UART_CON;
;;;381    
;;;382        tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;383    
;;;384        tmpreg |= UART_Remap;
;;;385    
;;;386        UARTx->UART_CON = tmpreg;
;;;387    #endif
;;;388    }
00000c  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.UART_RXCmd||, CODE, READONLY, ALIGN=2

                  UART_RXCmd PROC
;;;209     */
;;;210    void UART_RXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;211    {
000002  d004              BEQ      |L15.14|
;;;212        /* Check the parameters */
;;;213        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;214        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;215    
;;;216        if ( NewState != DISABLE )
;;;217        {
;;;218            /* Enable the UART RX Function */
;;;219            UARTx->UART_CON |= UART_CON_RXEN;
000004  6801              LDR      r1,[r0,#0]
000006  2240              MOVS     r2,#0x40
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;220        }
;;;221        else
;;;222        {
;;;223            /* Disable the UART RX Function */
;;;224            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
;;;225        }
;;;226    }
00000c  4770              BX       lr
                  |L15.14|
00000e  6801              LDR      r1,[r0,#0]            ;224
000010  4a01              LDR      r2,|L15.24|
000012  4011              ANDS     r1,r1,r2              ;224
000014  6001              STR      r1,[r0,#0]            ;224
000016  4770              BX       lr
;;;227    
                          ENDP

                  |L15.24|
                          DCD      0x0000ffbf

                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;310     */
;;;311    uint16_t UART_ReceiveData ( UART_TypeDef* UARTx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;312    {
;;;313        /* Check the parameters */
;;;314        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;315    
;;;316        /* Receive Data */
;;;317        return ( uint16_t ) ( UARTx->UART_DATA & ( uint16_t ) 0x01FF );
000002  05c0              LSLS     r0,r0,#23
000004  0dc0              LSRS     r0,r0,#23
;;;318    }
000006  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.UART_SendArray||, CODE, READONLY, ALIGN=1

                  UART_SendArray PROC
;;;272    }
;;;273    void UART_SendArray(UART_TypeDef* UARTx,uint8_t *Array, uint16_t Length)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;274    {
000002  460d              MOV      r5,r1
000004  4616              MOV      r6,r2
;;;275    	uint16_t i;
;;;276    	for (i = 0; i < Length; i ++)		//遍历数组
000006  2400              MOVS     r4,#0
;;;277    	{
;;;278    		UART_SendByte(UARTx,Array[i]);		//依次调用Serial_SendByte发送每个字节数据
;;;279    		delay_ms(1000);
000008  277d              MOVS     r7,#0x7d
00000a  00ff              LSLS     r7,r7,#3
00000c  e008              B        |L17.32|
                  |L17.14|
00000e  5d29              LDRB     r1,[r5,r4]            ;278
000010  9800              LDR      r0,[sp,#0]            ;278
000012  f7fffffe          BL       UART_SendByte
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       delay_ms
00001c  1c64              ADDS     r4,r4,#1              ;276
00001e  b2a4              UXTH     r4,r4                 ;276
                  |L17.32|
000020  42b4              CMP      r4,r6                 ;276
000022  d3f4              BCC      |L17.14|
;;;280    	}
;;;281    }
000024  bdfe              POP      {r1-r7,pc}
;;;282    void UART_SendPacket()
                          ENDP


                          AREA ||i.UART_SendBreak||, CODE, READONLY, ALIGN=2

                  UART_SendBreak PROC
;;;637     */
;;;638    void UART_SendBreak()
000000  4803              LDR      r0,|L18.16|
;;;639    {
;;;640        UART2->UART_CON |= UART_CON_BKTR;
000002  6a01              LDR      r1,[r0,#0x20]
000004  2201              MOVS     r2,#1
000006  0612              LSLS     r2,r2,#24
000008  4311              ORRS     r1,r1,r2
00000a  6201              STR      r1,[r0,#0x20]
;;;641    }
00000c  4770              BX       lr
;;;642    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40021000

                          AREA ||i.UART_SendByte||, CODE, READONLY, ALIGN=1

                  UART_SendByte PROC
;;;266    
;;;267    void UART_SendByte(UART_TypeDef* UARTx,uint8_t Byte)
000000  b500              PUSH     {lr}
;;;268    {
000002  4603              MOV      r3,r0
;;;269    	UART_SendData(UARTx, Byte);		//将字节数据写入数据寄存器，写入后USART自动生成时序波形
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       UART_SendData
                  |L19.10|
;;;270    	while (UART_GetFlagStatus(UARTx, UART_Flag_TX) == RESET);	//等待发送完成
00000a  2102              MOVS     r1,#2
00000c  4618              MOV      r0,r3
00000e  f7fffffe          BL       UART_GetFlagStatus
000012  2800              CMP      r0,#0
000014  d0f9              BEQ      |L19.10|
;;;271    	/*下次写入数据寄存器会自动清除发送完成标志位，故此循环后，无需清除标志位*/
;;;272    }
000016  bd00              POP      {pc}
;;;273    void UART_SendArray(UART_TypeDef* UARTx,uint8_t *Array, uint16_t Length)
                          ENDP


                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;258     */
;;;259    void UART_SendData ( UART_TypeDef* UARTx, uint16_t Data )
000000  05c9              LSLS     r1,r1,#23
;;;260    {
;;;261        /* Check the parameters */
;;;262        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;263        /* Transmit Data */
;;;264        UARTx->UART_DATA = ( Data & ( uint16_t ) 0x01FF );
000002  0dc9              LSRS     r1,r1,#23
000004  60c1              STR      r1,[r0,#0xc]
;;;265    }
000006  4770              BX       lr
;;;266    
                          ENDP


                          AREA ||i.UART_SendPacket||, CODE, READONLY, ALIGN=2

                  UART_SendPacket PROC
;;;281    }
;;;282    void UART_SendPacket()
000000  b510              PUSH     {r4,lr}
;;;283    {
;;;284    	
;;;285    	UART_SendArray(UART3,UART3_TxPacket,4);
000002  2204              MOVS     r2,#4
000004  4902              LDR      r1,|L21.16|
000006  4803              LDR      r0,|L21.20|
000008  f7fffffe          BL       UART_SendArray
;;;286    }
00000c  bd10              POP      {r4,pc}
;;;287    void UART_SendString(UART_TypeDef* UARTx,char *String)
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      ||.bss||
                  |L21.20|
                          DCD      0x40022020

                          AREA ||i.UART_SendString||, CODE, READONLY, ALIGN=2

                  UART_SendString PROC
;;;286    }
;;;287    void UART_SendString(UART_TypeDef* UARTx,char *String)
000000  b5f8              PUSH     {r3-r7,lr}
;;;288    {
000002  460d              MOV      r5,r1
;;;289    	uint8_t i;
;;;290    	for (i = 0; String[i] != '\0'; i ++)//遍历字符数组（字符串），遇到字符串结束标志位后停止
000004  2400              MOVS     r4,#0
;;;291    	{
;;;292    		UART_SendByte(UART3,String[i]);		//依次调用Serial_SendByte发送每个字节数据
;;;293    		delay_ms(1000);
000006  277d              MOVS     r7,#0x7d
000008  4e07              LDR      r6,|L22.40|
00000a  00ff              LSLS     r7,r7,#3
00000c  e007              B        |L22.30|
                  |L22.14|
00000e  4630              MOV      r0,r6                 ;292
000010  f7fffffe          BL       UART_SendByte
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       delay_ms
00001a  1c64              ADDS     r4,r4,#1              ;290
00001c  b2e4              UXTB     r4,r4                 ;290
                  |L22.30|
00001e  5d29              LDRB     r1,[r5,r4]            ;290
000020  2900              CMP      r1,#0                 ;290
000022  d1f4              BNE      |L22.14|
;;;294    	}
;;;295    }
000024  bdf8              POP      {r3-r7,pc}
;;;296    /**
                          ENDP

000026  0000              DCW      0x0000
                  |L22.40|
                          DCD      0x40022020

                          AREA ||i.UART_TXCmd||, CODE, READONLY, ALIGN=2

                  UART_TXCmd PROC
;;;173     */
;;;174    void UART_TXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;175    {
000002  d004              BEQ      |L23.14|
;;;176        /* Check the parameters */
;;;177        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;178        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;179    
;;;180        if ( NewState != DISABLE )
;;;181        {
;;;182            /* Enable the UART TX Function */
;;;183            UARTx->UART_CON |= UART_CON_TXEN;
000004  6801              LDR      r1,[r0,#0]
000006  2280              MOVS     r2,#0x80
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;184        }
;;;185        else
;;;186        {
;;;187            /* Disable the UART TX Function */
;;;188            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_TXEN;
;;;189        }
;;;190    }
00000c  4770              BX       lr
                  |L23.14|
00000e  6801              LDR      r1,[r0,#0]            ;188
000010  4a01              LDR      r2,|L23.24|
000012  4011              ANDS     r1,r1,r2              ;188
000014  6001              STR      r1,[r0,#0]            ;188
000016  4770              BX       lr
;;;191    
                          ENDP

                  |L23.24|
                          DCD      0x0000ff7f

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;787    #if defined (__ARMCC_VERSION)||defined (__ICCARM__)
;;;788    __attribute__((weak)) int fputc ( int c, FILE* f )
000000  b510              PUSH     {r4,lr}
;;;789    {
000002  4604              MOV      r4,r0
;;;790        UART_SendData ( Printf_Uart, ( uint8_t ) c );
000004  4b08              LDR      r3,|L24.40|
000006  b2e1              UXTB     r1,r4
000008  6818              LDR      r0,[r3,#0]  ; Printf_Uart
00000a  f7fffffe          BL       UART_SendData
                  |L24.14|
;;;791        while ( !UART_GetFlagStatus ( Printf_Uart, UART_Flag_TX ) );
00000e  2102              MOVS     r1,#2
000010  6818              LDR      r0,[r3,#0]  ; Printf_Uart
000012  f7fffffe          BL       UART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L24.14|
;;;792        UART_ClearFlag ( Printf_Uart, UART_Flag_TX );
00001a  2102              MOVS     r1,#2
00001c  6818              LDR      r0,[r3,#0]  ; Printf_Uart
00001e  f7fffffe          BL       UART_ClearFlag
;;;793        return c;
000022  4620              MOV      r0,r4
;;;794    }
000024  bd10              POP      {r4,pc}
;;;795    #elif defined (__GNUC__)
                          ENDP

000026  0000              DCW      0x0000
                  |L24.40|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART3_TxPacket
                          %        10

                          AREA ||.data||, DATA, ALIGN=2

                  Printf_Uart
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_uart_c_c95a8597____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH|
#line 478
|__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
