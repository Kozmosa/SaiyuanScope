; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_iap.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_iap.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_iap.c]
                          THUMB

                          AREA ||i.DeInitFlashToRam||, CODE, READONLY, ALIGN=2

                  DeInitFlashToRam PROC
;;;73      */
;;;74     static void DeInitFlashToRam(void)
000000  2000              MOVS     r0,#0
;;;75     {
;;;76     		for(uint16_t i=0;i<sizeof(IapProgramInRam);i++)
;;;77     		{
;;;78     				IapProgramInRam[i]    =0;
000002  4a05              LDR      r2,|L1.24|
000004  2100              MOVS     r1,#0                 ;76
                  |L1.6|
000006  5411              STRB     r1,[r2,r0]
000008  1c40              ADDS     r0,r0,#1              ;76
00000a  b280              UXTH     r0,r0                 ;76
00000c  28b4              CMP      r0,#0xb4              ;76
00000e  d3fa              BCC      |L1.6|
;;;79     		}		
;;;80     		pWriteIapFun=(pInitIapInRam)IAP_NOP;		
000010  4903              LDR      r1,|L1.32|
000012  4802              LDR      r0,|L1.28|
000014  6008              STR      r0,[r1,#0]  ; pWriteIapFun
;;;81     }
000016  4770              BX       lr
;;;82     
                          ENDP

                  |L1.24|
                          DCD      ||.bss||
                  |L1.28|
                          DCD      IAP_NOP
                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.IAP_EEPROMEraseSector||, CODE, READONLY, ALIGN=2

                  IAP_EEPROMEraseSector PROC
;;;361      */
;;;362    void IAP_EEPROMEraseSector ( uint32_t IAP_Sector )
000000  2169              MOVS     r1,#0x69
;;;363    {
;;;364        uint32_t tmpreg;
;;;365        IAP->IAP_SNB = 0x69000000 | IAP_Sector;
000002  0609              LSLS     r1,r1,#24
000004  4308              ORRS     r0,r0,r1
000006  4908              LDR      r1,|L2.40|
000008  6048              STR      r0,[r1,#4]
;;;366        tmpreg = IAP->IAP_CON;
00000a  68c8              LDR      r0,[r1,#0xc]
;;;367        tmpreg &= (uint32_t)~(IAP_CON_ERASE | IAP_CON_CMD | IAP_CON_PRG);
00000c  2293              MOVS     r2,#0x93
00000e  4390              BICS     r0,r0,r2
;;;368        tmpreg |= (uint32_t)(IAP_CON_SERASE  );
000010  2220              MOVS     r2,#0x20
000012  4310              ORRS     r0,r0,r2
;;;369    		/* Check if software lock is open (IAP write operations are permitted) */
;;;370    		if(IapWriteFlag==IAP_ENABLE)
000014  4a05              LDR      r2,|L2.44|
000016  6852              LDR      r2,[r2,#4]  ; IapWriteFlag
000018  2a69              CMP      r2,#0x69
00001a  d104              BNE      |L2.38|
;;;371    		{
;;;372    				IAP->IAP_CON = tmpreg;
00001c  60c8              STR      r0,[r1,#0xc]
;;;373    				IAP->IAP_CON |= (0x02 << IAP_CON_CMD_Pos);
00001e  68c8              LDR      r0,[r1,#0xc]
000020  2202              MOVS     r2,#2
000022  4310              ORRS     r0,r0,r2
000024  60c8              STR      r0,[r1,#0xc]
                  |L2.38|
;;;374    		}
;;;375    }
000026  4770              BX       lr
;;;376    
                          ENDP

                  |L2.40|
                          DCD      0x400003c0
                  |L2.44|
                          DCD      ||.data||

                          AREA ||i.IAP_EraseSector||, CODE, READONLY, ALIGN=2

                  IAP_EraseSector PROC
;;;337      */
;;;338    void IAP_EraseSector ( uint32_t IAP_Sector )
000000  2113              MOVS     r1,#0x13
;;;339    {
;;;340        uint32_t tmpreg;
;;;341        IAP->IAP_SNB = 0x4C000000 | IAP_Sector;
000002  0689              LSLS     r1,r1,#26
000004  4308              ORRS     r0,r0,r1
000006  4908              LDR      r1,|L3.40|
000008  6048              STR      r0,[r1,#4]
;;;342        tmpreg = IAP->IAP_CON;
00000a  68c8              LDR      r0,[r1,#0xc]
;;;343        tmpreg &= ( uint32_t ) ~ ( IAP_CON_ERASE | IAP_CON_CMD | IAP_CON_PRG );
00000c  2293              MOVS     r2,#0x93
00000e  4390              BICS     r0,r0,r2
;;;344        tmpreg |= ( uint32_t ) ( IAP_CON_SERASE );
000010  2220              MOVS     r2,#0x20
000012  4310              ORRS     r0,r0,r2
;;;345    		/* Check if software lock is open (IAP write operations are permitted) */
;;;346    		if(IapWriteFlag==IAP_ENABLE)
000014  4a05              LDR      r2,|L3.44|
000016  6852              LDR      r2,[r2,#4]  ; IapWriteFlag
000018  2a69              CMP      r2,#0x69
00001a  d104              BNE      |L3.38|
;;;347    		{
;;;348    				IAP->IAP_CON = tmpreg;
00001c  60c8              STR      r0,[r1,#0xc]
;;;349    				IAP->IAP_CON |= ( 0x02 << IAP_CON_CMD_Pos );
00001e  68c8              LDR      r0,[r1,#0xc]
000020  2202              MOVS     r2,#2
000022  4310              ORRS     r0,r0,r2
000024  60c8              STR      r0,[r1,#0xc]
                  |L3.38|
;;;350    		}
;;;351    }
000026  4770              BX       lr
;;;352    
                          ENDP

                  |L3.40|
                          DCD      0x400003c0
                  |L3.44|
                          DCD      ||.data||

                          AREA ||i.IAP_Lock||, CODE, READONLY, ALIGN=2

                  IAP_Lock PROC
;;;294      */
;;;295    void IAP_Lock ( void )
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297        /* Set the LOCK Bit to lock the FLASH Registers access */
;;;298        IAP->IAP_CON = ( uint32_t ) IAP_CON_LOCK;
000002  2001              MOVS     r0,#1
000004  4902              LDR      r1,|L4.16|
000006  07c0              LSLS     r0,r0,#31
000008  60c8              STR      r0,[r1,#0xc]
;;;299    	
;;;300    		DeInitFlashToRam();
00000a  f7fffffe          BL       DeInitFlashToRam
;;;301    }
00000e  bd10              POP      {r4,pc}
;;;302    
                          ENDP

                  |L4.16|
                          DCD      0x400003c0

                          AREA ||i.IAP_NOP||, CODE, READONLY, ALIGN=1

                  IAP_NOP PROC
;;;87      */
;;;88     static boolType IAP_NOP(void)
000000  bf00              NOP      
;;;89     {
;;;90     		__NOP();
;;;91     		return FALSE;
000002  2000              MOVS     r0,#0
;;;92     }
000004  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i.IAP_ProgramArray_InRam||, CODE, READONLY, ALIGN=2

                  IAP_ProgramArray_InRam PROC
;;;180     */  
;;;181    static uint16_t IAP_ProgramArray_InRam( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize,IAPWRITE_ALIGNTYPE Type )
000000  b5f0              PUSH     {r4-r7,lr}
;;;182    {
000002  4694              MOV      r12,r2
;;;183    		uint16_t tmpCnt = 0;
000004  2400              MOVS     r4,#0
;;;184    		/* Disable non-maskable interrupts */
;;;185    		uint32_t	Temp=RCC->NMI_CFG;
000006  4d27              LDR      r5,|L6.164|
000008  6aea              LDR      r2,[r5,#0x2c]
;;;186    		Temp =(Temp&0x0000FFFF)|0xA05F0000;
00000a  4e27              LDR      r6,|L6.168|
00000c  b292              UXTH     r2,r2
00000e  1997              ADDS     r7,r2,r6
;;;187    		RCC->NMI_CFG =Temp&0xFFFF0000;
000010  0c3a              LSRS     r2,r7,#16
000012  0412              LSLS     r2,r2,#16
000014  62ea              STR      r2,[r5,#0x2c]
;;;188    		/* Disable interrupt requests (IRQ) */
;;;189    		__disable_irq();
000016  b672              CPSID    i
;;;190    	  
;;;191    		/* Enable writing if the IAP software lock is open */
;;;192        /* IAP_WriteCmd(ENABLE); */
;;;193    		if(IapWriteFlag==IAP_ENABLE)
000018  4a24              LDR      r2,|L6.172|
00001a  6855              LDR      r5,[r2,#4]  ; IapWriteFlag
00001c  2d69              CMP      r5,#0x69
00001e  d105              BNE      |L6.44|
;;;194    		{
;;;195    				IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000020  4a23              LDR      r2,|L6.176|
000022  68d6              LDR      r6,[r2,#0xc]
000024  2210              MOVS     r2,#0x10
000026  4316              ORRS     r6,r6,r2
000028  4a21              LDR      r2,|L6.176|
00002a  60d6              STR      r6,[r2,#0xc]
                  |L6.44|
;;;196    		}
;;;197    		if(IapWriteFlag==IAP_ENABLE)
00002c  2d69              CMP      r5,#0x69
00002e  d12f              BNE      |L6.144|
                  |L6.48|
;;;198    		{
;;;199    				do
;;;200    				{			
;;;201    						switch(Type)
000030  2b00              CMP      r3,#0
000032  d004              BEQ      |L6.62|
000034  2b01              CMP      r3,#1
000036  d00c              BEQ      |L6.82|
000038  2b02              CMP      r3,#2
00003a  d125              BNE      |L6.136|
00003c  e017              B        |L6.110|
                  |L6.62|
;;;202    						{
;;;203    								/* Program byte (8-bit) Array at a specified address */
;;;204    								case IAP_BYTE:
;;;205    								{
;;;206    										* ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
00003e  5d0a              LDRB     r2,[r1,r4]
000040  7002              STRB     r2,[r0,#0]
;;;207    										* ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
000042  5d0a              LDRB     r2,[r1,r4]
000044  7002              STRB     r2,[r0,#0]
;;;208    										if ( ByteArray[tmpCnt] != * ( __IO uint8_t * ) Address )
000046  5d0a              LDRB     r2,[r1,r4]
000048  7805              LDRB     r5,[r0,#0]
00004a  42aa              CMP      r2,r5
00004c  d11c              BNE      |L6.136|
;;;209    										{
;;;210    												break;
;;;211    										}
;;;212    										Address = Address + 1;
00004e  1c40              ADDS     r0,r0,#1
;;;213    										break;
000050  e01a              B        |L6.136|
                  |L6.82|
;;;214    								}
;;;215    								/* Program halfword (16-bit) Array at a specified address */
;;;216    								case IAP_HALFWORD:
;;;217    								{
;;;218    										uint16_t* ByteArray16=(uint16_t*)ByteArray;
000052  460e              MOV      r6,r1
;;;219    										if ( ( Address & 0x01 ) == 0 )
000054  07c2              LSLS     r2,r0,#31
000056  d117              BNE      |L6.136|
;;;220    										{
;;;221    												* ( __IO uint16_t* ) Address = ByteArray16[tmpCnt];
000058  0065              LSLS     r5,r4,#1
00005a  5b72              LDRH     r2,[r6,r5]
00005c  8002              STRH     r2,[r0,#0]
;;;222    												* ( __IO uint16_t* ) Address = ByteArray16[tmpCnt];
00005e  5b72              LDRH     r2,[r6,r5]
000060  8002              STRH     r2,[r0,#0]
;;;223    												if ( ByteArray16[tmpCnt] != * ( __IO uint16_t * ) Address )
000062  5b72              LDRH     r2,[r6,r5]
000064  8805              LDRH     r5,[r0,#0]
000066  42aa              CMP      r2,r5
000068  d10e              BNE      |L6.136|
;;;224    												{
;;;225    														break;
;;;226    												}
;;;227    												Address = Address + 2;
00006a  1c80              ADDS     r0,r0,#2
00006c  e00c              B        |L6.136|
                  |L6.110|
;;;228    										}
;;;229    										break;
;;;230    								}
;;;231    								/* Program word (32-bit) Array at a specified address */
;;;232    								case IAP_WORD:
;;;233    								{
;;;234    										uint32_t* ByteArray32=(uint32_t*)ByteArray;;
00006e  460e              MOV      r6,r1
;;;235    										if ( ( Address & 0x03 ) == 0 )
000070  0782              LSLS     r2,r0,#30
000072  d109              BNE      |L6.136|
;;;236    										{
;;;237    												* ( __IO uint32_t* ) Address = (uint32_t)ByteArray32[tmpCnt];
000074  00a5              LSLS     r5,r4,#2
000076  5972              LDR      r2,[r6,r5]
000078  6002              STR      r2,[r0,#0]
;;;238    												* ( __IO uint32_t* ) Address = (uint32_t)ByteArray32[tmpCnt];							
00007a  5972              LDR      r2,[r6,r5]
00007c  6002              STR      r2,[r0,#0]
;;;239    												if ( ByteArray32[tmpCnt] != * ( __IO uint32_t * ) Address )
00007e  5972              LDR      r2,[r6,r5]
000080  6805              LDR      r5,[r0,#0]
000082  42aa              CMP      r2,r5
000084  d100              BNE      |L6.136|
;;;240    												{
;;;241    														break;			
;;;242    												}									
;;;243    												Address = Address + 4;
000086  1d00              ADDS     r0,r0,#4
                  |L6.136|
;;;244    										}	
;;;245    										break;					
;;;246    								}
;;;247    						}
;;;248    				}while ( ++tmpCnt < ArraySize );
000088  1c64              ADDS     r4,r4,#1
00008a  b2a4              UXTH     r4,r4
00008c  4564              CMP      r4,r12
00008e  d3cf              BCC      |L6.48|
                  |L6.144|
;;;249    		}
;;;250    		/* IAP_WriteCmd(DISABLE); */
;;;251        IAP->IAP_CON &= ( uint32_t ) ~IAP_CON_PRG;		
000090  4807              LDR      r0,|L6.176|
000092  68c1              LDR      r1,[r0,#0xc]
000094  2210              MOVS     r2,#0x10
000096  4391              BICS     r1,r1,r2
000098  60c1              STR      r1,[r0,#0xc]
;;;252    		/* Enable interrupt requests (IRQ) */
;;;253        __enable_irq();
00009a  b662              CPSIE    i
;;;254    		/* Restore the previous non-maskable interrupt (NMI) settings */
;;;255    		RCC->NMI_CFG =Temp;
00009c  4801              LDR      r0,|L6.164|
00009e  62c7              STR      r7,[r0,#0x2c]
;;;256    		return  tmpCnt;
0000a0  4620              MOV      r0,r4
;;;257    }
0000a2  bdf0              POP      {r4-r7,pc}
;;;258    
                          ENDP

                  |L6.164|
                          DCD      0x40003000
                  |L6.168|
                          DCD      0xa05f0000
                  |L6.172|
                          DCD      ||.data||
                  |L6.176|
                          DCD      0x400003c0

                          AREA ||i.IAP_ProgramByte||, CODE, READONLY, ALIGN=2

                  IAP_ProgramByte PROC
;;;591      */
;;;592    boolType IAP_ProgramByte ( uint32_t Address, uint8_t Data )
000000  b430              PUSH     {r4,r5}
;;;593    {
;;;594        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;595    		
;;;596    		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;597    	     directly write data to FLASH memory at the specified address */
;;;598    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
000002  4a0e              LDR      r2,|L7.60|
000004  6953              LDR      r3,[r2,#0x14]
000006  061c              LSLS     r4,r3,#24
;;;599    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
;;;600    		{
;;;601    				/* Check if software lock is open (IAP write operations are permitted) */
;;;602    				if(IapWriteFlag==IAP_ENABLE)
000008  4b0d              LDR      r3,|L7.64|
00000a  d50b              BPL      |L7.36|
00000c  6954              LDR      r4,[r2,#0x14]         ;599
00000e  0624              LSLS     r4,r4,#24             ;599
000010  d504              BPL      |L7.28|
000012  6952              LDR      r2,[r2,#0x14]         ;599
000014  0592              LSLS     r2,r2,#22             ;599
000016  0f92              LSRS     r2,r2,#30             ;599
000018  2a02              CMP      r2,#2                 ;599
00001a  d003              BEQ      |L7.36|
                  |L7.28|
;;;603    				{
;;;604    						* ( uint8_t* ) Address = Data;
;;;605    				}
;;;606    				/* Verify the data was written correctly by reading it back */
;;;607    				if ( Data == * ( uint8_t * ) Address )
;;;608    						return TRUE;
;;;609    				else
;;;610    						return FALSE;
;;;611    		}
;;;612    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;613           which points to the IAP write function that was previously copied to RAM */
;;;614    		else
;;;615    		{
;;;616    				boolType Flag;
;;;617    			  /* Execute the IAP write function from RAM via the function pointer */
;;;618    				Flag=(*pWriteIapFun)(Address,Data,IAP_BYTE);
00001c  681b              LDR      r3,[r3,#0]  ; pWriteIapFun
00001e  bc30              POP      {r4,r5}
000020  2200              MOVS     r2,#0
000022  4718              BX       r3
                  |L7.36|
000024  685a              LDR      r2,[r3,#4]            ;602  ; IapWriteFlag
000026  2a69              CMP      r2,#0x69              ;602
000028  d100              BNE      |L7.44|
00002a  7001              STRB     r1,[r0,#0]            ;604
                  |L7.44|
00002c  7800              LDRB     r0,[r0,#0]            ;607
00002e  4288              CMP      r0,r1                 ;607
000030  d102              BNE      |L7.56|
000032  2001              MOVS     r0,#1                 ;608
                  |L7.52|
;;;619    			  /* Return the result from the RAM-executed function */
;;;620    				return Flag;
;;;621    		}
;;;622    }
000034  bc30              POP      {r4,r5}
000036  4770              BX       lr
                  |L7.56|
000038  2000              MOVS     r0,#0                 ;610
00003a  e7fb              B        |L7.52|
;;;623    
                          ENDP

                  |L7.60|
                          DCD      0x40003000
                  |L7.64|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramByteArray||, CODE, READONLY, ALIGN=2

                  IAP_ProgramByteArray PROC
;;;1271     */
;;;1272   uint16_t IAP_ProgramByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b5f0              PUSH     {r4-r7,lr}
;;;1273   {
000002  b0c1              SUB      sp,sp,#0x104
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1274       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1275   		/* Counter for successfully programmed bytes */
;;;1276       uint16_t tmpCnt = 0;
00000a  2000              MOVS     r0,#0
;;;1277   		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;1278   	     directly write data to FLASH memory at the specified address */
;;;1279   		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
00000c  491e              LDR      r1,|L8.136|
00000e  694a              LDR      r2,[r1,#0x14]
000010  0612              LSLS     r2,r2,#24
000012  d528              BPL      |L8.102|
;;;1280   			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
000014  694a              LDR      r2,[r1,#0x14]
000016  0612              LSLS     r2,r2,#24
000018  d504              BPL      |L8.36|
00001a  6949              LDR      r1,[r1,#0x14]
00001c  0589              LSLS     r1,r1,#22
00001e  0f89              LSRS     r1,r1,#30
000020  2902              CMP      r1,#2
000022  d020              BEQ      |L8.102|
                  |L8.36|
;;;1281   		{
;;;1282   				/* Check if software lock is open (IAP write operations are permitted) */
;;;1283   				if(IapWriteFlag==IAP_ENABLE)
;;;1284   				{
;;;1285   						/* Program each byte in the array until completion or error */
;;;1286   						do
;;;1287   						{
;;;1288   								* ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
;;;1289   								/* Verify the write operation by reading back the value */
;;;1290   								if ( ByteArray[tmpCnt] != * ( __IO uint8_t * ) Address )
;;;1291   										break;
;;;1292   								/* Move to next byte address */
;;;1293   								Address = Address + 1;
;;;1294   						/* Continue until all bytes are programmed */
;;;1295   						} while ( ++tmpCnt < ArraySize );
;;;1296   				}
;;;1297   				/* Return count of successfully programmed bytes */
;;;1298   				return tmpCnt;
;;;1299   		}
;;;1300   		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;1301          which points to the IAP write function that was previously copied to RAM */
;;;1302   		else
;;;1303   		{
;;;1304   				/* Define function pointer type for the RAM-based IAP programming function */
;;;1305   				typedef uint16_t (*pInitFlashInRam)( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize,IAPWRITE_ALIGNTYPE Type );
;;;1306   				/* Allocate and initialize RAM buffer for the IAP programming function */
;;;1307   				__align(4) uint8_t IapWriteInRam[256]={0};	
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       __aeabi_memclr4
;;;1308   				/* Copy the IAP programming function from FLASH to RAM */
;;;1309   				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
00002e  2300              MOVS     r3,#0
;;;1310   				{
;;;1311   						IapWriteInRam[i] =*(uint8_t*)((uint32_t)IAP_ProgramArray_InRam-1+i);
000030  4a16              LDR      r2,|L8.140|
000032  a801              ADD      r0,sp,#4              ;1307
                  |L8.52|
000034  18d1              ADDS     r1,r2,r3
000036  3920              SUBS     r1,r1,#0x20
000038  7fc9              LDRB     r1,[r1,#0x1f]
00003a  54c1              STRB     r1,[r0,r3]
00003c  1c5b              ADDS     r3,r3,#1              ;1309
00003e  b29b              UXTH     r3,r3                 ;1309
000040  2bff              CMP      r3,#0xff              ;1309
000042  d9f7              BLS      |L8.52|
;;;1312   				}	
;;;1313   				/* Create function pointer to the RAM-based function and execute it */
;;;1314   				/* The "|0x01" operation sets the Thumb bit for ARM architecture compatibility.
;;;1315   				   In ARM architecture, the least significant bit (LSB) of a function pointer
;;;1316   				   indicates the instruction set (0 for ARM, 1 for Thumb). This ensures the
;;;1317   				   function executes in Thumb mode, which is typically used for RAM-based code.*/
;;;1318   				pInitFlashInRam p=(pInitFlashInRam)((uint32_t)IapWriteInRam|0x01);
000044  af01              ADD      r7,sp,#4
000046  3701              ADDS     r7,#1
;;;1319   				tmpCnt =(*p)(Address,(uint8_t*)ByteArray,ArraySize,IAP_BYTE);
000048  2300              MOVS     r3,#0
00004a  4632              MOV      r2,r6
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  47b8              BLX      r7
;;;1320   				/* Clear the RAM buffer */
;;;1321   				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
000052  2100              MOVS     r1,#0
000054  2300              MOVS     r3,#0
000056  aa01              ADD      r2,sp,#4              ;1307
                  |L8.88|
;;;1322   				{
;;;1323   						IapWriteInRam[i] =0;
000058  5453              STRB     r3,[r2,r1]
00005a  1c49              ADDS     r1,r1,#1              ;1321
00005c  b289              UXTH     r1,r1                 ;1321
00005e  29ff              CMP      r1,#0xff              ;1321
000060  d9fa              BLS      |L8.88|
                  |L8.98|
;;;1324   				}			
;;;1325   				/* Return count of successfully programmed bytes */
;;;1326   				return tmpCnt;	
;;;1327   		}
;;;1328   }
000062  b041              ADD      sp,sp,#0x104
000064  bdf0              POP      {r4-r7,pc}
                  |L8.102|
000066  490a              LDR      r1,|L8.144|
000068  6849              LDR      r1,[r1,#4]            ;1283  ; IapWriteFlag
00006a  2969              CMP      r1,#0x69              ;1283
00006c  d1f9              BNE      |L8.98|
                  |L8.110|
00006e  5c29              LDRB     r1,[r5,r0]            ;1288
000070  7021              STRB     r1,[r4,#0]            ;1288
000072  5c29              LDRB     r1,[r5,r0]            ;1290
000074  7822              LDRB     r2,[r4,#0]            ;1290
000076  4291              CMP      r1,r2                 ;1290
000078  d1f3              BNE      |L8.98|
00007a  1c64              ADDS     r4,r4,#1              ;1293
00007c  1c40              ADDS     r0,r0,#1              ;1295
00007e  b280              UXTH     r0,r0                 ;1295
000080  42b0              CMP      r0,r6                 ;1295
000082  d3f4              BCC      |L8.110|
000084  e7ed              B        |L8.98|
;;;1329   
                          ENDP

000086  0000              DCW      0x0000
                  |L8.136|
                          DCD      0x40003000
                  |L8.140|
                          DCD      IAP_ProgramArray_InRam
                  |L8.144|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  IAP_ProgramHalfWord PROC
;;;550      */
;;;551    boolType IAP_ProgramHalfWord ( uint32_t Address, uint16_t Data )
000000  b430              PUSH     {r4,r5}
;;;552    {
;;;553        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;554    
;;;555    		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;556    	     directly write data to FLASH memory at the specified address */
;;;557    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
000002  4a0e              LDR      r2,|L9.60|
000004  6953              LDR      r3,[r2,#0x14]
000006  061c              LSLS     r4,r3,#24
;;;558    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
;;;559    		{
;;;560    				/* Check if software lock is open (IAP write operations are permitted) */
;;;561    				if(IapWriteFlag==IAP_ENABLE)
000008  4b0d              LDR      r3,|L9.64|
00000a  d50b              BPL      |L9.36|
00000c  6954              LDR      r4,[r2,#0x14]         ;558
00000e  0624              LSLS     r4,r4,#24             ;558
000010  d504              BPL      |L9.28|
000012  6952              LDR      r2,[r2,#0x14]         ;558
000014  0592              LSLS     r2,r2,#22             ;558
000016  0f92              LSRS     r2,r2,#30             ;558
000018  2a02              CMP      r2,#2                 ;558
00001a  d003              BEQ      |L9.36|
                  |L9.28|
;;;562    				{
;;;563    						* ( __IO uint16_t* ) Address = Data;
;;;564    				}
;;;565    				/* Verify the data was written correctly by reading it back */
;;;566    				if ( Data == * ( __IO uint16_t * ) Address )
;;;567    						return TRUE;
;;;568    				else
;;;569    						return FALSE;
;;;570    		}	
;;;571    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;572           which points to the IAP write function that was previously copied to RAM */
;;;573    		else
;;;574    		{
;;;575    				boolType Flag;
;;;576    				/* Execute the IAP write function from RAM via the function pointer */
;;;577    				Flag=(*pWriteIapFun)(Address,Data,IAP_HALFWORD);
00001c  681b              LDR      r3,[r3,#0]  ; pWriteIapFun
00001e  bc30              POP      {r4,r5}
000020  2201              MOVS     r2,#1
000022  4718              BX       r3
                  |L9.36|
000024  685a              LDR      r2,[r3,#4]            ;561  ; IapWriteFlag
000026  2a69              CMP      r2,#0x69              ;561
000028  d100              BNE      |L9.44|
00002a  8001              STRH     r1,[r0,#0]            ;563
                  |L9.44|
00002c  8800              LDRH     r0,[r0,#0]            ;566
00002e  4288              CMP      r0,r1                 ;566
000030  d102              BNE      |L9.56|
000032  2001              MOVS     r0,#1                 ;567
                  |L9.52|
;;;578    				/* Return the result from the RAM-executed function */
;;;579    				return Flag;	
;;;580    		}
;;;581    }
000034  bc30              POP      {r4,r5}
000036  4770              BX       lr
                  |L9.56|
000038  2000              MOVS     r0,#0                 ;569
00003a  e7fb              B        |L9.52|
;;;582    
                          ENDP

                  |L9.60|
                          DCD      0x40003000
                  |L9.64|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramHalfWordArray||, CODE, READONLY, ALIGN=2

                  IAP_ProgramHalfWordArray PROC
;;;1201     */
;;;1202   uint16_t IAP_ProgramHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b5f0              PUSH     {r4-r7,lr}
;;;1203   {
000002  b0c1              SUB      sp,sp,#0x104
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1204       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1205   		/* Counter for successfully programmed half-words */
;;;1206       uint16_t tmpCnt = 0;
00000a  2000              MOVS     r0,#0
;;;1207   		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;1208   	     directly write data to FLASH memory at the specified address */
;;;1209   		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
00000c  491f              LDR      r1,|L10.140|
00000e  694a              LDR      r2,[r1,#0x14]
000010  0612              LSLS     r2,r2,#24
000012  d528              BPL      |L10.102|
;;;1210   			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
000014  694a              LDR      r2,[r1,#0x14]
000016  0612              LSLS     r2,r2,#24
000018  d504              BPL      |L10.36|
00001a  6949              LDR      r1,[r1,#0x14]
00001c  0589              LSLS     r1,r1,#22
00001e  0f89              LSRS     r1,r1,#30
000020  2902              CMP      r1,#2
000022  d020              BEQ      |L10.102|
                  |L10.36|
;;;1211   		{
;;;1212   				/* Check if address is 16-bit aligned (required for half-word programming) */
;;;1213   				if ( ( Address & 0x01 ) == 0 )
;;;1214   				{
;;;1215   						/* Check if software lock is open (IAP write operations are permitted) */
;;;1216   						if(IapWriteFlag==IAP_ENABLE)
;;;1217   						{
;;;1218   								/* Program each half-word in the array until completion or error */
;;;1219   								do
;;;1220   								{
;;;1221   										* ( __IO uint16_t* ) Address = ByteArray[tmpCnt];
;;;1222   										/* Verify the write operation by reading back the value */
;;;1223   										if ( ByteArray[tmpCnt] != * ( __IO uint16_t * ) Address )
;;;1224   												break;
;;;1225   										/* Move to next 16-bit address */
;;;1226   										Address = Address + 2;
;;;1227   								/* Continue until all half-words are programmed */
;;;1228   								} while ( ++tmpCnt < ArraySize );
;;;1229   					  }
;;;1230   				}
;;;1231   				/* Return count of successfully programmed half-words */
;;;1232   				return tmpCnt;
;;;1233   		}
;;;1234   		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;1235          which points to the IAP write function that was previously copied to RAM */
;;;1236   		else
;;;1237   		{
;;;1238   				/* Define function pointer type for the RAM-based IAP programming function */
;;;1239   				typedef uint16_t (*pInitFlashInRam)( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize,IAPWRITE_ALIGNTYPE Type );
;;;1240   				/* Allocate and initialize RAM buffer for the IAP programming function */
;;;1241   				__align(4) uint8_t IapWriteInRam[256]={0};
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       __aeabi_memclr4
;;;1242   				/* Copy the IAP programming function from FLASH to RAM */
;;;1243   				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
00002e  2300              MOVS     r3,#0
;;;1244   				{
;;;1245   						IapWriteInRam[i] =*(uint8_t*)((uint32_t)IAP_ProgramArray_InRam-1+i);
000030  4a17              LDR      r2,|L10.144|
000032  a801              ADD      r0,sp,#4              ;1241
                  |L10.52|
000034  18d1              ADDS     r1,r2,r3
000036  3920              SUBS     r1,r1,#0x20
000038  7fc9              LDRB     r1,[r1,#0x1f]
00003a  54c1              STRB     r1,[r0,r3]
00003c  1c5b              ADDS     r3,r3,#1              ;1243
00003e  b29b              UXTH     r3,r3                 ;1243
000040  2bff              CMP      r3,#0xff              ;1243
000042  d9f7              BLS      |L10.52|
;;;1246   				}	
;;;1247   				/* Create function pointer to the RAM-based function and execute it */
;;;1248   				/* The "|0x01" operation sets the Thumb bit for ARM architecture compatibility.
;;;1249   				   In ARM architecture, the least significant bit (LSB) of a function pointer
;;;1250   				   indicates the instruction set (0 for ARM, 1 for Thumb). This ensures the
;;;1251   				   function executes in Thumb mode, which is typically used for RAM-based code.*/
;;;1252   				pInitFlashInRam p=(pInitFlashInRam)((uint32_t)IapWriteInRam|0x01);
000044  af01              ADD      r7,sp,#4
000046  3701              ADDS     r7,#1
;;;1253   				tmpCnt =(*p)(Address,(uint8_t*)ByteArray,ArraySize,IAP_HALFWORD);
000048  2301              MOVS     r3,#1
00004a  4632              MOV      r2,r6
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  47b8              BLX      r7
;;;1254   				/* Clear the RAM buffer */
;;;1255   				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
000052  2100              MOVS     r1,#0
000054  2300              MOVS     r3,#0
000056  aa01              ADD      r2,sp,#4              ;1241
                  |L10.88|
;;;1256   				{
;;;1257   						IapWriteInRam[i] =0;
000058  5453              STRB     r3,[r2,r1]
00005a  1c49              ADDS     r1,r1,#1              ;1255
00005c  b289              UXTH     r1,r1                 ;1255
00005e  29ff              CMP      r1,#0xff              ;1255
000060  d9fa              BLS      |L10.88|
                  |L10.98|
;;;1258   				}
;;;1259   				/* Return count of successfully programmed half-words */
;;;1260   				return tmpCnt;
;;;1261   		}
;;;1262   }
000062  b041              ADD      sp,sp,#0x104
000064  bdf0              POP      {r4-r7,pc}
                  |L10.102|
000066  07e1              LSLS     r1,r4,#31             ;1213
000068  d1fb              BNE      |L10.98|
00006a  490a              LDR      r1,|L10.148|
00006c  6849              LDR      r1,[r1,#4]            ;1216  ; IapWriteFlag
00006e  2969              CMP      r1,#0x69              ;1216
000070  d1f7              BNE      |L10.98|
                  |L10.114|
000072  0041              LSLS     r1,r0,#1              ;1221
000074  5a6a              LDRH     r2,[r5,r1]            ;1221
000076  8022              STRH     r2,[r4,#0]            ;1221
000078  5a69              LDRH     r1,[r5,r1]            ;1223
00007a  8822              LDRH     r2,[r4,#0]            ;1223
00007c  4291              CMP      r1,r2                 ;1223
00007e  d1f0              BNE      |L10.98|
000080  1ca4              ADDS     r4,r4,#2              ;1226
000082  1c40              ADDS     r0,r0,#1              ;1228
000084  b280              UXTH     r0,r0                 ;1228
000086  42b0              CMP      r0,r6                 ;1228
000088  d3f3              BCC      |L10.114|
00008a  e7ea              B        |L10.98|
;;;1263   
                          ENDP

                  |L10.140|
                          DCD      0x40003000
                  |L10.144|
                          DCD      IAP_ProgramArray_InRam
                  |L10.148|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramWord||, CODE, READONLY, ALIGN=2

                  IAP_ProgramWord PROC
;;;509      */
;;;510    boolType IAP_ProgramWord ( uint32_t Address, uint32_t Data )
000000  b430              PUSH     {r4,r5}
;;;511    {
;;;512        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;513    		
;;;514    		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;515    	     directly write data to FLASH memory at the specified address */
;;;516    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
000002  4a0e              LDR      r2,|L11.60|
000004  6953              LDR      r3,[r2,#0x14]
000006  061c              LSLS     r4,r3,#24
;;;517    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
;;;518    		{
;;;519    				/* Check if software lock is open (IAP write operations are permitted) */
;;;520    				if(IapWriteFlag==IAP_ENABLE)
000008  4b0d              LDR      r3,|L11.64|
00000a  d50b              BPL      |L11.36|
00000c  6954              LDR      r4,[r2,#0x14]         ;517
00000e  0624              LSLS     r4,r4,#24             ;517
000010  d504              BPL      |L11.28|
000012  6952              LDR      r2,[r2,#0x14]         ;517
000014  0592              LSLS     r2,r2,#22             ;517
000016  0f92              LSRS     r2,r2,#30             ;517
000018  2a02              CMP      r2,#2                 ;517
00001a  d003              BEQ      |L11.36|
                  |L11.28|
;;;521    				{
;;;522    						* ( __IO uint32_t* ) Address = Data;
;;;523    				}
;;;524    				/* Verify the data was written correctly by reading it back */
;;;525    				if ( Data == * ( __IO uint32_t * ) Address )
;;;526    						return TRUE;
;;;527    				else
;;;528    						return FALSE;
;;;529    		}
;;;530    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun 
;;;531    		   which points to the IAP write function that was previously copied to RAM */
;;;532    		else
;;;533    		{
;;;534    				boolType Flag;
;;;535    				/* Execute the IAP write function from RAM via the function pointer */
;;;536    				Flag=(*pWriteIapFun)(Address,Data,IAP_WORD);
00001c  681b              LDR      r3,[r3,#0]  ; pWriteIapFun
00001e  bc30              POP      {r4,r5}
000020  2202              MOVS     r2,#2
000022  4718              BX       r3
                  |L11.36|
000024  685a              LDR      r2,[r3,#4]            ;520  ; IapWriteFlag
000026  2a69              CMP      r2,#0x69              ;520
000028  d100              BNE      |L11.44|
00002a  6001              STR      r1,[r0,#0]            ;522
                  |L11.44|
00002c  6800              LDR      r0,[r0,#0]            ;525
00002e  4288              CMP      r0,r1                 ;525
000030  d102              BNE      |L11.56|
000032  2001              MOVS     r0,#1                 ;526
                  |L11.52|
;;;537    				/* Return the result from the RAM-executed function */
;;;538    				return Flag;
;;;539    		}
;;;540    }
000034  bc30              POP      {r4,r5}
000036  4770              BX       lr
                  |L11.56|
000038  2000              MOVS     r0,#0                 ;528
00003a  e7fb              B        |L11.52|
;;;541    
                          ENDP

                  |L11.60|
                          DCD      0x40003000
                  |L11.64|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramWordArray||, CODE, READONLY, ALIGN=2

                  IAP_ProgramWordArray PROC
;;;1131     */
;;;1132   uint16_t IAP_ProgramWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b5f0              PUSH     {r4-r7,lr}
;;;1133   {
000002  b0c1              SUB      sp,sp,#0x104
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1134       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1135   		/* Counter for successfully programmed words */
;;;1136       uint16_t tmpCnt = 0;
00000a  2000              MOVS     r0,#0
;;;1137   		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;1138   	     directly write data to FLASH memory at the specified address */
;;;1139   		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
00000c  491f              LDR      r1,|L12.140|
00000e  694a              LDR      r2,[r1,#0x14]
000010  0612              LSLS     r2,r2,#24
000012  d528              BPL      |L12.102|
;;;1140   			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
000014  694a              LDR      r2,[r1,#0x14]
000016  0612              LSLS     r2,r2,#24
000018  d504              BPL      |L12.36|
00001a  6949              LDR      r1,[r1,#0x14]
00001c  0589              LSLS     r1,r1,#22
00001e  0f89              LSRS     r1,r1,#30
000020  2902              CMP      r1,#2
000022  d020              BEQ      |L12.102|
                  |L12.36|
;;;1141   		{
;;;1142   				/* Check if address is 32-bit aligned (required for word programming) */
;;;1143   				if ( ( Address & 0x03 ) == 0 )
;;;1144   				{
;;;1145   						/* Check if software lock is open (IAP write operations are permitted) */
;;;1146   						if(IapWriteFlag==IAP_ENABLE)
;;;1147   						{
;;;1148   								/* Program each word in the array until completion or error */
;;;1149   								do
;;;1150   								{
;;;1151   										* ( __IO uint32_t* ) Address = ByteArray[tmpCnt];
;;;1152   										/* Verify the write operation by reading back the value */
;;;1153   										if ( ByteArray[tmpCnt] != * ( __IO uint32_t * ) Address )
;;;1154   												break;
;;;1155   										/* Move to next 32-bit address */
;;;1156   										Address = Address + 4;
;;;1157   								/* Continue until all words are programmed */
;;;1158   								} while ( ++tmpCnt < ArraySize );
;;;1159   						}
;;;1160   				}
;;;1161   				/* Return count of successfully programmed words */
;;;1162   				return tmpCnt;
;;;1163   		}
;;;1164   		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;1165          which points to the IAP write function that was previously copied to RAM */
;;;1166   		else
;;;1167   		{
;;;1168   				/* Define function pointer type for the RAM-based IAP programming function */
;;;1169   				typedef uint16_t (*pInitFlashInRam)( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize,IAPWRITE_ALIGNTYPE Type );
;;;1170   				/* Allocate and initialize RAM buffer for the IAP programming function */
;;;1171   				__align(4) uint8_t IapWriteInRam[256]={0};
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       __aeabi_memclr4
;;;1172   				/* Copy the IAP programming function from FLASH to RAM */
;;;1173   				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
00002e  2300              MOVS     r3,#0
;;;1174   				{
;;;1175   						IapWriteInRam[i] =*(uint8_t*)((uint32_t)IAP_ProgramArray_InRam-1+i);
000030  4a17              LDR      r2,|L12.144|
000032  a801              ADD      r0,sp,#4              ;1171
                  |L12.52|
000034  18d1              ADDS     r1,r2,r3
000036  3920              SUBS     r1,r1,#0x20
000038  7fc9              LDRB     r1,[r1,#0x1f]
00003a  54c1              STRB     r1,[r0,r3]
00003c  1c5b              ADDS     r3,r3,#1              ;1173
00003e  b29b              UXTH     r3,r3                 ;1173
000040  2bff              CMP      r3,#0xff              ;1173
000042  d9f7              BLS      |L12.52|
;;;1176   				}
;;;1177   				/* Create function pointer to the RAM-based function and execute it */
;;;1178   				/* The "|0x01" operation sets the Thumb bit for ARM architecture compatibility.
;;;1179   				   In ARM architecture, the least significant bit (LSB) of a function pointer
;;;1180   				   indicates the instruction set (0 for ARM, 1 for Thumb). This ensures the
;;;1181   				   function executes in Thumb mode, which is typically used for RAM-based code.*/
;;;1182   				pInitFlashInRam p=(pInitFlashInRam)((uint32_t)IapWriteInRam|0x01);
000044  af01              ADD      r7,sp,#4
000046  3701              ADDS     r7,#1
;;;1183   				tmpCnt =(*p)(Address,(uint8_t*)ByteArray,ArraySize,IAP_WORD);
000048  2302              MOVS     r3,#2
00004a  4632              MOV      r2,r6
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  47b8              BLX      r7
;;;1184   				/* Clear the RAM buffer */
;;;1185   				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
000052  2100              MOVS     r1,#0
000054  2300              MOVS     r3,#0
000056  aa01              ADD      r2,sp,#4              ;1171
                  |L12.88|
;;;1186   				{
;;;1187   						IapWriteInRam[i] =0;
000058  5453              STRB     r3,[r2,r1]
00005a  1c49              ADDS     r1,r1,#1              ;1185
00005c  b289              UXTH     r1,r1                 ;1185
00005e  29ff              CMP      r1,#0xff              ;1185
000060  d9fa              BLS      |L12.88|
                  |L12.98|
;;;1188   				}
;;;1189   				/* Return count of successfully programmed words */
;;;1190   				return tmpCnt;		
;;;1191   		}
;;;1192   }
000062  b041              ADD      sp,sp,#0x104
000064  bdf0              POP      {r4-r7,pc}
                  |L12.102|
000066  07a1              LSLS     r1,r4,#30             ;1143
000068  d1fb              BNE      |L12.98|
00006a  490a              LDR      r1,|L12.148|
00006c  6849              LDR      r1,[r1,#4]            ;1146  ; IapWriteFlag
00006e  2969              CMP      r1,#0x69              ;1146
000070  d1f7              BNE      |L12.98|
                  |L12.114|
000072  0081              LSLS     r1,r0,#2              ;1151
000074  586a              LDR      r2,[r5,r1]            ;1151
000076  6022              STR      r2,[r4,#0]            ;1151
000078  5869              LDR      r1,[r5,r1]            ;1153
00007a  6822              LDR      r2,[r4,#0]            ;1153
00007c  4291              CMP      r1,r2                 ;1153
00007e  d1f0              BNE      |L12.98|
000080  1d24              ADDS     r4,r4,#4              ;1156
000082  1c40              ADDS     r0,r0,#1              ;1158
000084  b280              UXTH     r0,r0                 ;1158
000086  42b0              CMP      r0,r6                 ;1158
000088  d3f3              BCC      |L12.114|
00008a  e7ea              B        |L12.98|
;;;1193   
                          ENDP

                  |L12.140|
                          DCD      0x40003000
                  |L12.144|
                          DCD      IAP_ProgramArray_InRam
                  |L12.148|
                          DCD      ||.data||

                          AREA ||i.IAP_Program_InRam||, CODE, READONLY, ALIGN=2

                  IAP_Program_InRam PROC
;;;105     */  
;;;106    static boolType IAP_Program_InRam(uint32_t Address, uint32_t Data,IAPWRITE_ALIGNTYPE Type)
000000  b5f0              PUSH     {r4-r7,lr}
;;;107    {
000002  4694              MOV      r12,r2
;;;108    		boolType Flag;
;;;109    		/* Disable non-maskable interrupts */
;;;110    		uint32_t	Temp=RCC->NMI_CFG;
000004  4a16              LDR      r2,|L13.96|
000006  6ad3              LDR      r3,[r2,#0x2c]
;;;111    		Temp =(Temp&0x0000FFFF)|0xA05F0000;
000008  4c16              LDR      r4,|L13.100|
00000a  b29b              UXTH     r3,r3
00000c  191b              ADDS     r3,r3,r4
;;;112    		RCC->NMI_CFG =Temp&0xFFFF0000;
00000e  0c1c              LSRS     r4,r3,#16
000010  0424              LSLS     r4,r4,#16
000012  62d4              STR      r4,[r2,#0x2c]
;;;113    		/* Disable interrupt requests (IRQ) */
;;;114    		__disable_irq();
000014  b672              CPSID    i
;;;115    		
;;;116    		/* Enable writing if the IAP software lock is open */
;;;117        /* IAP_WriteCmd(ENABLE); */
;;;118    		if(IapWriteFlag==IAP_ENABLE)
000016  4c14              LDR      r4,|L13.104|
;;;119    		{
;;;120    				IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000018  4f14              LDR      r7,|L13.108|
00001a  6864              LDR      r4,[r4,#4]            ;118  ; IapWriteFlag
00001c  2510              MOVS     r5,#0x10
00001e  2c69              CMP      r4,#0x69              ;118
000020  d102              BNE      |L13.40|
000022  68fe              LDR      r6,[r7,#0xc]
000024  432e              ORRS     r6,r6,r5
000026  60fe              STR      r6,[r7,#0xc]
                  |L13.40|
;;;121    		}
;;;122    		if(IapWriteFlag==IAP_ENABLE)
000028  2c69              CMP      r4,#0x69
00002a  d112              BNE      |L13.82|
;;;123    		{
;;;124    				switch(Type)
00002c  4664              MOV      r4,r12
00002e  2c00              CMP      r4,#0
000030  d004              BEQ      |L13.60|
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L13.68|
000036  2c02              CMP      r4,#2
000038  d10b              BNE      |L13.82|
00003a  e007              B        |L13.76|
                  |L13.60|
;;;125    				{
;;;126    						/* Program a byte (8-bit) at a specified address */
;;;127    						case IAP_BYTE:
;;;128    						{
;;;129    								* ( uint8_t * ) Address = (uint8_t)Data;
;;;130    								* ( uint8_t * ) Address = (uint8_t)Data;
00003c  7001              STRB     r1,[r0,#0]
;;;131    								if ( (uint8_t)Data == * ( __IO uint8_t * ) Address )
00003e  7800              LDRB     r0,[r0,#0]
;;;132    										Flag= TRUE;
000040  2001              MOVS     r0,#1
000042  e006              B        |L13.82|
                  |L13.68|
;;;133    								else
;;;134    										Flag= FALSE;
;;;135    								break;
;;;136    						}
;;;137    						/* Program a halfword (16-bit) at a specified address */
;;;138    						case IAP_HALFWORD:
;;;139    						{
;;;140    								* ( uint16_t * ) Address = (uint16_t)Data;
;;;141    								* ( uint16_t * ) Address = (uint16_t)Data;
000044  8001              STRH     r1,[r0,#0]
;;;142    								if ( (uint16_t)Data == * ( __IO uint16_t * ) Address )
000046  8800              LDRH     r0,[r0,#0]
;;;143    										Flag= TRUE;
000048  2001              MOVS     r0,#1
00004a  e002              B        |L13.82|
                  |L13.76|
;;;144    								else
;;;145    										Flag= FALSE;						
;;;146    								break;
;;;147    						}			
;;;148    						/* Program a word (32-bit) at a specified address */
;;;149    						case IAP_WORD:
;;;150    						{
;;;151    								* ( uint32_t * ) Address = (uint32_t)Data;
00004c  6001              STR      r1,[r0,#0]
;;;152    								* ( uint32_t * ) Address = (uint32_t)Data;
;;;153    								if ( (uint32_t)Data == * ( __IO uint32_t * ) Address )
00004e  6800              LDR      r0,[r0,#0]
;;;154    										Flag= TRUE;
000050  2001              MOVS     r0,#1
                  |L13.82|
;;;155    								else
;;;156    										Flag= FALSE;						
;;;157    								break;
;;;158    						}
;;;159    				}
;;;160    		}
;;;161    		/* IAP_WriteCmd(DISABLE); */
;;;162        IAP->IAP_CON &= ( uint32_t ) ~IAP_CON_PRG;		
000052  68f9              LDR      r1,[r7,#0xc]
000054  43a9              BICS     r1,r1,r5
000056  60f9              STR      r1,[r7,#0xc]
;;;163    		/* Enable interrupt requests (IRQ) */
;;;164        __enable_irq();
000058  b662              CPSIE    i
;;;165    		/* Restore the previous non-maskable interrupt (NMI) settings */
;;;166    		RCC->NMI_CFG =Temp; 
00005a  62d3              STR      r3,[r2,#0x2c]
;;;167    		return Flag;
;;;168    }	
00005c  bdf0              POP      {r4-r7,pc}
;;;169    
                          ENDP

00005e  0000              DCW      0x0000
                  |L13.96|
                          DCD      0x40003000
                  |L13.100|
                          DCD      0xa05f0000
                  |L13.104|
                          DCD      ||.data||
                  |L13.108|
                          DCD      0x400003c0

                          AREA ||i.IAP_ReadByte||, CODE, READONLY, ALIGN=1

                  IAP_ReadByte PROC
;;;838      */
;;;839    uint8_t IAP_ReadByte ( uint32_t Address )
000000  7800              LDRB     r0,[r0,#0]
;;;840    {
;;;841        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;842    
;;;843        uint8_t Data;
;;;844        Data = * ( uint8_t* ) Address;
;;;845        return Data;
;;;846    }
000002  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.IAP_ReadByteArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadByteArray PROC
;;;1388     */
;;;1389   uint16_t IAP_ReadByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b510              PUSH     {r4,lr}
;;;1390   {
000002  4603              MOV      r3,r0
;;;1391       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1392   
;;;1393       uint16_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
                  |L15.6|
;;;1394       do
;;;1395       {
;;;1396           ByteArray[tmpCnt] = * ( __IO uint8_t* ) Address;
000006  781c              LDRB     r4,[r3,#0]
000008  1c5b              ADDS     r3,r3,#1
00000a  540c              STRB     r4,[r1,r0]
;;;1397           Address = Address + 1;
;;;1398   
;;;1399       } while ( ++tmpCnt < ArraySize );
00000c  1c40              ADDS     r0,r0,#1
00000e  b280              UXTH     r0,r0
000010  4290              CMP      r0,r2
000012  d3f8              BCC      |L15.6|
;;;1400   
;;;1401       return tmpCnt;
;;;1402   }
000014  bd10              POP      {r4,pc}
;;;1403   
                          ENDP


                          AREA ||i.IAP_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWord PROC
;;;823      */
;;;824    uint16_t IAP_ReadHalfWord ( uint32_t Address )
000000  8800              LDRH     r0,[r0,#0]
;;;825    {
;;;826        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;827    
;;;828        uint16_t Data;
;;;829        Data = * ( __IO uint16_t* ) Address;
;;;830        return Data;
;;;831    }
000002  4770              BX       lr
;;;832    
                          ENDP


                          AREA ||i.IAP_ReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWordArray PROC
;;;1363     */
;;;1364   uint16_t IAP_ReadHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;1365   {
000002  4603              MOV      r3,r0
;;;1366       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1367   
;;;1368       uint16_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;1369       if ( ( Address & 0x01 ) == 0 )
000006  07dc              LSLS     r4,r3,#31
000008  d107              BNE      |L17.26|
                  |L17.10|
;;;1370       {
;;;1371           do
;;;1372           {
;;;1373               ByteArray[tmpCnt] = * ( __IO uint16_t* ) Address;
00000a  881c              LDRH     r4,[r3,#0]
00000c  1c9b              ADDS     r3,r3,#2
00000e  0045              LSLS     r5,r0,#1
000010  534c              STRH     r4,[r1,r5]
;;;1374               Address = Address + 2;
;;;1375   
;;;1376           } while ( ++tmpCnt < ArraySize );
000012  1c40              ADDS     r0,r0,#1
000014  b280              UXTH     r0,r0
000016  4290              CMP      r0,r2
000018  d3f7              BCC      |L17.10|
                  |L17.26|
;;;1377       }
;;;1378       return tmpCnt;
;;;1379   }
00001a  bd30              POP      {r4,r5,pc}
;;;1380   
                          ENDP


                          AREA ||i.IAP_ReadWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadWord PROC
;;;808      */
;;;809    uint32_t IAP_ReadWord ( uint32_t Address )
000000  6800              LDR      r0,[r0,#0]
;;;810    {
;;;811        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;812    
;;;813        uint32_t Data;
;;;814        Data = * ( __IO uint32_t* ) Address;
;;;815        return Data;
;;;816    }
000002  4770              BX       lr
;;;817    
                          ENDP


                          AREA ||i.IAP_ReadWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadWordArray PROC
;;;1338     */
;;;1339   uint16_t IAP_ReadWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;1340   {
000002  4603              MOV      r3,r0
;;;1341       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1342   
;;;1343       uint16_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;1344       if ( ( Address & 0x03 ) == 0 )
000006  079c              LSLS     r4,r3,#30
000008  d106              BNE      |L19.24|
                  |L19.10|
;;;1345       {
;;;1346           do
;;;1347           {
;;;1348               ByteArray[tmpCnt] = * ( __IO uint32_t* ) Address;
00000a  cb10              LDM      r3!,{r4}
00000c  0085              LSLS     r5,r0,#2
00000e  514c              STR      r4,[r1,r5]
;;;1349               Address = Address + 4;
;;;1350   
;;;1351           } while ( ++tmpCnt < ArraySize );
000010  1c40              ADDS     r0,r0,#1
000012  b280              UXTH     r0,r0
000014  4290              CMP      r0,r2
000016  d3f8              BCC      |L19.10|
                  |L19.24|
;;;1352       }
;;;1353       return tmpCnt;
;;;1354   }
000018  bd30              POP      {r4,r5,pc}
;;;1355   
                          ENDP


                          AREA ||i.IAP_SoftwareReset||, CODE, READONLY, ALIGN=2

                  IAP_SoftwareReset PROC
;;;1427     */
;;;1428   void IAP_SoftwareReset ( IAP_BTLD_TypeDef IAP_BTLDType )
000000  21ff              MOVS     r1,#0xff
;;;1429   {
;;;1430       IAP->IAP_CON = ( IAP_BTLDType | IAP_CON_RST );
000002  3101              ADDS     r1,#1
000004  4308              ORRS     r0,r0,r1
000006  4901              LDR      r1,|L20.12|
000008  60c8              STR      r0,[r1,#0xc]
;;;1431   }
00000a  4770              BX       lr
;;;1432   /**
                          ENDP

                  |L20.12|
                          DCD      0x400003c0

                          AREA ||i.IAP_Unlock||, CODE, READONLY, ALIGN=2

                  IAP_Unlock PROC
;;;265      */
;;;266    boolType IAP_Unlock ( void )
000000  b510              PUSH     {r4,lr}
;;;267    {
;;;268    		/* Check if software lock is open (IAP write operations are permitted) */
;;;269    		if(IapWriteFlag==IAP_ENABLE)
000002  4809              LDR      r0,|L21.40|
;;;270    		{
;;;271    #if defined(SC32f10xx)
;;;272    				/* HIRC must be enabled before IAP operation */
;;;273    				RCC_Unlock ( 0xFF );
;;;274    				RCC_HIRCCmd ( ENABLE );
;;;275    #endif
;;;276    				/* Authorize the FLASH Registers access */
;;;277    				IAP->IAPKEY = IAP_KEY1;
000004  4c09              LDR      r4,|L21.44|
000006  6840              LDR      r0,[r0,#4]            ;269  ; IapWriteFlag
000008  2869              CMP      r0,#0x69              ;269
00000a  d105              BNE      |L21.24|
00000c  4808              LDR      r0,|L21.48|
00000e  6020              STR      r0,[r4,#0]
;;;278    				IAP->IAPKEY = IAP_KEY2;
000010  4808              LDR      r0,|L21.52|
000012  6020              STR      r0,[r4,#0]
;;;279    	
;;;280    				InitFlashToRam();
000014  f7fffffe          BL       InitFlashToRam
                  |L21.24|
;;;281    		}
;;;282    		if ( IAP->IAPKEY == 0x01 )
000018  6820              LDR      r0,[r4,#0]
00001a  2801              CMP      r0,#1
00001c  d001              BEQ      |L21.34|
;;;283    				/* Unlock success */
;;;284    				return TRUE;
;;;285    		else
;;;286    				/* Unlock Error */
;;;287    				return FALSE;
00001e  2000              MOVS     r0,#0
;;;288    }
000020  bd10              POP      {r4,pc}
                  |L21.34|
000022  2001              MOVS     r0,#1                 ;284
000024  bd10              POP      {r4,pc}
;;;289    
                          ENDP

000026  0000              DCW      0x0000
                  |L21.40|
                          DCD      ||.data||
                  |L21.44|
                          DCD      0x400003c0
                  |L21.48|
                          DCD      0x12345678
                  |L21.52|
                          DCD      0xa05f05fa

                          AREA ||i.IAP_WriteCmd||, CODE, READONLY, ALIGN=2

                  IAP_WriteCmd PROC
;;;309      */
;;;310    void IAP_WriteCmd ( FunctionalState NewState )
000000  4907              LDR      r1,|L22.32|
;;;311    {
;;;312        /* Check the parameters */
;;;313        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;314    		
;;;315    		/* Enable writing if the IAP software lock is open */
;;;316    		if ( NewState != DISABLE )
;;;317    		{
;;;318    				/* Check if software lock is open (IAP write operations are permitted) */
;;;319    				if(IapWriteFlag==IAP_ENABLE)
;;;320    				{
;;;321    						IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000002  2210              MOVS     r2,#0x10
000004  2800              CMP      r0,#0                 ;316
000006  d007              BEQ      |L22.24|
000008  4806              LDR      r0,|L22.36|
00000a  6840              LDR      r0,[r0,#4]            ;319  ; IapWriteFlag
00000c  2869              CMP      r0,#0x69              ;319
00000e  d102              BNE      |L22.22|
000010  68c8              LDR      r0,[r1,#0xc]
000012  4310              ORRS     r0,r0,r2
000014  60c8              STR      r0,[r1,#0xc]
                  |L22.22|
;;;322    				}
;;;323    		}
;;;324    		else
;;;325    		{
;;;326    				IAP->IAP_CON &= ~ ( uint32_t ) IAP_CON_PRG;
;;;327    		}
;;;328    }
000016  4770              BX       lr
                  |L22.24|
000018  68c8              LDR      r0,[r1,#0xc]          ;326
00001a  4390              BICS     r0,r0,r2              ;326
00001c  60c8              STR      r0,[r1,#0xc]          ;326
00001e  4770              BX       lr
;;;329    
                          ENDP

                  |L22.32|
                          DCD      0x400003c0
                  |L22.36|
                          DCD      ||.data||

                          AREA ||i.InitFlashToRam||, CODE, READONLY, ALIGN=2

                  InitFlashToRam PROC
;;;59      */
;;;60     static void InitFlashToRam(void)
000000  2000              MOVS     r0,#0
;;;61     {
;;;62     		for(uint16_t i=0;i<sizeof(IapProgramInRam);i++)
;;;63     		{
;;;64     				IapProgramInRam[i]    =*(uint8_t*)((uint32_t)IAP_Program_InRam-1+i);
000002  4907              LDR      r1,|L23.32|
000004  4a07              LDR      r2,|L23.36|
                  |L23.6|
000006  180b              ADDS     r3,r1,r0
000008  3b20              SUBS     r3,r3,#0x20
00000a  7fdb              LDRB     r3,[r3,#0x1f]
00000c  5413              STRB     r3,[r2,r0]
00000e  1c40              ADDS     r0,r0,#1              ;62
000010  b280              UXTH     r0,r0                 ;62
000012  28b4              CMP      r0,#0xb4              ;62
000014  d3f7              BCC      |L23.6|
;;;65     		}		
;;;66     		pWriteIapFun=(pInitIapInRam)((uint32_t)IapProgramInRam|0x01);
000016  4803              LDR      r0,|L23.36|
000018  4903              LDR      r1,|L23.40|
00001a  1c40              ADDS     r0,r0,#1
00001c  6008              STR      r0,[r1,#0]  ; pWriteIapFun
;;;67     }
00001e  4770              BX       lr
;;;68     
                          ENDP

                  |L23.32|
                          DCD      IAP_Program_InRam
                  |L23.36|
                          DCD      ||.bss||
                  |L23.40|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  IapProgramInRam
                          %        180

                          AREA ||.data||, DATA, ALIGN=2

                  pWriteIapFun
                          DCD      IAP_NOP
                  IapWriteFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_c6871858____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_iap_c_c6871858____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_c6871858____REVSH|
#line 478
|__asm___15_sc32f1xxx_iap_c_c6871858____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
