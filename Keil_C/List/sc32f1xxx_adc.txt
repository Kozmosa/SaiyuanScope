; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_adc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_adc.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\sc32f1xxx_adc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_adc.c]
                          THUMB

                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;458     */
;;;459    void ADC_ClearFlag ( ADC_TypeDef* ADCx, uint32_t ADC_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;460    {
;;;461        /* Check the parameters */
;;;462        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;463    
;;;464        /* Clear the flags */
;;;465        ADCx->ADC_STS = ( uint32_t ) ADC_FLAG;
;;;466    }
000002  4770              BX       lr
;;;467    
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;141     */
;;;142    void ADC_Cmd ( ADC_TypeDef* ADCx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;143    {
;;;144        /* Check the parameters */
;;;145        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;146        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;147    
;;;148        if ( NewState != DISABLE )
;;;149        {
;;;150            /* Enable the ADC Counter */
;;;151            ADCx->ADC_CON |= ADC_CON_ADCEN;
000002  03d2              LSLS     r2,r2,#15
000004  2900              CMP      r1,#0                 ;148
000006  d003              BEQ      |L2.16|
000008  6801              LDR      r1,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;152        }
;;;153        else
;;;154        {
;;;155            /* Disable the ADC Counter */
;;;156            ADCx->ADC_CON &= ( uint32_t ) ~ADC_CON_ADCEN;
;;;157        }
;;;158    }
00000e  4770              BX       lr
                  |L2.16|
000010  6801              LDR      r1,[r0,#0]            ;156
000012  4391              BICS     r1,r1,r2              ;156
000014  6001              STR      r1,[r0,#0]            ;156
000016  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.ADC_ConvModeConfig||, CODE, READONLY, ALIGN=1

                  ADC_ConvModeConfig PROC
;;;174     */
;;;175    void ADC_ConvModeConfig ( ADC_TypeDef* ADCx, ADC_ConvMode_TypeDef ADC_ConvMode )
000000  2201              MOVS     r2,#1
;;;176    {
;;;177        /* Check the parameters */
;;;178        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;179    
;;;180        if ( ADC_ConvMode != ADC_ConvMode_Single )
;;;181        {
;;;182            /* Enable the ADC Counter */
;;;183            ADCx->ADC_CON |= ADC_CON_CONT;
000002  02d2              LSLS     r2,r2,#11
000004  2900              CMP      r1,#0                 ;180
000006  d003              BEQ      |L3.16|
000008  6801              LDR      r1,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;184        }
;;;185        else
;;;186        {
;;;187            /* Disable the ADC Counter */
;;;188            ADCx->ADC_CON &= ( uint32_t ) ~ADC_CON_CONT;
;;;189        }
;;;190    }
00000e  4770              BX       lr
                  |L3.16|
000010  6801              LDR      r1,[r0,#0]            ;188
000012  4391              BICS     r1,r1,r2              ;188
000014  6001              STR      r1,[r0,#0]            ;188
000016  4770              BX       lr
;;;191    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;476     */
;;;477    void ADC_DMACmd ( ADC_TypeDef* ADCx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;478    {
;;;479    #if defined(SC32f10xx)||defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;480        /* Check the parameters */
;;;481        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;482    
;;;483        if ( NewState != DISABLE )
;;;484        {
;;;485            /* Enable the selected ADC DMA requests */
;;;486            ADCx->ADC_CON |= ( uint32_t ) ADC_CON_DMAEN;
000002  0312              LSLS     r2,r2,#12
000004  2900              CMP      r1,#0                 ;483
000006  d003              BEQ      |L4.16|
000008  6801              LDR      r1,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;487        }
;;;488        else
;;;489        {
;;;490            /* Disable the selected ADC DMA requests */
;;;491            ADCx->ADC_CON &= ( uint32_t ) ~ADC_CON_DMAEN;
;;;492        }
;;;493    #elif defined(SC32f15xx) || defined(SC32R601)
;;;494        /* Check the parameters */
;;;495        assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;496    
;;;497        if(NewState != DISABLE)
;;;498        {
;;;499        /* Enable the selected ADC DMA requests */
;;;500        ADCx->ADC_IDE |= (uint32_t)0x40;
;;;501        }
;;;502        else
;;;503        {
;;;504        /* Disable the selected ADC DMA requests */
;;;505        ADCx->ADC_IDE &= (uint32_t)~0x40;
;;;506        }		
;;;507    #endif
;;;508    }
00000e  4770              BX       lr
                  |L4.16|
000010  6801              LDR      r1,[r0,#0]            ;491
000012  4391              BICS     r1,r1,r2              ;491
000014  6001              STR      r1,[r0,#0]            ;491
000016  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;45      */
;;;46     void ADC_DeInit ( ADC_TypeDef* ADCx )
000000  2100              MOVS     r1,#0
;;;47     {
;;;48     #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)||defined(SC32R803)
;;;49         /* Check the parameters */
;;;50         assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;51     
;;;52         ADCx->ADC_CFG = ( uint32_t ) 0x00000000U;
000002  60c1              STR      r1,[r0,#0xc]
;;;53         ADCx->ADC_CON = ( uint32_t ) 0x00000000U;
000004  6001              STR      r1,[r0,#0]
;;;54         ADCx->ADC_VALUE = ( uint32_t ) 0x00000000U;
000006  6081              STR      r1,[r0,#8]
;;;55         ADCx->ADC_STS = ( uint32_t ) 0x00000001U;
000008  2101              MOVS     r1,#1
00000a  6041              STR      r1,[r0,#4]
;;;56     #elif defined(SC32f15xx) || defined(SC32R601)
;;;57       /* Check the parameters */
;;;58       assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;59     
;;;60       if(ADCx == ADC)
;;;61       	{
;;;62         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
;;;63     	  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
;;;64       	}	
;;;65     #endif
;;;66     }
00000c  4770              BX       lr
;;;67     
                          ENDP


                          AREA ||i.ADC_GetChannel||, CODE, READONLY, ALIGN=1

                  ADC_GetChannel PROC
;;;278     */
;;;279    ADC_ChannelTypedef ADC_GetChannel ( ADC_TypeDef* ADCx )
000000  6800              LDR      r0,[r0,#0]
;;;280    {
;;;281    #if defined(SC32f10xx)||defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;282        /* Check the parameters */
;;;283        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;284    
;;;285        /* Get the ADC channel type */
;;;286        return ( ADC_ChannelTypedef ) ( ADCx->ADC_CON & ADC_CON_ADCIS );
000002  06c0              LSLS     r0,r0,#27
000004  0ec0              LSRS     r0,r0,#27
;;;287    #elif defined(SC32f15xx) || defined(SC32R601)
;;;288      /* Check the parameters */
;;;289      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;290    
;;;291      /* Get the ADC channel type */
;;;292      return (ADC_ChannelTypedef)(ADCx->ADC_CON  & ( ADC_CON_ADCISA));
;;;293    #endif	
;;;294    	
;;;295    }
000006  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;333     */
;;;334    uint16_t ADC_GetConversionValue ( ADC_TypeDef* ADCx )
000000  6880              LDR      r0,[r0,#8]
;;;335    {
;;;336        /* Check the parameters */
;;;337        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;338        /*Returns the result of the latest ADCx conversion */
;;;339        return ( uint16_t ) ADCx->ADC_VALUE;
000002  b280              UXTH     r0,r0
;;;340    }
000004  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;425     */
;;;426    FlagStatus ADC_GetFlagStatus ( ADC_TypeDef* ADCx, uint32_t ADC_FLAG )
000000  4602              MOV      r2,r0
;;;427    {
;;;428        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;429        /* Check the parameters */
;;;430        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;431    
;;;432        if ( ( ADCx->ADC_STS & ADC_FLAG ) != ( uint16_t ) RESET )
000004  6852              LDR      r2,[r2,#4]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;433        {
;;;434            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;435        }
;;;436        else
;;;437        {
;;;438            bitstatus = RESET;
;;;439        }
;;;440        return bitstatus;
;;;441    }
00000c  4770              BX       lr
;;;442    
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;376     */
;;;377    void ADC_ITConfig ( ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;378    {
000002  d003              BEQ      |L9.12|
;;;379        /* Check the parameters */
;;;380        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;381        assert_param ( IS_ADC_IT ( ADC_IT ) );
;;;382        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;383    #if defined(SC32f10xx)||defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;384        if ( NewState != DISABLE )
;;;385        {
;;;386            /* Enable the Interrupt sources */
;;;387            ADCx->ADC_CON |= ADC_IT;
000004  6802              LDR      r2,[r0,#0]
000006  430a              ORRS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;388        }
;;;389        else
;;;390        {
;;;391            /* Disable the Interrupt sources */
;;;392            ADCx->ADC_CON &= ( uint32_t ) ~ADC_IT;
;;;393        }
;;;394    #elif defined(SC32f15xx) || defined(SC32R601)
;;;395        if ( NewState != DISABLE )
;;;396        {
;;;397            /* Enable the Interrupt sources */
;;;398            ADCx->ADC_IDE |= ADC_IT;
;;;399        }
;;;400        else
;;;401        {
;;;402            /* Disable the Interrupt sources */
;;;403            ADCx->ADC_IDE &= ( uint32_t ) ~ADC_IT;
;;;404        }	
;;;405    #endif
;;;406    }
00000a  4770              BX       lr
                  |L9.12|
00000c  6802              LDR      r2,[r0,#0]            ;392
00000e  438a              BICS     r2,r2,r1              ;392
000010  6002              STR      r2,[r0,#0]            ;392
000012  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;75      */
;;;76     void ADC_Init ( ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;77     {
;;;78     #if defined(SC32f10xx)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)||defined(SC32R803)
;;;79         uint32_t tmpreg;
;;;80         /* Check the parameters */
;;;81         assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;82         assert_param ( IS_ADC_CONVMODE ( ADC_InitStruct->ADC_ConvMode ) );
;;;83         assert_param ( IS_ADC_PRESCALER ( ADC_InitStruct->ADC_Prescaler ) );
;;;84         assert_param ( IS_ADC_VREF ( ADC_InitStruct->ADC_VREF ) );
;;;85         assert_param ( IS_ADC_EAIN ( ADC_InitStruct->ADC_EAIN ) );
;;;86     
;;;87         tmpreg = ADCx->ADC_CON;
000002  6802              LDR      r2,[r0,#0]
;;;88         tmpreg &= ~ ( ADC_CON_ADCIS | ADC_CON_CONT | ADC_CON_LOWSP | ADC_CON_VREFS );
000004  4b05              LDR      r3,|L10.28|
000006  401a              ANDS     r2,r2,r3
;;;89         tmpreg |= ( ADC_InitStruct->ADC_Prescaler | ADC_InitStruct->ADC_VREF |
000008  688c              LDR      r4,[r1,#8]
00000a  680b              LDR      r3,[r1,#0]
00000c  4323              ORRS     r3,r3,r4
00000e  898c              LDRH     r4,[r1,#0xc]
000010  4314              ORRS     r4,r4,r2
000012  4323              ORRS     r3,r3,r4
;;;90                     ADC_InitStruct->ADC_ConvMode );
;;;91         ADCx->ADC_CON = tmpreg;
000014  6003              STR      r3,[r0,#0]
;;;92         ADCx->ADC_CFG = ADC_InitStruct->ADC_EAIN;
000016  6849              LDR      r1,[r1,#4]
000018  60c1              STR      r1,[r0,#0xc]
;;;93     #elif defined(SC32f15xx)||defined(SC32R601)
;;;94       uint32_t tmpreg;
;;;95       /* Check the parameters */
;;;96       assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;97       assert_param(IS_ADC_CONVMODE(ADC_InitStruct->ADC_ConvMode));
;;;98       assert_param(IS_ADC_PRESCALER(ADC_InitStruct->ADC_Prescaler));
;;;99       assert_param(IS_ADC_EAIN(ADC_InitStruct->ADC_EAIN));
;;;100      assert_param(IS_ADC_VREF(ADC_InitStruct->ADC_VREF));
;;;101      
;;;102      tmpreg = ADCx->ADC_CON;
;;;103      tmpreg &= ~( ADC_CON_CONT | ADC_CON_LOWSP | ADC_CON_REFSEL );
;;;104      tmpreg |= ( ADC_InitStruct->ADC_Prescaler |
;;;105      	          ADC_InitStruct->ADC_VREF | ADC_InitStruct->ADC_ConvMode);
;;;106      ADCx->ADC_CON = tmpreg;
;;;107      
;;;108      ADCx->ADC_CFG = ADC_InitStruct->ADC_EAIN;
;;;109    #endif
;;;110    }
00001a  bd10              POP      {r4,pc}
;;;111    
                          ENDP

                  |L10.28|
                          DCD      0xffc8f7e0

                          AREA ||i.ADC_SetChannel||, CODE, READONLY, ALIGN=1

                  ADC_SetChannel PROC
;;;224     */
;;;225    void ADC_SetChannel ( ADC_TypeDef* ADCx, ADC_ChannelTypedef ADC_Channel )
000000  6802              LDR      r2,[r0,#0]
;;;226    {
;;;227    #if defined(SC32f10xx)||defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;228        uint32_t tmpreg;
;;;229        /* Check the parameters */
;;;230        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;231    
;;;232        tmpreg = ADCx->ADC_CON;
;;;233        tmpreg &= ( uint32_t ) ~ ( ADC_CON_ADCIS );
000002  0952              LSRS     r2,r2,#5
000004  0152              LSLS     r2,r2,#5
;;;234    
;;;235        /* Set the ADC channel type */
;;;236        tmpreg |= ADC_Channel;
000006  430a              ORRS     r2,r2,r1
;;;237    
;;;238        ADCx->ADC_CON = tmpreg;
000008  6002              STR      r2,[r0,#0]
;;;239    #elif defined(SC32f15xx) || defined(SC32R601)
;;;240        /* Check the parameters */
;;;241        assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;242        ADCx->ADC_CON &=(uint32_t) ~(ADC_CON_ADCISA);
;;;243        ADCx->ADC_CON  |= ADC_Channel<<16;
;;;244    #endif
;;;245    }
00000a  4770              BX       lr
;;;246    
                          ENDP


                          AREA ||i.ADC_SoftwareStartConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConv PROC
;;;318     */
;;;319    void ADC_SoftwareStartConv ( ADC_TypeDef* ADCx )
000000  6801              LDR      r1,[r0,#0]
;;;320    {
;;;321        /* Check the parameters */
;;;322        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;323    
;;;324        /* Set the ADCS Bit */
;;;325        ADCx->ADC_CON |= ADC_CON_ADCS;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;326    }
000008  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;117      */
;;;118    void ADC_StructInit ( ADC_InitTypeDef* ADC_InitStruct )
000000  2100              MOVS     r1,#0
;;;119    {
;;;120        /* Set the default configuration */
;;;121        ADC_InitStruct->ADC_ConvMode = ADC_ConvMode_Single;
000002  8181              STRH     r1,[r0,#0xc]
;;;122        ADC_InitStruct->ADC_EAIN = ADC_EAIN_Less;
000004  6041              STR      r1,[r0,#4]
;;;123        ADC_InitStruct->ADC_Prescaler = ADC_Prescaler_3CLOCK;
000006  2201              MOVS     r2,#1
000008  0492              LSLS     r2,r2,#18
00000a  6002              STR      r2,[r0,#0]
;;;124    #if !(defined(SC32f15xx) || defined(SC32R601))
;;;125        ADC_InitStruct->ADC_VREF = ADC_VREF_VDD;
00000c  6081              STR      r1,[r0,#8]
;;;126    #else
;;;127    	ADC_InitStruct->ADC_VREF      = ADC_RefSource_VDD;
;;;128    #endif
;;;129    	
;;;130    
;;;131    }
00000e  4770              BX       lr
;;;132    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_adc_c_e11a2ea2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_adc_c_e11a2ea2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_adc_c_e11a2ea2____REVSH|
#line 478
|__asm___15_sc32f1xxx_adc_c_e11a2ea2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
