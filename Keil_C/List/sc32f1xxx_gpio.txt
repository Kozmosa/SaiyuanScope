; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_gpio.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_gpio.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_gpio.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_gpio.c]
                          THUMB

                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=1

                  GPIO_DeInit PROC
;;;54      */
;;;55     void GPIO_DeInit ( GPIO_TypeDef* GPIOx )
000000  6a01              LDR      r1,[r0,#0x20]
;;;56     {
;;;57         /* Check the parameters */
;;;58         assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;59     
;;;60         /* Deinitializes the GPIOx PXCON register to their default reset values. */
;;;61         GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_PIN_All );
000002  0c09              LSRS     r1,r1,#16
000004  0409              LSLS     r1,r1,#16
000006  6201              STR      r1,[r0,#0x20]
;;;62         /* Deinitializes the GPIOx PXPH register to their default reset values. */
;;;63         GPIOx->PXPH &= ( uint32_t ) ( ~GPIO_PIN_All );
000008  6c01              LDR      r1,[r0,#0x40]
00000a  0c09              LSRS     r1,r1,#16
00000c  0409              LSLS     r1,r1,#16
00000e  6401              STR      r1,[r0,#0x40]
;;;64         /* Deinitializes the GPIOx PIN register to their default reset values. */
;;;65         GPIOx->PIN &= ( uint32_t ) ( ~GPIO_PIN_All );
000010  6801              LDR      r1,[r0,#0]
000012  0c09              LSRS     r1,r1,#16
000014  0409              LSLS     r1,r1,#16
000016  6001              STR      r1,[r0,#0]
;;;66         /* Deinitializes the GPIOx PXLEV register to their default reset values. */
;;;67         GPIOx->PXLEV &= ( uint32_t ) 0x00000000;
000018  6e01              LDR      r1,[r0,#0x60]
00001a  2100              MOVS     r1,#0
00001c  6601              STR      r1,[r0,#0x60]
;;;68     }
00001e  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;83      */
;;;84     void GPIO_Init ( GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct )
000000  b5f0              PUSH     {r4-r7,lr}
;;;85     {
;;;86         uint32_t tmppin, tmppos, tmpreg;
;;;87     
;;;88         /* Check the parameters */
;;;89         assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;90         assert_param ( IS_GPIO_PIN ( GPIO_InitStruct->GPIO_Pin ) );
;;;91         assert_param ( IS_GPIO_MODE ( GPIO_InitStruct->GPIO_Mode ) );
;;;92     
;;;93         if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT_PP )
000002  884b              LDRH     r3,[r1,#2]
;;;94         {
;;;95             /* Configure Pins to High-resistance output mode */
;;;96             GPIOx->PXCON |= ( uint32_t ) GPIO_InitStruct->GPIO_Pin;
000004  880a              LDRH     r2,[r1,#0]
000006  2b02              CMP      r3,#2                 ;93
000008  d004              BEQ      |L2.20|
;;;97         }
;;;98         else if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IN_PU )
00000a  2b01              CMP      r3,#1
00000c  d006              BEQ      |L2.28|
;;;99         {
;;;100            /* Configure Pins to Pull-up input mode */
;;;101            GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
;;;102            GPIOx->PXPH |= ( uint32_t ) GPIO_InitStruct->GPIO_Pin;
;;;103        }
;;;104        else if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IN_HI )
00000e  2b00              CMP      r3,#0
000010  d00c              BEQ      |L2.44|
000012  e012              B        |L2.58|
                  |L2.20|
000014  6a03              LDR      r3,[r0,#0x20]         ;96
000016  4313              ORRS     r3,r3,r2              ;96
000018  6203              STR      r3,[r0,#0x20]         ;96
00001a  e00e              B        |L2.58|
                  |L2.28|
00001c  6a03              LDR      r3,[r0,#0x20]         ;101
00001e  4393              BICS     r3,r3,r2              ;101
000020  6203              STR      r3,[r0,#0x20]         ;101
000022  6c02              LDR      r2,[r0,#0x40]         ;102
000024  880b              LDRH     r3,[r1,#0]            ;102
000026  431a              ORRS     r2,r2,r3              ;102
000028  6402              STR      r2,[r0,#0x40]         ;102
00002a  e006              B        |L2.58|
                  |L2.44|
;;;105        {
;;;106            /* Configure Pin to High-resistance intput mode */
;;;107            GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  4393              BICS     r3,r3,r2
000030  6203              STR      r3,[r0,#0x20]
;;;108            GPIOx->PXPH &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
000032  6c02              LDR      r2,[r0,#0x40]
000034  880b              LDRH     r3,[r1,#0]
000036  439a              BICS     r2,r2,r3
000038  6402              STR      r2,[r0,#0x40]
                  |L2.58|
;;;109        }
;;;110    
;;;111        /* Get GPIOx PXLEV value */
;;;112        tmpreg = GPIOx->PXLEV;
00003a  6e03              LDR      r3,[r0,#0x60]
;;;113        /* Query the Pins that needs to be manipulated */
;;;114        for ( tmppos = 0; tmppos < 16; tmppos++ )
00003c  2200              MOVS     r2,#0
00003e  880e              LDRH     r6,[r1,#0]            ;96
;;;115        {
;;;116            tmppin = ( uint32_t ) ( 0x01 << tmppos );
;;;117            if ( ( tmppin & GPIO_InitStruct->GPIO_Pin ) != RESET )
;;;118            {
;;;119                /* Clear the LEVx bits */
;;;120                tmpreg &= ( uint32_t ) ~ ( GPIO_DriveLevel_3 << ( tmppos * 2 ) );
000040  2703              MOVS     r7,#3
                  |L2.66|
000042  2401              MOVS     r4,#1                 ;116
000044  4094              LSLS     r4,r4,r2              ;116
000046  4226              TST      r6,r4                 ;117
000048  d006              BEQ      |L2.88|
00004a  0054              LSLS     r4,r2,#1
00004c  463d              MOV      r5,r7
00004e  40a5              LSLS     r5,r5,r4
000050  43ab              BICS     r3,r3,r5
;;;121                /* Set LEVx bits according to Drive Level value */
;;;122                tmpreg |= ( uint32_t ) ( GPIO_InitStruct->GPIO_DriveLevel << ( tmppos * 2 ) );
000052  888d              LDRH     r5,[r1,#4]
000054  40a5              LSLS     r5,r5,r4
000056  432b              ORRS     r3,r3,r5
                  |L2.88|
000058  1c52              ADDS     r2,r2,#1              ;114
00005a  2a10              CMP      r2,#0x10              ;114
00005c  d3f1              BCC      |L2.66|
;;;123            }
;;;124        }
;;;125        /* Store GPIOx PXLEV the new value */
;;;126        GPIOx->PXLEV = tmpreg;
00005e  6603              STR      r3,[r0,#0x60]
;;;127    }
000060  bdf0              POP      {r4-r7,pc}
;;;128    
                          ENDP


                          AREA ||i.GPIO_ReadData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadData PROC
;;;237     */
;;;238    uint16_t GPIO_ReadData ( GPIO_TypeDef* GPIOx )
000000  6800              LDR      r0,[r0,#0]
;;;239    {
;;;240        /* Check the parameters */
;;;241        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;242    
;;;243        return ( uint16_t ) ( GPIOx->PIN );
000002  b280              UXTH     r0,r0
;;;244    }
000004  4770              BX       lr
;;;245    
                          ENDP


                          AREA ||i.GPIO_ReadDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadDataBit PROC
;;;280     */
;;;281    BitAction GPIO_ReadDataBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  6800              LDR      r0,[r0,#0]
;;;282    {
;;;283        BitAction bitstatus;
;;;284        /* Check the parameters */
;;;285        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;286        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;287    
;;;288        if ( GPIOx->PIN & GPIO_Pin )
000002  4208              TST      r0,r1
000004  d001              BEQ      |L4.10|
;;;289        {
;;;290            bitstatus = Bit_SET;
000006  2001              MOVS     r0,#1
;;;291        }
;;;292        else
;;;293        {
;;;294            bitstatus = Bit_RESET;
;;;295        }
;;;296    
;;;297        return bitstatus;
;;;298    }
000008  4770              BX       lr
                  |L4.10|
00000a  2000              MOVS     r0,#0                 ;294
00000c  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;382     */
;;;383    void GPIO_ResetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  b508              PUSH     {r3,lr}
;;;384    {
;;;385        /* Check the parameters */
;;;386        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;387        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;388    
;;;389        __IO uint32_t tmpreg = ( uint32_t ) GPIOx;
000002  9000              STR      r0,[sp,#0]
;;;390    
;;;391        while ( GPIO_Pin != 0 )
000004  2000              MOVS     r0,#0
000006  e007              B        |L5.24|
                  |L5.8|
;;;392        {
;;;393            if ( GPIO_Pin & 0x0001 )
000008  07ca              LSLS     r2,r1,#31
00000a  d001              BEQ      |L5.16|
;;;394            {
;;;395                ( * ( ( uint8_t* ) ( tmpreg ) ) ) = 0;
00000c  9a00              LDR      r2,[sp,#0]
00000e  7010              STRB     r0,[r2,#0]
                  |L5.16|
;;;396            }
;;;397            GPIO_Pin = GPIO_Pin >> 1;
000010  0849              LSRS     r1,r1,#1
;;;398            tmpreg++;
000012  9a00              LDR      r2,[sp,#0]
000014  1c52              ADDS     r2,r2,#1
000016  9200              STR      r2,[sp,#0]
                  |L5.24|
000018  2900              CMP      r1,#0                 ;391
00001a  d1f5              BNE      |L5.8|
;;;399        }
;;;400    }
00001c  bd08              POP      {r3,pc}
;;;401    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;332     */
;;;333    void GPIO_SetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  b508              PUSH     {r3,lr}
;;;334    {
;;;335        /* Check the parameters */
;;;336        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;337        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;338        __IO uint32_t tmpreg = ( uint32_t ) GPIOx;
000002  9000              STR      r0,[sp,#0]
;;;339        while ( GPIO_Pin != 0 )
;;;340        {
;;;341            if ( GPIO_Pin & 0x0001 )
;;;342            {
;;;343                ( * ( ( uint8_t* ) ( tmpreg ) ) ) = 1;
000004  2001              MOVS     r0,#1
000006  e007              B        |L6.24|
                  |L6.8|
000008  07ca              LSLS     r2,r1,#31             ;341
00000a  d001              BEQ      |L6.16|
00000c  9a00              LDR      r2,[sp,#0]
00000e  7010              STRB     r0,[r2,#0]
                  |L6.16|
;;;344            }
;;;345            GPIO_Pin = GPIO_Pin >> 1;
000010  0849              LSRS     r1,r1,#1
;;;346            tmpreg++;
000012  9a00              LDR      r2,[sp,#0]
000014  1c52              ADDS     r2,r2,#1
000016  9200              STR      r2,[sp,#0]
                  |L6.24|
000018  2900              CMP      r1,#0                 ;339
00001a  d1f5              BNE      |L6.8|
;;;347        }
;;;348    }
00001c  bd08              POP      {r3,pc}
;;;349    
                          ENDP


                          AREA ||i.GPIO_SetDriveLevel||, CODE, READONLY, ALIGN=1

                  GPIO_SetDriveLevel PROC
;;;166     */
;;;167    void GPIO_SetDriveLevel ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_DriveLevel_TypeDef GPIO_DriveLevel )
000000  b5f0              PUSH     {r4-r7,lr}
;;;168    {
;;;169        uint32_t tmppin, tmppos, tmpreg;
;;;170        /* Get GPIOx PXLEV value */
;;;171        tmpreg = GPIOx->PXLEV;
000002  6e04              LDR      r4,[r0,#0x60]
;;;172        /* Query the Pins that needs to be manipulated */
;;;173        for ( tmppos = 0; tmppos < 16; tmppos++ )
000004  2300              MOVS     r3,#0
;;;174        {
;;;175            tmppin = ( uint32_t ) ( 0x01 << tmppos );
000006  2701              MOVS     r7,#1
                  |L7.8|
000008  463d              MOV      r5,r7
00000a  409d              LSLS     r5,r5,r3
;;;176            if ( ( tmppin & GPIO_Pin ) != RESET )
00000c  420d              TST      r5,r1
00000e  d006              BEQ      |L7.30|
;;;177            {
;;;178                /* Clear the LEVx bits */
;;;179                tmpreg &= ( uint32_t ) ~ ( GPIO_DriveLevel_3 << ( tmppos * 2 ) );
000010  005d              LSLS     r5,r3,#1
000012  2603              MOVS     r6,#3
000014  40ae              LSLS     r6,r6,r5
000016  43b4              BICS     r4,r4,r6
;;;180                /* Set LEVx bits according to Drive Level value */
;;;181                tmpreg |= ( uint32_t ) ( GPIO_DriveLevel << ( tmppos * 2 ) );
000018  4616              MOV      r6,r2
00001a  40ae              LSLS     r6,r6,r5
00001c  4334              ORRS     r4,r4,r6
                  |L7.30|
00001e  1c5b              ADDS     r3,r3,#1              ;173
000020  2b10              CMP      r3,#0x10              ;173
000022  d3f1              BCC      |L7.8|
;;;182            }
;;;183        }
;;;184        /* Store GPIOx PXLEV the new value */
;;;185        GPIOx->PXLEV = tmpreg;
000024  6604              STR      r4,[r0,#0x60]
;;;186    
;;;187    }
000026  bdf0              POP      {r4-r7,pc}
;;;188    
                          ENDP


                          AREA ||i.GPIO_TogglePins||, CODE, READONLY, ALIGN=2

                  GPIO_TogglePins PROC
;;;512     */
;;;513    void GPIO_TogglePins ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
000000  b538              PUSH     {r3-r5,lr}
;;;514    {   GPIO_TogglePins(GPIOB , GPIO_Pin_5); 
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  2120              MOVS     r1,#0x20
000008  4809              LDR      r0,|L8.48|
00000a  f7fffffe          BL       GPIO_TogglePins
;;;515        /* Check the parameters */
;;;516        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;517        assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
;;;518        __IO uint32_t tmpreg = ( uint32_t ) GPIOx + ( 0x00000010UL );
00000e  3510              ADDS     r5,r5,#0x10
000010  9500              STR      r5,[sp,#0]
;;;519        uint32_t temp = 0;
;;;520        /* Set the GPIOx PIN value  */
;;;521        while ( GPIO_Pin != 0 )
000012  e00a              B        |L8.42|
                  |L8.20|
;;;522        {
;;;523    
;;;524            if ( GPIO_Pin & 0x0001 )
000014  07e0              LSLS     r0,r4,#31
000016  d004              BEQ      |L8.34|
;;;525            {
;;;526                temp = ~ ( * ( ( uint8_t* ) ( tmpreg ) ) );
000018  9800              LDR      r0,[sp,#0]
00001a  7800              LDRB     r0,[r0,#0]
00001c  43c0              MVNS     r0,r0
;;;527                ( * ( ( uint8_t* ) ( tmpreg ) ) ) = temp;
00001e  9900              LDR      r1,[sp,#0]
000020  7008              STRB     r0,[r1,#0]
                  |L8.34|
;;;528            }
;;;529            GPIO_Pin = GPIO_Pin >> 1;
000022  0864              LSRS     r4,r4,#1
;;;530            tmpreg++;
000024  9800              LDR      r0,[sp,#0]
000026  1c40              ADDS     r0,r0,#1
000028  9000              STR      r0,[sp,#0]
                  |L8.42|
00002a  2c00              CMP      r4,#0                 ;521
00002c  d1f2              BNE      |L8.20|
;;;531        }
;;;532    }
00002e  bd38              POP      {r3-r5,pc}
;;;533    
                          ENDP

                  |L8.48|
                          DCD      0x40011100

                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;416     */
;;;417    void GPIO_Write ( GPIO_TypeDef* GPIOx, uint16_t PortVal )
000000  6001              STR      r1,[r0,#0]
;;;418    {
;;;419        /* Check the parameters */
;;;420        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;421    
;;;422        /*  */
;;;423        GPIOx->PIN = PortVal;
;;;424    }
000002  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;462      */
;;;463    void GPIO_WriteBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal )
000000  2a00              CMP      r2,#0
;;;464    {
000002  d003              BEQ      |L10.12|
;;;465        /* Check the parameters */
;;;466        assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
;;;467        assert_param ( IS_GET_GPIO_PIN ( GPIO_Pin ) );
;;;468        assert_param ( IS_GPIO_BITACTION ( BitVal ) );
;;;469    
;;;470        if ( BitVal != Bit_RESET )
;;;471        {
;;;472            GPIOx->PIN |= GPIO_Pin;
000004  6802              LDR      r2,[r0,#0]
000006  430a              ORRS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;473        }
;;;474        else
;;;475        {
;;;476            GPIOx->PIN &= ( ~GPIO_Pin ) ;
;;;477        }
;;;478    }
00000a  4770              BX       lr
                  |L10.12|
00000c  6802              LDR      r2,[r0,#0]            ;476
00000e  438a              BICS     r2,r2,r1              ;476
000010  6002              STR      r2,[r0,#0]            ;476
000012  4770              BX       lr
;;;479    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REVSH|
#line 478
|__asm___16_sc32f1xxx_gpio_c_f8e8e39a____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
