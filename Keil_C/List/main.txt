; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\main.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.Debug_Show_8_Channels||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_f
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_fp_dec
                  Debug_Show_8_Channels PROC
;;;75     // =========================================================
;;;76     void Debug_Show_8_Channels(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;77     {
000002  b08f              SUB      sp,sp,#0x3c
;;;78         char buf[50];
;;;79         uint16_t y_pos = 10; // 起始Y坐标
000004  210a              MOVS     r1,#0xa
;;;80         
;;;81         // 1. 显示标题
;;;82         LCD_ShowString(10, y_pos, "ADC 8-CH RAW DEBUG", RED, BLACK, 16);
000006  2710              MOVS     r7,#0x10
000008  2600              MOVS     r6,#0
00000a  4b17              LDR      r3,|L1.104|
00000c  a217              ADR      r2,|L1.108|
00000e  200a              MOVS     r0,#0xa
000010  9701              STR      r7,[sp,#4]
000012  9600              STR      r6,[sp,#0]
000014  f7fffffe          BL       LCD_ShowString
;;;83         y_pos += 24; // 标题高度
000018  2522              MOVS     r5,#0x22
;;;84     
;;;85         // 2. 循环显示 8 个通道
;;;86         for(int i = 0; i < 8; i++)
00001a  2400              MOVS     r4,#0
                  |L1.28|
;;;87         {
;;;88             uint16_t raw = AD.v[i]; // 获取原始值 (0~16383)
00001c  4818              LDR      r0,|L1.128|
00001e  0061              LSLS     r1,r4,#1
000020  5a46              LDRH     r6,[r0,r1]
;;;89             // 换算电压: Raw * 3.3 / 16383
;;;90             float volt = (float)raw * 3.3f / 16383.0f; 
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       __aeabi_ui2f
000028  4916              LDR      r1,|L1.132|
00002a  f7fffffe          BL       __aeabi_fmul
00002e  4916              LDR      r1,|L1.136|
000030  f7fffffe          BL       __aeabi_fdiv
;;;91             
;;;92             // 格式化字符串: "CH0: 16383 = 3.300V"
;;;93             sprintf(buf, "CH%d: %5d = %.3fV", i, raw, volt);
000034  f7fffffe          BL       __aeabi_f2d
000038  9101              STR      r1,[sp,#4]
00003a  9000              STR      r0,[sp,#0]
00003c  4633              MOV      r3,r6
00003e  4622              MOV      r2,r4
000040  a112              ADR      r1,|L1.140|
000042  a802              ADD      r0,sp,#8
000044  f7fffffe          BL       __2sprintf
;;;94             
;;;95             // 显示一行
;;;96             LCD_ShowString(10, y_pos, buf, WHITE, BLACK, 16);
000048  2000              MOVS     r0,#0
00004a  9000              STR      r0,[sp,#0]
00004c  4b14              LDR      r3,|L1.160|
00004e  aa02              ADD      r2,sp,#8
000050  4629              MOV      r1,r5
000052  9701              STR      r7,[sp,#4]
000054  200a              MOVS     r0,#0xa
000056  f7fffffe          BL       LCD_ShowString
;;;97             y_pos += 20; // 行间距
00005a  3514              ADDS     r5,r5,#0x14
00005c  b2ad              UXTH     r5,r5
00005e  1c64              ADDS     r4,r4,#1              ;86
000060  2c08              CMP      r4,#8                 ;86
000062  dbdb              BLT      |L1.28|
;;;98         }
;;;99     }
000064  b00f              ADD      sp,sp,#0x3c
000066  bdf0              POP      {r4-r7,pc}
;;;100    
                          ENDP

                  |L1.104|
                          DCD      0x0000f882
                  |L1.108|
00006c  41444320          DCB      "ADC 8-CH RAW DEBUG",0
000070  382d4348
000074  20524157
000078  20444542
00007c  554700  
00007f  00                DCB      0
                  |L1.128|
                          DCD      Acq_Data
                  |L1.132|
                          DCD      0x40533333
                  |L1.136|
                          DCD      0x467ffc00
                  |L1.140|
00008c  43482564          DCB      "CH%d: %5d = %.3fV",0
000090  3a202535
000094  64203d20
000098  252e3366
00009c  5600    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L1.160|
                          DCD      0x0000ffff

                          AREA ||i.UART3_Send_Packet||, CODE, READONLY, ALIGN=2

                  UART3_Send_Packet PROC
;;;178    
;;;179    void UART3_Send_Packet()//wifi串口发送数据包
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;182    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;183    	 UART3_TxPacket[0]=0x01;
000002  480d              LDR      r0,|L2.56|
000004  2101              MOVS     r1,#1
000006  7001              STRB     r1,[r0,#0]
;;;184    	UART3_TxPacket[1]=0xA2;
000008  21a2              MOVS     r1,#0xa2
00000a  7041              STRB     r1,[r0,#1]
;;;185    	UART3_TxPacket[2]=0x12;
00000c  2112              MOVS     r1,#0x12
00000e  7081              STRB     r1,[r0,#2]
;;;186    	UART3_TxPacket[3]=0x23;
000010  2123              MOVS     r1,#0x23
000012  70c1              STRB     r1,[r0,#3]
;;;187    	UART3_TxPacket[4]=0x34;
000014  2134              MOVS     r1,#0x34
000016  7101              STRB     r1,[r0,#4]
;;;188    	UART3_TxPacket[5]=0x45;
000018  2145              MOVS     r1,#0x45
00001a  7141              STRB     r1,[r0,#5]
;;;189    	UART3_TxPacket[6]=0x56;
00001c  2156              MOVS     r1,#0x56
00001e  7181              STRB     r1,[r0,#6]
;;;190    	UART3_TxPacket[7]=0x65;
000020  2165              MOVS     r1,#0x65
000022  71c1              STRB     r1,[r0,#7]
;;;191    	UART3_TxPacket[8]=0x54;
000024  2154              MOVS     r1,#0x54
000026  7201              STRB     r1,[r0,#8]
;;;192    	UART3_TxPacket[9]=0x43;
000028  2143              MOVS     r1,#0x43
00002a  7241              STRB     r1,[r0,#9]
;;;193    	UART_SendArray(UART3,UART3_TxPacket, 10);					
00002c  4601              MOV      r1,r0
00002e  220a              MOVS     r2,#0xa
000030  4802              LDR      r0,|L2.60|
000032  f7fffffe          BL       UART_SendArray
;;;194    }
000036  bd10              POP      {r4,pc}
;;;195    
                          ENDP

                  |L2.56|
                          DCD      UART3_TxPacket
                  |L2.60|
                          DCD      0x40022020

                          AREA ||i.UART3_Send_String||, CODE, READONLY, ALIGN=2

                  UART3_Send_String PROC
;;;195    
;;;196    void UART3_Send_String()//wifi串口发送文本
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198    	UART_SendString(UART3,"uni_wro");
000002  a102              ADR      r1,|L3.12|
000004  4803              LDR      r0,|L3.20|
000006  f7fffffe          BL       UART_SendString
;;;199    }
00000a  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  |L3.12|
00000c  756e695f          DCB      "uni_wro",0
000010  77726f00
                  |L3.20|
                          DCD      0x40022020

                          AREA ||i.UART3_receive_Packet||, CODE, READONLY, ALIGN=2

                  UART3_receive_Packet PROC
;;;200    
;;;201    void UART3_receive_Packet()//wifi串口接受数据(数据包格式FF xx xx xx xx FE)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;204    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;205    	if (UART_GetFlagStatus(UART3, UART_Flag_RX) == SET)	//判断是否是USART3的接收事件触发的中断
000002  4c15              LDR      r4,|L4.88|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d111              BNE      |L4.52|
;;;206    	{
;;;207    		
;;;208    		uint8_t RxData = UART_ReceiveData(UART3);			//读取数据寄存器，存放在接收的数据变量
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ReceiveData
000016  b2c0              UXTB     r0,r0
;;;209    
;;;210    		/*使用状态机的思路，依次处理数据包的不同部分*/
;;;211    
;;;212    		/*当前状态为0，接收数据包包头*/
;;;213    				if (RxState == 0)
000018  4a10              LDR      r2,|L4.92|
00001a  2400              MOVS     r4,#0
00001c  7851              LDRB     r1,[r2,#1]  ; RxState
00001e  2301              MOVS     r3,#1                 ;205
000020  2900              CMP      r1,#0
000022  d008              BEQ      |L4.54|
;;;214    		{
;;;215    			if (RxData == 0xFF)			//如果数据确实是包头
;;;216    			{
;;;217    				RxState = 1;			//置下一个状态
;;;218    				pRxPacket = 0;			//数据包的位置归零
;;;219    			}
;;;220    		}
;;;221    		/*当前状态为1，接收数据包数据*/
;;;222    		else if (RxState == 1)
000024  2901              CMP      r1,#1
000026  d00b              BEQ      |L4.64|
;;;223    		{
;;;224    			UART3_RxPacket[pRxPacket] = RxData;	//将数据存入数据包数组的指定位置
;;;225    			pRxPacket ++;				//数据包的位置自增
;;;226    			if (pRxPacket >=4)			//如果收够4个数据
;;;227    			{
;;;228    				RxState = 2;			//置下一个状态
;;;229    			}
;;;230    		}
;;;231    		/*当前状态为2，接收数据包包尾*/
;;;232    		else if (RxState == 2)
000028  2902              CMP      r1,#2
00002a  d103              BNE      |L4.52|
;;;233    		{
;;;234    			if (RxData == 0xFE)			//如果数据确实是包尾部
00002c  28fe              CMP      r0,#0xfe
00002e  d101              BNE      |L4.52|
;;;235    			{
;;;236    				RxState = 0;			//状态归0
000030  7054              STRB     r4,[r2,#1]
;;;237    				UART3_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
000032  7013              STRB     r3,[r2,#0]
                  |L4.52|
;;;238    			}
;;;239    		}
;;;240    
;;;241    
;;;242    	}
;;;243    }
000034  bd10              POP      {r4,pc}
                  |L4.54|
000036  28ff              CMP      r0,#0xff              ;215
000038  d1fc              BNE      |L4.52|
00003a  7053              STRB     r3,[r2,#1]            ;217
00003c  7094              STRB     r4,[r2,#2]            ;218
                  |L4.62|
00003e  bd10              POP      {r4,pc}
                  |L4.64|
000040  4b07              LDR      r3,|L4.96|
000042  7891              LDRB     r1,[r2,#2]            ;224  ; pRxPacket
000044  5458              STRB     r0,[r3,r1]            ;224
000046  1c49              ADDS     r1,r1,#1              ;225
000048  b2c8              UXTB     r0,r1                 ;225
00004a  7090              STRB     r0,[r2,#2]            ;225
00004c  2804              CMP      r0,#4                 ;226
00004e  d3f6              BCC      |L4.62|
000050  2002              MOVS     r0,#2                 ;228
000052  7050              STRB     r0,[r2,#1]            ;228
000054  bd10              POP      {r4,pc}
;;;244    void UART3_receive_String()
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40022020
                  |L4.92|
                          DCD      ||.data||
                  |L4.96|
                          DCD      ||.bss||

                          AREA ||i.UART3_receive_String||, CODE, READONLY, ALIGN=2

                  UART3_receive_String PROC
;;;243    }
;;;244    void UART3_receive_String()
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
;;;246    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;247    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;248    	if (UART_GetFlagStatus(UART3, UART_Flag_RX) == SET)	//判断是否是USART1的接收事件触发的中断
000002  4c19              LDR      r4,|L5.104|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d114              BNE      |L5.58|
;;;249    	{
;;;250    		uint8_t RxData = UART_ReceiveData(UART3);			//读取数据寄存器，存放在接收的数据变量
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ReceiveData
000016  b2c1              UXTB     r1,r0
;;;251    
;;;252    		/*使用状态机的思路，依次处理数据包的不同部分*/
;;;253    
;;;254    		/*当前状态为0，接收数据包包头*/
;;;255    		if (RxState == 0)
000018  4c14              LDR      r4,|L5.108|
00001a  2200              MOVS     r2,#0
00001c  78e0              LDRB     r0,[r4,#3]  ; RxState
00001e  2501              MOVS     r5,#1                 ;248
;;;256    		{
;;;257    			 RxState=1;
;;;258                for(uint8_t i=0;i<100;i++)
;;;259                {
;;;260                    UART3_RxString[i]=' ';
000020  4b13              LDR      r3,|L5.112|
000022  2800              CMP      r0,#0                 ;255
000024  d00a              BEQ      |L5.60|
;;;261                }
;;;262                pRxPacket=0;
;;;263                UART3_RxString[pRxPacket]=RxData;
;;;264                pRxPacket++;
;;;265    		}
;;;266    		/*当前状态为1，接收数据包数据，同时判断是否接收到了第一个包尾*/
;;;267    		else if (RxState == 1)
000026  2801              CMP      r0,#1
000028  d013              BEQ      |L5.82|
;;;268    		{
;;;269    			if (RxData == '\r')			//如果收到第一个包尾
;;;270    			{
;;;271    				RxState = 2;			//置下一个状态
;;;272    			}
;;;273    			else						//接收到了正常的数据
;;;274    			{
;;;275    				UART3_RxString[pRxPacket] = RxData;		//将数据存入数据包数组的指定位置
;;;276    				pRxPacket ++;			//数据包的位置自增
;;;277    			}
;;;278    		}
;;;279    		/*当前状态为2，接收数据包第二个包尾*/
;;;280    		else if (RxState == 2)
00002a  2802              CMP      r0,#2
00002c  d105              BNE      |L5.58|
;;;281    		{
;;;282    			if (RxData == '\n')			//如果收到第二个包尾
00002e  290a              CMP      r1,#0xa
000030  d103              BNE      |L5.58|
;;;283    			{
;;;284    				RxState = 0;			//状态归0
000032  70e2              STRB     r2,[r4,#3]
;;;285    				UART3_RxString[pRxPacket] = '\0';			//将收到的字符数据包添加一个字符串结束标志
000034  7920              LDRB     r0,[r4,#4]  ; pRxPacket
000036  541a              STRB     r2,[r3,r0]
;;;286    				UART3_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
000038  7025              STRB     r5,[r4,#0]
                  |L5.58|
;;;287    			}
;;;288    		}
;;;289    
;;;290    
;;;291    	}
;;;292    }
00003a  bd70              POP      {r4-r6,pc}
                  |L5.60|
00003c  70e5              STRB     r5,[r4,#3]            ;257
00003e  2000              MOVS     r0,#0                 ;258
000040  2220              MOVS     r2,#0x20              ;260
                  |L5.66|
000042  541a              STRB     r2,[r3,r0]            ;260
000044  1c40              ADDS     r0,r0,#1              ;258
000046  b2c0              UXTB     r0,r0                 ;258
000048  2864              CMP      r0,#0x64              ;258
00004a  d3fa              BCC      |L5.66|
00004c  7019              STRB     r1,[r3,#0]            ;263
00004e  7125              STRB     r5,[r4,#4]            ;264
000050  bd70              POP      {r4-r6,pc}
                  |L5.82|
000052  290d              CMP      r1,#0xd               ;269
000054  d004              BEQ      |L5.96|
000056  7920              LDRB     r0,[r4,#4]            ;275  ; pRxPacket
000058  5419              STRB     r1,[r3,r0]            ;275
00005a  1c40              ADDS     r0,r0,#1              ;276
00005c  7120              STRB     r0,[r4,#4]            ;276
00005e  bd70              POP      {r4-r6,pc}
                  |L5.96|
000060  2002              MOVS     r0,#2                 ;271
000062  70e0              STRB     r0,[r4,#3]            ;271
000064  bd70              POP      {r4-r6,pc}
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      0x40022020
                  |L5.108|
                          DCD      ||.data||
                  |L5.112|
                          DCD      ||.bss||+0x64

                          AREA ||i.key_Get||, CODE, READONLY, ALIGN=2

                  key_Get PROC
;;;166    
;;;167    void key_Get()//按压旋转编码器
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169    	if(GPIO_ReadDataBit(GPIOA,GPIO_Pin_6)==0)
000002  4c0c              LDR      r4,|L6.52|
000004  2140              MOVS     r1,#0x40
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ReadDataBit
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L6.48|
;;;170    			{
;;;171    				 delay_ms ( 20 );
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       delay_ms
                  |L6.22|
;;;172    				while(GPIO_ReadDataBit(GPIOA,GPIO_Pin_6)==0);
000016  2140              MOVS     r1,#0x40
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       GPIO_ReadDataBit
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L6.22|
;;;173    				delay_ms(20);
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       delay_ms
;;;174    				key_count++;
000028  4803              LDR      r0,|L6.56|
00002a  8801              LDRH     r1,[r0,#0]  ; key_count
00002c  1c49              ADDS     r1,r1,#1
00002e  8001              STRH     r1,[r0,#0]
                  |L6.48|
;;;175    			}
;;;176    			
;;;177    }
000030  bd10              POP      {r4,pc}
;;;178    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40011000
                  |L6.56|
                          DCD      key_count

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;103    // =========================================================
;;;104    int main(void)
000000  b090              SUB      sp,sp,#0x40
;;;105    {
;;;106        // 1. 硬件初始化
;;;107        IcResourceInit();    
000002  f7fffffe          BL       IcResourceInit
;;;108        // 【关键】开启全局中断，否则 DMA 中断进不去
;;;109        __enable_irq(); 	
000006  b662              CPSIE    i
;;;110        
;;;111        screen_init();        
000008  f7fffffe          BL       screen_init
;;;112        
;;;113        // 2. 界面初始化 (清黑屏)
;;;114        LCD_Fill(0, 0, 240, 320, BLACK);
00000c  2400              MOVS     r4,#0
00000e  23ff              MOVS     r3,#0xff
000010  3341              ADDS     r3,r3,#0x41
000012  22f0              MOVS     r2,#0xf0
000014  4621              MOV      r1,r4
000016  4620              MOV      r0,r4
000018  9400              STR      r4,[sp,#0]
00001a  f7fffffe          BL       LCD_Fill
;;;115        
;;;116        // 3. 初始化采集 (DMA + ADC)
;;;117        Data_Acquisition_Init();
00001e  f7fffffe          BL       Data_Acquisition_Init
;;;118    
;;;119        while(1)
;;;120        {
;;;121            // ---------------------------------------------------------
;;;122            // 任务 1: 实时监控寄存器状态 (调试用，如果不动说明挂了)
;;;123            // ---------------------------------------------------------
;;;124            // 读取 DMA0 状态 (0x07 表示传输完成且中断置位)
;;;125            uint32_t dma_status = DMA0->DMA_STS; 
000022  4e11              LDR      r6,|L7.104|
;;;126            
;;;127            // 读取 ADC 状态 (0x01 表示转换完成)
;;;128            uint32_t adc_status = ADC->ADC_STS;
000024  4f11              LDR      r7,|L7.108|
;;;129    
;;;130            char buf[50];
;;;131            // 在屏幕底部显示: DMA状态, ADC状态, 中断进入次数
;;;132            // 如果 Cnt 不涨，说明中断没进去；如果 D:00，说明 DMA 没动
;;;133            sprintf(buf, "D:%02X A:%02X Cnt:%d", dma_status, adc_status, Debug_ISR_Count);
;;;134            LCD_ShowString(10, 220, buf, YELLOW, BLACK, 16);
;;;135    				Debug_Show_8_Channels();
;;;136            // ---------------------------------------------------------
;;;137            // 任务 2: 处理采集数据
;;;138            // ---------------------------------------------------------
;;;139            if(Acq_Done_Flag == 1)
000026  4d12              LDR      r5,|L7.112|
                  |L7.40|
000028  6932              LDR      r2,[r6,#0x10]         ;125
00002a  697b              LDR      r3,[r7,#0x14]         ;128
00002c  4811              LDR      r0,|L7.116|
00002e  6800              LDR      r0,[r0,#0]            ;133  ; Debug_ISR_Count
000030  9000              STR      r0,[sp,#0]            ;133
000032  a111              ADR      r1,|L7.120|
000034  a803              ADD      r0,sp,#0xc            ;133
000036  f7fffffe          BL       __2sprintf
00003a  2010              MOVS     r0,#0x10              ;134
00003c  9001              STR      r0,[sp,#4]            ;134
00003e  4b14              LDR      r3,|L7.144|
000040  aa03              ADD      r2,sp,#0xc            ;134
000042  21dc              MOVS     r1,#0xdc              ;134
000044  9400              STR      r4,[sp,#0]            ;134
000046  200a              MOVS     r0,#0xa               ;134
000048  f7fffffe          BL       LCD_ShowString
00004c  f7fffffe          BL       Debug_Show_8_Channels
000050  7828              LDRB     r0,[r5,#0]  ; Acq_Done_Flag
000052  2801              CMP      r0,#1
000054  d104              BNE      |L7.96|
;;;140            {
;;;141                // 1. 清除标志
;;;142                Acq_Done_Flag = 0;
000056  702c              STRB     r4,[r5,#0]
;;;143    
;;;144                // 2. 显示 8 个通道的数据
;;;145                Debug_Show_8_Channels();
000058  f7fffffe          BL       Debug_Show_8_Channels
;;;146    
;;;147                // 3. 启动下一轮采集 (接力)
;;;148                Data_Acquisition_Start_Next();
00005c  f7fffffe          BL       Data_Acquisition_Start_Next
                  |L7.96|
;;;149            }
;;;150    
;;;151            // ---------------------------------------------------------
;;;152            // 任务 3: 系统扫描
;;;153            // ---------------------------------------------------------
;;;154            Sys_Scan();
000060  f7fffffe          BL       Sys_Scan
000064  e7e0              B        |L7.40|
;;;155        }
;;;156    }
;;;157    
                          ENDP

000066  0000              DCW      0x0000
                  |L7.104|
                          DCD      0x40010800
                  |L7.108|
                          DCD      0x40022100
                  |L7.112|
                          DCD      Acq_Done_Flag
                  |L7.116|
                          DCD      Debug_ISR_Count
                  |L7.120|
000078  443a2530          DCB      "D:%02X A:%02X Cnt:%d",0
00007c  32582041
000080  3a253032
000084  5820436e
000088  743a2564
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L7.144|
                          DCD      0x0000ffe0

                          AREA ||i.screen_init||, CODE, READONLY, ALIGN=1

                  screen_init PROC
;;;157    
;;;158    void screen_init()//屏幕初始化
000000  b508              PUSH     {r3,lr}
;;;159    {
;;;160    	Lcd_Init();
000002  f7fffffe          BL       Lcd_Init
;;;161    	LCD_Fill ( 1, 1, 320, 240, BLACK );//本来是花屏，刷新后为白屏
000006  2000              MOVS     r0,#0
000008  22ff              MOVS     r2,#0xff
00000a  2101              MOVS     r1,#1
00000c  9000              STR      r0,[sp,#0]
00000e  23f0              MOVS     r3,#0xf0
000010  3241              ADDS     r2,r2,#0x41
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       LCD_Fill
;;;162    }
000018  bd08              POP      {r3,pc}
;;;163    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART3_RxPacket
                          %        100
                  UART3_RxString
                          %        100

                          AREA ||.data||, DATA, ALIGN=0

                  UART3_RxFlag
000000  00                DCB      0x00
                  RxState
000001  00                DCB      0x00
                  pRxPacket
000002  00                DCB      0x00
                  |symbol_number.30|
000003  00                DCB      0x00
                  |symbol_number.31|
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_5c2d3fd9____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_5c2d3fd9____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_5c2d3fd9____REVSH|
#line 478
|__asm___6_main_c_5c2d3fd9____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
