; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\main.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.UART3_Send_Packet||, CODE, READONLY, ALIGN=2

                  UART3_Send_Packet PROC
;;;119    
;;;120    void UART3_Send_Packet()//wifi串口发送数据包
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;123    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;124    	 UART3_TxPacket[0]=0x01;
000002  480d              LDR      r0,|L1.56|
000004  2101              MOVS     r1,#1
000006  7001              STRB     r1,[r0,#0]
;;;125    	UART3_TxPacket[1]=0xA2;
000008  21a2              MOVS     r1,#0xa2
00000a  7041              STRB     r1,[r0,#1]
;;;126    	UART3_TxPacket[2]=0x12;
00000c  2112              MOVS     r1,#0x12
00000e  7081              STRB     r1,[r0,#2]
;;;127    	UART3_TxPacket[3]=0x23;
000010  2123              MOVS     r1,#0x23
000012  70c1              STRB     r1,[r0,#3]
;;;128    	UART3_TxPacket[4]=0x34;
000014  2134              MOVS     r1,#0x34
000016  7101              STRB     r1,[r0,#4]
;;;129    	UART3_TxPacket[5]=0x45;
000018  2145              MOVS     r1,#0x45
00001a  7141              STRB     r1,[r0,#5]
;;;130    	UART3_TxPacket[6]=0x56;
00001c  2156              MOVS     r1,#0x56
00001e  7181              STRB     r1,[r0,#6]
;;;131    	UART3_TxPacket[7]=0x65;
000020  2165              MOVS     r1,#0x65
000022  71c1              STRB     r1,[r0,#7]
;;;132    	UART3_TxPacket[8]=0x54;
000024  2154              MOVS     r1,#0x54
000026  7201              STRB     r1,[r0,#8]
;;;133    	UART3_TxPacket[9]=0x43;
000028  2143              MOVS     r1,#0x43
00002a  7241              STRB     r1,[r0,#9]
;;;134    	UART_SendArray(UART3,UART3_TxPacket, 10);					
00002c  4601              MOV      r1,r0
00002e  220a              MOVS     r2,#0xa
000030  4802              LDR      r0,|L1.60|
000032  f7fffffe          BL       UART_SendArray
;;;135    }
000036  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  |L1.56|
                          DCD      UART3_TxPacket
                  |L1.60|
                          DCD      0x40022020

                          AREA ||i.UART3_Send_String||, CODE, READONLY, ALIGN=2

                  UART3_Send_String PROC
;;;136    
;;;137    void UART3_Send_String()//wifi串口发送文本
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139    	UART_SendString(UART3,"uni_wro");
000002  a102              ADR      r1,|L2.12|
000004  4803              LDR      r0,|L2.20|
000006  f7fffffe          BL       UART_SendString
;;;140    }
00000a  bd10              POP      {r4,pc}
;;;141    
                          ENDP

                  |L2.12|
00000c  756e695f          DCB      "uni_wro",0
000010  77726f00
                  |L2.20|
                          DCD      0x40022020

                          AREA ||i.UART3_receive_Packet||, CODE, READONLY, ALIGN=2

                  UART3_receive_Packet PROC
;;;141    
;;;142    void UART3_receive_Packet()//wifi串口接受数据(数据包格式FF xx xx xx xx FE)
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;145    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;146    	if (UART_GetFlagStatus(UART3, UART_Flag_RX) == SET)	//判断是否是USART3的接收事件触发的中断
000002  4c15              LDR      r4,|L3.88|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d111              BNE      |L3.52|
;;;147    	{
;;;148    		
;;;149    		uint8_t RxData = UART_ReceiveData(UART3);			//读取数据寄存器，存放在接收的数据变量
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ReceiveData
000016  b2c0              UXTB     r0,r0
;;;150    
;;;151    		/*使用状态机的思路，依次处理数据包的不同部分*/
;;;152    
;;;153    		/*当前状态为0，接收数据包包头*/
;;;154    				if (RxState == 0)
000018  4a10              LDR      r2,|L3.92|
00001a  2400              MOVS     r4,#0
00001c  7811              LDRB     r1,[r2,#0]  ; RxState
00001e  2301              MOVS     r3,#1                 ;146
000020  2900              CMP      r1,#0
000022  d008              BEQ      |L3.54|
;;;155    		{
;;;156    			if (RxData == 0xFF)			//如果数据确实是包头
;;;157    			{
;;;158    				RxState = 1;			//置下一个状态
;;;159    				pRxPacket = 0;			//数据包的位置归零
;;;160    			}
;;;161    		}
;;;162    		/*当前状态为1，接收数据包数据*/
;;;163    		else if (RxState == 1)
000024  2901              CMP      r1,#1
000026  d00b              BEQ      |L3.64|
;;;164    		{
;;;165    			UART3_RxPacket[pRxPacket] = RxData;	//将数据存入数据包数组的指定位置
;;;166    			pRxPacket ++;				//数据包的位置自增
;;;167    			if (pRxPacket >=4)			//如果收够4个数据
;;;168    			{
;;;169    				RxState = 2;			//置下一个状态
;;;170    			}
;;;171    		}
;;;172    		/*当前状态为2，接收数据包包尾*/
;;;173    		else if (RxState == 2)
000028  2902              CMP      r1,#2
00002a  d103              BNE      |L3.52|
;;;174    		{
;;;175    			if (RxData == 0xFE)			//如果数据确实是包尾部
00002c  28fe              CMP      r0,#0xfe
00002e  d101              BNE      |L3.52|
;;;176    			{
;;;177    				RxState = 0;			//状态归0
000030  7014              STRB     r4,[r2,#0]
;;;178    				UART3_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
000032  7113              STRB     r3,[r2,#4]
                  |L3.52|
;;;179    			}
;;;180    		}
;;;181    
;;;182    
;;;183    	}
;;;184    }
000034  bd10              POP      {r4,pc}
                  |L3.54|
000036  28ff              CMP      r0,#0xff              ;156
000038  d1fc              BNE      |L3.52|
00003a  7013              STRB     r3,[r2,#0]            ;158
00003c  7054              STRB     r4,[r2,#1]            ;159
                  |L3.62|
00003e  bd10              POP      {r4,pc}
                  |L3.64|
000040  4b07              LDR      r3,|L3.96|
000042  7851              LDRB     r1,[r2,#1]            ;165  ; pRxPacket
000044  5458              STRB     r0,[r3,r1]            ;165
000046  1c49              ADDS     r1,r1,#1              ;166
000048  b2c8              UXTB     r0,r1                 ;166
00004a  7050              STRB     r0,[r2,#1]            ;166
00004c  2804              CMP      r0,#4                 ;167
00004e  d3f6              BCC      |L3.62|
000050  2002              MOVS     r0,#2                 ;169
000052  7010              STRB     r0,[r2,#0]            ;169
000054  bd10              POP      {r4,pc}
;;;185    void UART3_receive_String()
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      0x40022020
                  |L3.92|
                          DCD      ||.data||
                  |L3.96|
                          DCD      ||.bss||

                          AREA ||i.UART3_receive_String||, CODE, READONLY, ALIGN=2

                  UART3_receive_String PROC
;;;184    }
;;;185    void UART3_receive_String()
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
;;;187    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;188    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;189    	if (UART_GetFlagStatus(UART3, UART_Flag_RX) == SET)	//判断是否是USART1的接收事件触发的中断
000002  4c19              LDR      r4,|L4.104|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d114              BNE      |L4.58|
;;;190    	{
;;;191    		uint8_t RxData = UART_ReceiveData(UART3);			//读取数据寄存器，存放在接收的数据变量
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ReceiveData
000016  b2c1              UXTB     r1,r0
;;;192    
;;;193    		/*使用状态机的思路，依次处理数据包的不同部分*/
;;;194    
;;;195    		/*当前状态为0，接收数据包包头*/
;;;196    		if (RxState == 0)
000018  4c14              LDR      r4,|L4.108|
00001a  2200              MOVS     r2,#0
00001c  78a0              LDRB     r0,[r4,#2]  ; RxState
00001e  2501              MOVS     r5,#1                 ;189
;;;197    		{
;;;198    			 RxState=1;
;;;199                for(uint8_t i=0;i<100;i++)
;;;200                {
;;;201                    UART3_RxString[i]=' ';
000020  4b13              LDR      r3,|L4.112|
000022  2800              CMP      r0,#0                 ;196
000024  d00a              BEQ      |L4.60|
;;;202                }
;;;203                pRxPacket=0;
;;;204                UART3_RxString[pRxPacket]=RxData;
;;;205                pRxPacket++;
;;;206    		}
;;;207    		/*当前状态为1，接收数据包数据，同时判断是否接收到了第一个包尾*/
;;;208    		else if (RxState == 1)
000026  2801              CMP      r0,#1
000028  d013              BEQ      |L4.82|
;;;209    		{
;;;210    			if (RxData == '\r')			//如果收到第一个包尾
;;;211    			{
;;;212    				RxState = 2;			//置下一个状态
;;;213    			}
;;;214    			else						//接收到了正常的数据
;;;215    			{
;;;216    				UART3_RxString[pRxPacket] = RxData;		//将数据存入数据包数组的指定位置
;;;217    				pRxPacket ++;			//数据包的位置自增
;;;218    			}
;;;219    		}
;;;220    		/*当前状态为2，接收数据包第二个包尾*/
;;;221    		else if (RxState == 2)
00002a  2802              CMP      r0,#2
00002c  d105              BNE      |L4.58|
;;;222    		{
;;;223    			if (RxData == '\n')			//如果收到第二个包尾
00002e  290a              CMP      r1,#0xa
000030  d103              BNE      |L4.58|
;;;224    			{
;;;225    				RxState = 0;			//状态归0
000032  70a2              STRB     r2,[r4,#2]
;;;226    				UART3_RxString[pRxPacket] = '\0';			//将收到的字符数据包添加一个字符串结束标志
000034  78e0              LDRB     r0,[r4,#3]  ; pRxPacket
000036  541a              STRB     r2,[r3,r0]
;;;227    				UART3_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
000038  7125              STRB     r5,[r4,#4]
                  |L4.58|
;;;228    			}
;;;229    		}
;;;230    
;;;231    
;;;232    	}
;;;233    }
00003a  bd70              POP      {r4-r6,pc}
                  |L4.60|
00003c  70a5              STRB     r5,[r4,#2]            ;198
00003e  2000              MOVS     r0,#0                 ;199
000040  2220              MOVS     r2,#0x20              ;201
                  |L4.66|
000042  541a              STRB     r2,[r3,r0]            ;201
000044  1c40              ADDS     r0,r0,#1              ;199
000046  b2c0              UXTB     r0,r0                 ;199
000048  2864              CMP      r0,#0x64              ;199
00004a  d3fa              BCC      |L4.66|
00004c  7019              STRB     r1,[r3,#0]            ;204
00004e  70e5              STRB     r5,[r4,#3]            ;205
000050  bd70              POP      {r4-r6,pc}
                  |L4.82|
000052  290d              CMP      r1,#0xd               ;210
000054  d004              BEQ      |L4.96|
000056  78e0              LDRB     r0,[r4,#3]            ;216  ; pRxPacket
000058  5419              STRB     r1,[r3,r0]            ;216
00005a  1c40              ADDS     r0,r0,#1              ;217
00005c  70e0              STRB     r0,[r4,#3]            ;217
00005e  bd70              POP      {r4-r6,pc}
                  |L4.96|
000060  2002              MOVS     r0,#2                 ;212
000062  70a0              STRB     r0,[r4,#2]            ;212
000064  bd70              POP      {r4-r6,pc}
                          ENDP

000066  0000              DCW      0x0000
                  |L4.104|
                          DCD      0x40022020
                  |L4.108|
                          DCD      ||.data||
                  |L4.112|
                          DCD      ||.bss||+0x64

                          AREA ||i.key_Get||, CODE, READONLY, ALIGN=2

                  key_Get PROC
;;;107    
;;;108    void key_Get()//按压旋转编码器
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110    	if(GPIO_ReadDataBit(GPIOA,GPIO_Pin_6)==0)
000002  4c0c              LDR      r4,|L5.52|
000004  2140              MOVS     r1,#0x40
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ReadDataBit
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L5.48|
;;;111    			{
;;;112    				 delay_ms ( 20 );
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       delay_ms
                  |L5.22|
;;;113    				while(GPIO_ReadDataBit(GPIOA,GPIO_Pin_6)==0);
000016  2140              MOVS     r1,#0x40
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       GPIO_ReadDataBit
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L5.22|
;;;114    				delay_ms(20);
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       delay_ms
;;;115    				key_count++;
000028  4803              LDR      r0,|L5.56|
00002a  88c1              LDRH     r1,[r0,#6]  ; key_count
00002c  1c49              ADDS     r1,r1,#1
00002e  80c1              STRH     r1,[r0,#6]
                  |L5.48|
;;;116    			}
;;;117    			
;;;118    }
000030  bd10              POP      {r4,pc}
;;;119    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40011000
                  |L5.56|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;53     
;;;54     int main(void)
000000  b508              PUSH     {r3,lr}
;;;55     {
;;;56         IcResourceInit();     // ?????
000002  f7fffffe          BL       IcResourceInit
;;;57         screen_init();        // ?????
000006  f7fffffe          BL       screen_init
;;;58         
;;;59         // ??? ???(????)
;;;60         LCD_Fill(0, 0, 240, 320, BLACK);   // ????
00000a  2000              MOVS     r0,#0
00000c  23ff              MOVS     r3,#0xff
00000e  3341              ADDS     r3,r3,#0x41
000010  22f0              MOVS     r2,#0xf0
000012  4601              MOV      r1,r0
000014  9000              STR      r0,[sp,#0]
000016  f7fffffe          BL       LCD_Fill
;;;61         LCD_DrawGrid(200, 255, 20, 15, BLUE);  // ???
00001a  480b              LDR      r0,|L6.72|
00001c  9000              STR      r0,[sp,#0]
00001e  230f              MOVS     r3,#0xf
000020  2214              MOVS     r2,#0x14
000022  21ff              MOVS     r1,#0xff
000024  20c8              MOVS     r0,#0xc8
000026  f7fffffe          BL       LCD_DrawGrid
;;;62         
;;;63         // (????????,????)
;;;64         // TFT_DrawLine(0, 160, 240, 160, RED);
;;;65         // TFT_DrawLine(120, 0, 120, 320, RED);
;;;66     		Data_Acquisition_Init();
00002a  f7fffffe          BL       Data_Acquisition_Init
;;;67         while(1)
;;;68         {
;;;69             
;;;70     					menu();
;;;71             // 【新增 2】 检查采集是否完成
;;;72             if(Acq_Done_Flag == 1)
00002e  4c07              LDR      r4,|L6.76|
                  |L6.48|
000030  f7fffffe          BL       menu
000034  7820              LDRB     r0,[r4,#0]  ; Acq_Done_Flag
000036  2801              CMP      r0,#1
000038  d101              BNE      |L6.62|
;;;73             {
;;;74                 /* 
;;;75                    数据已存放在 Acq_Data.Buffer[] 中
;;;76                    0~499 是通道1，500~999 是通道2
;;;77                    在这里处理数据（如发送串口、计算等），不需要画图
;;;78                 */
;;;79     					
;;;80                 // 【重要】 处理完数据后，必须调用此函数启动下一轮采集
;;;81                 Data_Acquisition_Start_Next();
00003a  f7fffffe          BL       Data_Acquisition_Start_Next
                  |L6.62|
;;;82             }
;;;83             Sys_Scan();        // ????
00003e  f7fffffe          BL       Sys_Scan
;;;84             key_Get();
000042  f7fffffe          BL       key_Get
000046  e7f3              B        |L6.48|
;;;85     
;;;86             // ??????(????)
;;;87            
;;;88         }
;;;89     }
;;;90     
                          ENDP

                  |L6.72|
                          DCD      0x000003bd
                  |L6.76|
                          DCD      Acq_Done_Flag

                          AREA ||i.screen_init||, CODE, READONLY, ALIGN=1

                  screen_init PROC
;;;98     
;;;99     void screen_init()//屏幕初始化
000000  b508              PUSH     {r3,lr}
;;;100    {
;;;101    	Lcd_Init();
000002  f7fffffe          BL       Lcd_Init
;;;102    	LCD_Fill ( 1, 1, 320, 240, BLACK );//本来是花屏，刷新后为白屏
000006  2000              MOVS     r0,#0
000008  22ff              MOVS     r2,#0xff
00000a  2101              MOVS     r1,#1
00000c  9000              STR      r0,[sp,#0]
00000e  23f0              MOVS     r3,#0xf0
000010  3241              ADDS     r2,r2,#0x41
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       LCD_Fill
;;;103    }
000018  bd08              POP      {r3,pc}
;;;104    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART3_RxPacket
                          %        100
                  UART3_RxString
                          %        100

                          AREA ||.data||, DATA, ALIGN=1

                  RxState
000000  00                DCB      0x00
                  pRxPacket
000001  00                DCB      0x00
                  |symbol_number.27|
000002  00                DCB      0x00
                  |symbol_number.28|
000003  00                DCB      0x00
                  UART3_RxFlag
000004  0000              DCB      0x00,0x00
                  key_count
000006  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_main____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REVSH|
#line 478
|__asm___6_main_c_main____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
