; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\main.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.ADC_Conversion||, CODE, READONLY, ALIGN=2

                  ADC_Conversion PROC
;;;109    
;;;110    void ADC_Conversion()//ADC采集
000000  b5fe              PUSH     {r1-r7,lr}
;;;111    {
;;;112    	for(int ADC_num=1;ADC_num<=8;ADC_num++)//8个ADC通道采集
000002  2401              MOVS     r4,#1
;;;113    	{
;;;114    		if(ADC_num==1) ADC_SetChannel(ADC,ADC_Channel_0);
000004  4e3f              LDR      r6,|L1.260|
;;;115    		if(ADC_num==2) ADC_SetChannel(ADC,ADC_Channel_1);
;;;116    		if(ADC_num==3) ADC_SetChannel(ADC,ADC_Channel_10);
;;;117    		if(ADC_num==4) ADC_SetChannel(ADC,ADC_Channel_11);
;;;118    		if(ADC_num==5) ADC_SetChannel(ADC,ADC_Channel_12);
;;;119    		if(ADC_num==6) ADC_SetChannel(ADC,ADC_Channel_13);
;;;120    		if(ADC_num==7) ADC_SetChannel(ADC,ADC_Channel_14);
;;;121    		if(ADC_num==8) ADC_SetChannel(ADC,ADC_Channel_15);
;;;122    		static volatile uint16_t ADC_Value;//定义变量存储ADC值
;;;123    		//ADC单次转化
;;;124    		ADC_SoftwareStartConv(ADC);//软件触发ADC
;;;125    		while(ADC_Flag == RESET);//等待ADC转换结束
000006  4d40              LDR      r5,|L1.264|
                  |L1.8|
000008  2c01              CMP      r4,#1                 ;114
00000a  d103              BNE      |L1.20|
00000c  2100              MOVS     r1,#0                 ;114
00000e  4630              MOV      r0,r6                 ;114
000010  f7fffffe          BL       ADC_SetChannel
                  |L1.20|
000014  2c02              CMP      r4,#2                 ;115
000016  d103              BNE      |L1.32|
000018  2101              MOVS     r1,#1                 ;115
00001a  4630              MOV      r0,r6                 ;115
00001c  f7fffffe          BL       ADC_SetChannel
                  |L1.32|
000020  2c03              CMP      r4,#3                 ;116
000022  d103              BNE      |L1.44|
000024  210a              MOVS     r1,#0xa               ;116
000026  4630              MOV      r0,r6                 ;116
000028  f7fffffe          BL       ADC_SetChannel
                  |L1.44|
00002c  2c04              CMP      r4,#4                 ;117
00002e  d103              BNE      |L1.56|
000030  210b              MOVS     r1,#0xb               ;117
000032  4630              MOV      r0,r6                 ;117
000034  f7fffffe          BL       ADC_SetChannel
                  |L1.56|
000038  2c05              CMP      r4,#5                 ;118
00003a  d103              BNE      |L1.68|
00003c  210c              MOVS     r1,#0xc               ;118
00003e  4630              MOV      r0,r6                 ;118
000040  f7fffffe          BL       ADC_SetChannel
                  |L1.68|
000044  2c06              CMP      r4,#6                 ;119
000046  d103              BNE      |L1.80|
000048  210d              MOVS     r1,#0xd               ;119
00004a  4630              MOV      r0,r6                 ;119
00004c  f7fffffe          BL       ADC_SetChannel
                  |L1.80|
000050  2c07              CMP      r4,#7                 ;120
000052  d103              BNE      |L1.92|
000054  210e              MOVS     r1,#0xe               ;120
000056  4630              MOV      r0,r6                 ;120
000058  f7fffffe          BL       ADC_SetChannel
                  |L1.92|
00005c  2c08              CMP      r4,#8                 ;121
00005e  d103              BNE      |L1.104|
000060  210f              MOVS     r1,#0xf               ;121
000062  4630              MOV      r0,r6                 ;121
000064  f7fffffe          BL       ADC_SetChannel
                  |L1.104|
000068  4630              MOV      r0,r6                 ;124
00006a  f7fffffe          BL       ADC_SoftwareStartConv
                  |L1.110|
00006e  7928              LDRB     r0,[r5,#4]  ; ADC_Flag
000070  2800              CMP      r0,#0
000072  d0fc              BEQ      |L1.110|
;;;126    		ADC_Flag = RESET;
000074  2000              MOVS     r0,#0
000076  7128              STRB     r0,[r5,#4]
;;;127    		LCD_ShowIntNum (270 , 20*ADC_num,ADC_GetConversionValue(ADC), 6, RED, WHITE,16 );//ADC采样结果
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       ADC_GetConversionValue
00007e  4602              MOV      r2,r0
000080  2010              MOVS     r0,#0x10
000082  9002              STR      r0,[sp,#8]
000084  4921              LDR      r1,|L1.268|
000086  2014              MOVS     r0,#0x14
000088  9101              STR      r1,[sp,#4]
00008a  4360              MULS     r0,r4,r0
00008c  4b20              LDR      r3,|L1.272|
00008e  b281              UXTH     r1,r0
000090  9300              STR      r3,[sp,#0]
000092  20ff              MOVS     r0,#0xff
000094  2306              MOVS     r3,#6
000096  300f              ADDS     r0,r0,#0xf
000098  f7fffffe          BL       LCD_ShowIntNum
;;;128    		if(ADC_num==1) AD1=ADC_GetConversionValue(ADC);
00009c  2c01              CMP      r4,#1
00009e  d103              BNE      |L1.168|
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       ADC_GetConversionValue
0000a6  8128              STRH     r0,[r5,#8]
                  |L1.168|
;;;129    		if(ADC_num==2) AD2=ADC_GetConversionValue(ADC);
0000a8  2c02              CMP      r4,#2
0000aa  d103              BNE      |L1.180|
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       ADC_GetConversionValue
0000b2  8168              STRH     r0,[r5,#0xa]
                  |L1.180|
;;;130    		if(ADC_num==3) AD3=ADC_GetConversionValue(ADC);
0000b4  2c03              CMP      r4,#3
0000b6  d103              BNE      |L1.192|
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       ADC_GetConversionValue
0000be  81a8              STRH     r0,[r5,#0xc]
                  |L1.192|
;;;131    		if(ADC_num==4) AD4=ADC_GetConversionValue(ADC);
0000c0  2c04              CMP      r4,#4
0000c2  d103              BNE      |L1.204|
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       ADC_GetConversionValue
0000ca  81e8              STRH     r0,[r5,#0xe]
                  |L1.204|
;;;132    		if(ADC_num==5) AD5=ADC_GetConversionValue(ADC);
0000cc  2c05              CMP      r4,#5
0000ce  d103              BNE      |L1.216|
0000d0  4630              MOV      r0,r6
0000d2  f7fffffe          BL       ADC_GetConversionValue
0000d6  8228              STRH     r0,[r5,#0x10]
                  |L1.216|
;;;133    		if(ADC_num==6) AD6=ADC_GetConversionValue(ADC);
0000d8  2c06              CMP      r4,#6
0000da  d103              BNE      |L1.228|
0000dc  4630              MOV      r0,r6
0000de  f7fffffe          BL       ADC_GetConversionValue
0000e2  8268              STRH     r0,[r5,#0x12]
                  |L1.228|
;;;134    		if(ADC_num==7) AD7=ADC_GetConversionValue(ADC);
0000e4  2c07              CMP      r4,#7
0000e6  d103              BNE      |L1.240|
0000e8  4630              MOV      r0,r6
0000ea  f7fffffe          BL       ADC_GetConversionValue
0000ee  82a8              STRH     r0,[r5,#0x14]
                  |L1.240|
;;;135    		if(ADC_num==8) AD8=ADC_GetConversionValue(ADC);
0000f0  2c08              CMP      r4,#8
0000f2  d103              BNE      |L1.252|
0000f4  4630              MOV      r0,r6
0000f6  f7fffffe          BL       ADC_GetConversionValue
0000fa  82e8              STRH     r0,[r5,#0x16]
                  |L1.252|
0000fc  1c64              ADDS     r4,r4,#1              ;112
0000fe  2c08              CMP      r4,#8                 ;112
000100  dd82              BLE      |L1.8|
;;;136    	}
;;;137    }
000102  bdfe              POP      {r1-r7,pc}
;;;138    
                          ENDP

                  |L1.260|
                          DCD      0x40022110
                  |L1.264|
                          DCD      ||.data||
                  |L1.268|
                          DCD      0x0000ffff
                  |L1.272|
                          DCD      0x0000f882

                          AREA ||i.ADC_Conversion_IRQ||, CODE, READONLY, ALIGN=2

                  ADC_Conversion_IRQ PROC
;;;99     
;;;100    void ADC_Conversion_IRQ()//ADC中断处理
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102      if(ADC_GetFlagStatus(ADC, ADC_Flag_ADCIF))//判断ADC标志位
000002  4c07              LDR      r4,|L2.32|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       ADC_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d006              BEQ      |L2.30|
;;;103      {
;;;104        ADC_ClearFlag(ADC, ADC_Flag_ADCIF);//清除ADC标志位
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_ClearFlag
;;;105        ADC_Flag = SET;//自定义标志位置起
000018  4902              LDR      r1,|L2.36|
00001a  2001              MOVS     r0,#1
00001c  7108              STRB     r0,[r1,#4]
                  |L2.30|
;;;106      }
;;;107    }
00001e  bd10              POP      {r4,pc}
;;;108    
                          ENDP

                  |L2.32|
                          DCD      0x40022110
                  |L2.36|
                          DCD      ||.data||

                          AREA ||i.UART3_Send_Packet||, CODE, READONLY, ALIGN=2

                  UART3_Send_Packet PROC
;;;152    
;;;153    void UART3_Send_Packet()//wifi串口发送数据包
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;156    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;157    	 UART3_TxPacket[0]=0x01;
000002  480d              LDR      r0,|L3.56|
000004  2101              MOVS     r1,#1
000006  7001              STRB     r1,[r0,#0]
;;;158    	UART3_TxPacket[1]=0xA2;
000008  21a2              MOVS     r1,#0xa2
00000a  7041              STRB     r1,[r0,#1]
;;;159    	UART3_TxPacket[2]=0x12;
00000c  2112              MOVS     r1,#0x12
00000e  7081              STRB     r1,[r0,#2]
;;;160    	UART3_TxPacket[3]=0x23;
000010  2123              MOVS     r1,#0x23
000012  70c1              STRB     r1,[r0,#3]
;;;161    	UART3_TxPacket[4]=0x34;
000014  2134              MOVS     r1,#0x34
000016  7101              STRB     r1,[r0,#4]
;;;162    	UART3_TxPacket[5]=0x45;
000018  2145              MOVS     r1,#0x45
00001a  7141              STRB     r1,[r0,#5]
;;;163    	UART3_TxPacket[6]=0x56;
00001c  2156              MOVS     r1,#0x56
00001e  7181              STRB     r1,[r0,#6]
;;;164    	UART3_TxPacket[7]=0x65;
000020  2165              MOVS     r1,#0x65
000022  71c1              STRB     r1,[r0,#7]
;;;165    	UART3_TxPacket[8]=0x54;
000024  2154              MOVS     r1,#0x54
000026  7201              STRB     r1,[r0,#8]
;;;166    	UART3_TxPacket[9]=0x43;
000028  2143              MOVS     r1,#0x43
00002a  7241              STRB     r1,[r0,#9]
;;;167    	UART_SendArray(UART3,UART3_TxPacket, 10);					
00002c  4601              MOV      r1,r0
00002e  220a              MOVS     r2,#0xa
000030  4802              LDR      r0,|L3.60|
000032  f7fffffe          BL       UART_SendArray
;;;168    }
000036  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  |L3.56|
                          DCD      UART3_TxPacket
                  |L3.60|
                          DCD      0x40022020

                          AREA ||i.UART3_Send_String||, CODE, READONLY, ALIGN=2

                  UART3_Send_String PROC
;;;169    
;;;170    void UART3_Send_String()//wifi串口发送文本
000000  b510              PUSH     {r4,lr}
;;;171    {
;;;172    	UART_SendString(UART3,"uni_wro");
000002  a102              ADR      r1,|L4.12|
000004  4803              LDR      r0,|L4.20|
000006  f7fffffe          BL       UART_SendString
;;;173    }
00000a  bd10              POP      {r4,pc}
;;;174    
                          ENDP

                  |L4.12|
00000c  756e695f          DCB      "uni_wro",0
000010  77726f00
                  |L4.20|
                          DCD      0x40022020

                          AREA ||i.UART3_receive_Packet||, CODE, READONLY, ALIGN=2

                  UART3_receive_Packet PROC
;;;174    
;;;175    void UART3_receive_Packet()//wifi串口接受数据(数据包格式FF xx xx xx xx FE)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;178    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;179    	if (UART_GetFlagStatus(UART3, UART_Flag_RX) == SET)	//判断是否是USART3的接收事件触发的中断
000002  4c15              LDR      r4,|L5.88|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d111              BNE      |L5.52|
;;;180    	{
;;;181    		
;;;182    		uint8_t RxData = UART_ReceiveData(UART3);			//读取数据寄存器，存放在接收的数据变量
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ReceiveData
000016  b2c0              UXTB     r0,r0
;;;183    
;;;184    		/*使用状态机的思路，依次处理数据包的不同部分*/
;;;185    
;;;186    		/*当前状态为0，接收数据包包头*/
;;;187    				if (RxState == 0)
000018  4a10              LDR      r2,|L5.92|
00001a  2400              MOVS     r4,#0
00001c  7811              LDRB     r1,[r2,#0]  ; RxState
00001e  2301              MOVS     r3,#1                 ;179
000020  2900              CMP      r1,#0
000022  d008              BEQ      |L5.54|
;;;188    		{
;;;189    			if (RxData == 0xFF)			//如果数据确实是包头
;;;190    			{
;;;191    				RxState = 1;			//置下一个状态
;;;192    				pRxPacket = 0;			//数据包的位置归零
;;;193    			}
;;;194    		}
;;;195    		/*当前状态为1，接收数据包数据*/
;;;196    		else if (RxState == 1)
000024  2901              CMP      r1,#1
000026  d00b              BEQ      |L5.64|
;;;197    		{
;;;198    			UART3_RxPacket[pRxPacket] = RxData;	//将数据存入数据包数组的指定位置
;;;199    			pRxPacket ++;				//数据包的位置自增
;;;200    			if (pRxPacket >=4)			//如果收够4个数据
;;;201    			{
;;;202    				RxState = 2;			//置下一个状态
;;;203    			}
;;;204    		}
;;;205    		/*当前状态为2，接收数据包包尾*/
;;;206    		else if (RxState == 2)
000028  2902              CMP      r1,#2
00002a  d103              BNE      |L5.52|
;;;207    		{
;;;208    			if (RxData == 0xFE)			//如果数据确实是包尾部
00002c  28fe              CMP      r0,#0xfe
00002e  d101              BNE      |L5.52|
;;;209    			{
;;;210    				RxState = 0;			//状态归0
000030  7014              STRB     r4,[r2,#0]
;;;211    				UART3_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
000032  7153              STRB     r3,[r2,#5]
                  |L5.52|
;;;212    			}
;;;213    		}
;;;214    
;;;215    
;;;216    	}
;;;217    }
000034  bd10              POP      {r4,pc}
                  |L5.54|
000036  28ff              CMP      r0,#0xff              ;189
000038  d1fc              BNE      |L5.52|
00003a  7013              STRB     r3,[r2,#0]            ;191
00003c  7054              STRB     r4,[r2,#1]            ;192
                  |L5.62|
00003e  bd10              POP      {r4,pc}
                  |L5.64|
000040  4b07              LDR      r3,|L5.96|
000042  7851              LDRB     r1,[r2,#1]            ;198  ; pRxPacket
000044  5458              STRB     r0,[r3,r1]            ;198
000046  1c49              ADDS     r1,r1,#1              ;199
000048  b2c8              UXTB     r0,r1                 ;199
00004a  7050              STRB     r0,[r2,#1]            ;199
00004c  2804              CMP      r0,#4                 ;200
00004e  d3f6              BCC      |L5.62|
000050  2002              MOVS     r0,#2                 ;202
000052  7010              STRB     r0,[r2,#0]            ;202
000054  bd10              POP      {r4,pc}
;;;218    void UART3_receive_String()
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x40022020
                  |L5.92|
                          DCD      ||.data||
                  |L5.96|
                          DCD      ||.bss||

                          AREA ||i.UART3_receive_String||, CODE, READONLY, ALIGN=2

                  UART3_receive_String PROC
;;;217    }
;;;218    void UART3_receive_String()
000000  b570              PUSH     {r4-r6,lr}
;;;219    {
;;;220    	static uint8_t RxState = 0;		//定义表示当前状态机状态的静态变量
;;;221    	static uint8_t pRxPacket = 0;	//定义表示当前接收数据位置的静态变量
;;;222    	if (UART_GetFlagStatus(UART3, UART_Flag_RX) == SET)	//判断是否是USART1的接收事件触发的中断
000002  4c19              LDR      r4,|L6.104|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d114              BNE      |L6.58|
;;;223    	{
;;;224    		uint8_t RxData = UART_ReceiveData(UART3);			//读取数据寄存器，存放在接收的数据变量
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ReceiveData
000016  b2c1              UXTB     r1,r0
;;;225    
;;;226    		/*使用状态机的思路，依次处理数据包的不同部分*/
;;;227    
;;;228    		/*当前状态为0，接收数据包包头*/
;;;229    		if (RxState == 0)
000018  4c14              LDR      r4,|L6.108|
00001a  2200              MOVS     r2,#0
00001c  78a0              LDRB     r0,[r4,#2]  ; RxState
00001e  2501              MOVS     r5,#1                 ;222
;;;230    		{
;;;231    			 RxState=1;
;;;232                for(uint8_t i=0;i<100;i++)
;;;233                {
;;;234                    UART3_RxString[i]=' ';
000020  4b13              LDR      r3,|L6.112|
000022  2800              CMP      r0,#0                 ;229
000024  d00a              BEQ      |L6.60|
;;;235                }
;;;236                pRxPacket=0;
;;;237                UART3_RxString[pRxPacket]=RxData;
;;;238                pRxPacket++;
;;;239    		}
;;;240    		/*当前状态为1，接收数据包数据，同时判断是否接收到了第一个包尾*/
;;;241    		else if (RxState == 1)
000026  2801              CMP      r0,#1
000028  d013              BEQ      |L6.82|
;;;242    		{
;;;243    			if (RxData == '\r')			//如果收到第一个包尾
;;;244    			{
;;;245    				RxState = 2;			//置下一个状态
;;;246    			}
;;;247    			else						//接收到了正常的数据
;;;248    			{
;;;249    				UART3_RxString[pRxPacket] = RxData;		//将数据存入数据包数组的指定位置
;;;250    				pRxPacket ++;			//数据包的位置自增
;;;251    			}
;;;252    		}
;;;253    		/*当前状态为2，接收数据包第二个包尾*/
;;;254    		else if (RxState == 2)
00002a  2802              CMP      r0,#2
00002c  d105              BNE      |L6.58|
;;;255    		{
;;;256    			if (RxData == '\n')			//如果收到第二个包尾
00002e  290a              CMP      r1,#0xa
000030  d103              BNE      |L6.58|
;;;257    			{
;;;258    				RxState = 0;			//状态归0
000032  70a2              STRB     r2,[r4,#2]
;;;259    				UART3_RxString[pRxPacket] = '\0';			//将收到的字符数据包添加一个字符串结束标志
000034  78e0              LDRB     r0,[r4,#3]  ; pRxPacket
000036  541a              STRB     r2,[r3,r0]
;;;260    				UART3_RxFlag = 1;		//接收数据包标志位置1，成功接收一个数据包
000038  7165              STRB     r5,[r4,#5]
                  |L6.58|
;;;261    			}
;;;262    		}
;;;263    
;;;264    
;;;265    	}
;;;266    }
00003a  bd70              POP      {r4-r6,pc}
                  |L6.60|
00003c  70a5              STRB     r5,[r4,#2]            ;231
00003e  2000              MOVS     r0,#0                 ;232
000040  2220              MOVS     r2,#0x20              ;234
                  |L6.66|
000042  541a              STRB     r2,[r3,r0]            ;234
000044  1c40              ADDS     r0,r0,#1              ;232
000046  b2c0              UXTB     r0,r0                 ;232
000048  2864              CMP      r0,#0x64              ;232
00004a  d3fa              BCC      |L6.66|
00004c  7019              STRB     r1,[r3,#0]            ;237
00004e  70e5              STRB     r5,[r4,#3]            ;238
000050  bd70              POP      {r4-r6,pc}
                  |L6.82|
000052  290d              CMP      r1,#0xd               ;243
000054  d004              BEQ      |L6.96|
000056  78e0              LDRB     r0,[r4,#3]            ;249  ; pRxPacket
000058  5419              STRB     r1,[r3,r0]            ;249
00005a  1c40              ADDS     r0,r0,#1              ;250
00005c  70e0              STRB     r0,[r4,#3]            ;250
00005e  bd70              POP      {r4-r6,pc}
                  |L6.96|
000060  2002              MOVS     r0,#2                 ;245
000062  70a0              STRB     r0,[r4,#2]            ;245
000064  bd70              POP      {r4-r6,pc}
                          ENDP

000066  0000              DCW      0x0000
                  |L6.104|
                          DCD      0x40022020
                  |L6.108|
                          DCD      ||.data||
                  |L6.112|
                          DCD      ||.bss||+0x64

                          AREA ||i.key_Get||, CODE, READONLY, ALIGN=2

                  key_Get PROC
;;;140    
;;;141    void key_Get()//按压旋转编码器
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143    	if(GPIO_ReadDataBit(GPIOA,GPIO_Pin_6)==0)
000002  4c0c              LDR      r4,|L7.52|
000004  2140              MOVS     r1,#0x40
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ReadDataBit
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L7.48|
;;;144    			{
;;;145    				 delay_ms ( 20 );
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       delay_ms
                  |L7.22|
;;;146    				while(GPIO_ReadDataBit(GPIOA,GPIO_Pin_6)==0);
000016  2140              MOVS     r1,#0x40
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       GPIO_ReadDataBit
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L7.22|
;;;147    				delay_ms(20);
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       delay_ms
;;;148    				key_count++;
000028  4803              LDR      r0,|L7.56|
00002a  88c1              LDRH     r1,[r0,#6]  ; key_count
00002c  1c49              ADDS     r1,r1,#1
00002e  80c1              STRH     r1,[r0,#6]
                  |L7.48|
;;;149    			}
;;;150    			
;;;151    }
000030  bd10              POP      {r4,pc}
;;;152    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x40011000
                  |L7.56|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;59       */
;;;60     int main(void)
000000  b508              PUSH     {r3,lr}
;;;61     {
;;;62         IcResourceInit();     // ?????
000002  f7fffffe          BL       IcResourceInit
;;;63         screen_init();        // ?????
000006  f7fffffe          BL       screen_init
;;;64         
;;;65         // ??? ???(????)
;;;66         LCD_Fill(0, 0, 240, 320, BLACK);   // ????
00000a  2000              MOVS     r0,#0
00000c  23ff              MOVS     r3,#0xff
00000e  3341              ADDS     r3,r3,#0x41
000010  22f0              MOVS     r2,#0xf0
000012  4601              MOV      r1,r0
000014  9000              STR      r0,[sp,#0]
000016  f7fffffe          BL       LCD_Fill
;;;67         LCD_DrawGrid(200, 255, 20, 15, BLUE);  // ???
00001a  4807              LDR      r0,|L8.56|
00001c  9000              STR      r0,[sp,#0]
00001e  230f              MOVS     r3,#0xf
000020  2214              MOVS     r2,#0x14
000022  21ff              MOVS     r1,#0xff
000024  20c8              MOVS     r0,#0xc8
000026  f7fffffe          BL       LCD_DrawGrid
                  |L8.42|
;;;68         
;;;69         // (????????,????)
;;;70         // TFT_DrawLine(0, 160, 240, 160, RED);
;;;71         // TFT_DrawLine(120, 0, 120, 320, RED);
;;;72     
;;;73         while(1)
;;;74         {
;;;75             ADC_Conversion();  // ADC ??
00002a  f7fffffe          BL       ADC_Conversion
;;;76     
;;;77             Sys_Scan();        // ????
00002e  f7fffffe          BL       Sys_Scan
;;;78             key_Get();
000032  f7fffffe          BL       key_Get
000036  e7f8              B        |L8.42|
;;;79     
;;;80             // ??????(????)
;;;81            
;;;82         }
;;;83     }
;;;84     
                          ENDP

                  |L8.56|
                          DCD      0x000003bd

                          AREA ||i.screen_init||, CODE, READONLY, ALIGN=1

                  screen_init PROC
;;;92     
;;;93     void screen_init()//屏幕初始化
000000  b508              PUSH     {r3,lr}
;;;94     {
;;;95     	Lcd_Init();
000002  f7fffffe          BL       Lcd_Init
;;;96     	LCD_Fill ( 1, 1, 320, 240, BLACK );//本来是花屏，刷新后为白屏
000006  2000              MOVS     r0,#0
000008  22ff              MOVS     r2,#0xff
00000a  2101              MOVS     r1,#1
00000c  9000              STR      r0,[sp,#0]
00000e  23f0              MOVS     r3,#0xf0
000010  3241              ADDS     r2,r2,#0x41
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       LCD_Fill
;;;97     }
000018  bd08              POP      {r3,pc}
;;;98     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART3_RxPacket
                          %        100
                  UART3_RxString
                          %        100

                          AREA ||.data||, DATA, ALIGN=1

                  RxState
000000  00                DCB      0x00
                  pRxPacket
000001  00                DCB      0x00
                  |symbol_number.33|
000002  00                DCB      0x00
                  |symbol_number.34|
000003  00                DCB      0x00
                  ADC_Flag
000004  00                DCB      0x00
                  UART3_RxFlag
000005  00                DCB      0x00
                  key_count
000006  0000              DCB      0x00,0x00
                  AD1
000008  0000              DCB      0x00,0x00
                  AD2
00000a  0000              DCB      0x00,0x00
                  AD3
00000c  0000              DCB      0x00,0x00
                  AD4
00000e  0000              DCB      0x00,0x00
                  AD5
000010  0000              DCB      0x00,0x00
                  AD6
000012  0000              DCB      0x00,0x00
                  AD7
000014  0000              DCB      0x00,0x00
                  AD8
000016  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_main____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REVSH|
#line 478
|__asm___6_main_c_main____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
