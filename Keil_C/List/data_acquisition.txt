; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\data_acquisition.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\data_acquisition.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -ID:\STM32\ARM\PACK\Keil\SC32F1xxx_DFP\1.1.5\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=540 -DSC32R803 --omf_browse=..\output\data_acquisition.crf ..\User\Data_Acquisition.c]
                          THUMB

                          AREA ||i.Data_Acquisition_Init||, CODE, READONLY, ALIGN=2

                  Data_Acquisition_Init PROC
;;;9      
;;;10     void Data_Acquisition_Init(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;11     {
000002  b08d              SUB      sp,sp,#0x34
;;;12         GPIO_InitTypeDef GPIO_InitStructure;
;;;13         ADC_InitTypeDef  ADC_InitStructure;
;;;14         DMA_InitTypeDef  DMA_InitStructure;
;;;15     
;;;16         // ---------------- 1. 开启时钟 ----------------
;;;17         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;18         // ADC 和 GPIO 时钟通常默认开启或由内部电路自动管理
;;;19         // 如果需要显式开启，请查阅 sc32f1xxx_rcc.h 确认宏定义
;;;20     
;;;21         // ---------------- 2. GPIO 配置 ----------------
;;;22         // 手动初始化结构体
;;;23         GPIO_InitStructure.GPIO_DriveLevel = GPIO_DriveLevel_0; 
00000c  2400              MOVS     r4,#0
00000e  4668              MOV      r0,sp
000010  8604              STRH     r4,[r0,#0x30]
;;;24         GPIO_InitStructure.GPIO_Pin  = DAQ_CH1_PIN | DAQ_CH2_PIN;
000012  2103              MOVS     r1,#3
000014  8581              STRH     r1,[r0,#0x2c]
;;;25         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_HI; // 高阻输入
000016  85c4              STRH     r4,[r0,#0x2e]
;;;26         GPIO_Init(DAQ_CH1_GPIO_PORT, &GPIO_InitStructure);
000018  a90b              ADD      r1,sp,#0x2c
00001a  482b              LDR      r0,|L1.200|
00001c  f7fffffe          BL       GPIO_Init
;;;27     
;;;28         // ---------------- 3. DMA 配置 ----------------
;;;29         DMA_DeInit(DMA0);
000020  4d2a              LDR      r5,|L1.204|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DMA_DeInit
;;;30         DMA_StructInit(&DMA_InitStructure);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       DMA_StructInit
;;;31         
;;;32         DMA_InitStructure.DMA_SrcAddress = (uint32_t)&(ADC->ADC_VALUE);
00002e  4828              LDR      r0,|L1.208|
000030  9005              STR      r0,[sp,#0x14]
;;;33         DMA_InitStructure.DMA_DstAddress = (uint32_t)&Acq_Data.Buffer[0];
000032  4828              LDR      r0,|L1.212|
000034  9006              STR      r0,[sp,#0x18]
;;;34         DMA_InitStructure.DMA_BufferSize = DAQ_SAMPLE_DEPTH;
000036  20ff              MOVS     r0,#0xff
000038  30f5              ADDS     r0,r0,#0xf5
00003a  9003              STR      r0,[sp,#0xc]
;;;35         DMA_InitStructure.DMA_SourceMode = DMA_SourceMode_FIXED;
00003c  4668              MOV      r0,sp
00003e  8104              STRH     r4,[r0,#8]
;;;36         DMA_InitStructure.DMA_TargetMode = DMA_TargetMode_INC;
000040  15a9              ASRS     r1,r5,#22
000042  80c1              STRH     r1,[r0,#6]
;;;37         DMA_InitStructure.DMA_DataSize   = DMA_DataSize_HalfWord;
000044  2104              MOVS     r1,#4
000046  8081              STRH     r1,[r0,#4]
;;;38         
;;;39         // 触发源：ADC
;;;40         // 如果 sc32f1xxx_dma.h 中没有 DMA_Request_ADC，请尝试用 0 代替
;;;41         DMA_InitStructure.DMA_Request = DMA_Request_ADC; 
000048  203b              MOVS     r0,#0x3b
00004a  0600              LSLS     r0,r0,#24
00004c  9004              STR      r0,[sp,#0x10]
;;;42         
;;;43         DMA_InitStructure.DMA_CircularMode = DMA_CircularMode_Disable;
00004e  4668              MOV      r0,sp
000050  8044              STRH     r4,[r0,#2]
;;;44         // 注意：优先级宏通常为全大写
;;;45         DMA_InitStructure.DMA_Priority = DMA_Priority_HIGH; 
000052  2102              MOVS     r1,#2
000054  8001              STRH     r1,[r0,#0]
;;;46         
;;;47         DMA_Init(DMA0, &DMA_InitStructure);
000056  4669              MOV      r1,sp
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       DMA_Init
;;;48     
;;;49         // 开启 DMA 传输完成中断
;;;50         DMA_ITConfig(DMA0, DMA_IT_TCIE, ENABLE);
00005e  2201              MOVS     r2,#1
000060  0451              LSLS     r1,r2,#17
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       DMA_ITConfig
000068  481b              LDR      r0,|L1.216|
00006a  14ee              ASRS     r6,r5,#19
00006c  6006              STR      r6,[r0,#0]
00006e  481b              LDR      r0,|L1.220|
000070  6801              LDR      r1,[r0,#0]
000072  0209              LSLS     r1,r1,#8
000074  0a09              LSRS     r1,r1,#8
000076  6001              STR      r1,[r0,#0]
;;;51         
;;;52         // 使用 CMSIS 标准函数配置中断
;;;53         NVIC_EnableIRQ(DMA0_IRQn); 
;;;54         NVIC_SetPriority(DMA0_IRQn, 0);
;;;55     
;;;56         // ---------------- 4. ADC 配置 ----------------
;;;57         ADC_DeInit(ADC);
000078  4f15              LDR      r7,|L1.208|
00007a  3f08              SUBS     r7,r7,#8
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       ADC_DeInit
;;;58         ADC_StructInit(&ADC_InitStructure);
000082  a807              ADD      r0,sp,#0x1c
000084  f7fffffe          BL       ADC_StructInit
;;;59         
;;;60         ADC_InitStructure.ADC_ConvMode = ADC_ConvMode_Continuous; 
000088  4668              MOV      r0,sp
00008a  8506              STRH     r6,[r0,#0x28]
;;;61         // 修正：使用库文件中确认存在的宏 ADC_Prescaler_3CLOCK (分频系数为3)
;;;62         // 如果需要更慢的速度，可以尝试 ADC_Prescaler_8CLOCK
;;;63         ADC_InitStructure.ADC_Prescaler = ADC_Prescaler_3CLOCK; 
00008c  01f0              LSLS     r0,r6,#7
00008e  9007              STR      r0,[sp,#0x1c]
;;;64         ADC_InitStructure.ADC_VREF = ADC_VREF_VDD;
000090  9409              STR      r4,[sp,#0x24]
;;;65         ADC_InitStructure.ADC_EAIN = DAQ_CH1_ADC_CH;
000092  9408              STR      r4,[sp,#0x20]
;;;66         
;;;67         ADC_Init(ADC, &ADC_InitStructure);
000094  a907              ADD      r1,sp,#0x1c
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       ADC_Init
;;;68         ADC_SetChannel(ADC, DAQ_CH1_ADC_CH);
00009c  2100              MOVS     r1,#0
00009e  4638              MOV      r0,r7
0000a0  f7fffffe          BL       ADC_SetChannel
;;;69         ADC_DMACmd(ADC, ENABLE);
0000a4  2101              MOVS     r1,#1
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       ADC_DMACmd
;;;70     
;;;71         // ---------------- 5. 启动 ----------------
;;;72         DMA_Cmd(DMA0, ENABLE);
0000ac  2101              MOVS     r1,#1
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       DMA_Cmd
;;;73         ADC_Cmd(ADC, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  4638              MOV      r0,r7
0000b8  f7fffffe          BL       ADC_Cmd
;;;74         ADC_SoftwareStartConv(ADC);
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       ADC_SoftwareStartConv
;;;75     }
0000c2  b00d              ADD      sp,sp,#0x34
0000c4  bdf0              POP      {r4-r7,pc}
;;;76     
                          ENDP

0000c6  0000              DCW      0x0000
                  |L1.200|
                          DCD      0x40011000
                  |L1.204|
                          DCD      0x40010800
                  |L1.208|
                          DCD      0x40022118
                  |L1.212|
                          DCD      ||.bss||
                  |L1.216|
                          DCD      0xe000e100
                  |L1.220|
                          DCD      0xe000e408

                          AREA ||i.Data_Acquisition_Start_Next||, CODE, READONLY, ALIGN=2

                  Data_Acquisition_Start_Next PROC
;;;76     
;;;77     void Data_Acquisition_Start_Next(void)
000000  b570              PUSH     {r4-r6,lr}
;;;78     {
;;;79         if(Acq_Done_Flag == 1)
000002  4813              LDR      r0,|L2.80|
000004  7801              LDRB     r1,[r0,#0]  ; Acq_Done_Flag
000006  2901              CMP      r1,#1
000008  d120              BNE      |L2.76|
;;;80         {
;;;81             Acq_Done_Flag = 0;
00000a  2100              MOVS     r1,#0
00000c  7001              STRB     r1,[r0,#0]
;;;82             Current_Ch_Index = 0;
00000e  7041              STRB     r1,[r0,#1]
;;;83     
;;;84             ADC_SetChannel(ADC, DAQ_CH1_ADC_CH);
000010  4c10              LDR      r4,|L2.84|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_SetChannel
;;;85     
;;;86             DMA_Cmd(DMA0, DISABLE);
000018  4d0f              LDR      r5,|L2.88|
00001a  2100              MOVS     r1,#0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       DMA_Cmd
;;;87             DMA_SetDstAddress(DMA0, (uint32_t)&Acq_Data.Buffer[0]);
000022  490e              LDR      r1,|L2.92|
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       DMA_SetDstAddress
;;;88             DMA_SetCurrDataCounter(DMA0, DAQ_SAMPLE_DEPTH);
00002a  21ff              MOVS     r1,#0xff
00002c  31f5              ADDS     r1,r1,#0xf5
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       DMA_SetCurrDataCounter
;;;89             DMA_Cmd(DMA0, ENABLE);
000034  2101              MOVS     r1,#1
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       DMA_Cmd
;;;90     
;;;91             // 如果 ADC 还在运行则不需要这句，但加上更保险
;;;92             if((ADC->ADC_CON & ADC_CON_ADCS) == 0) {
00003c  4905              LDR      r1,|L2.84|
00003e  3910              SUBS     r1,r1,#0x10
000040  6909              LDR      r1,[r1,#0x10]
000042  0609              LSLS     r1,r1,#24
000044  d402              BMI      |L2.76|
;;;93                  ADC_SoftwareStartConv(ADC);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       ADC_SoftwareStartConv
                  |L2.76|
;;;94             }
;;;95         }
;;;96     }
00004c  bd70              POP      {r4-r6,pc}
;;;97     
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      ||.data||
                  |L2.84|
                          DCD      0x40022110
                  |L2.88|
                          DCD      0x40010800
                  |L2.92|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Acq_Data
                          %        2000

                          AREA ||.data||, DATA, ALIGN=0

                  Acq_Done_Flag
000000  00                DCB      0x00
                  Current_Ch_Index
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\User\\Data_Acquisition.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_Data_Acquisition_c_a4d46a4d____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___18_Data_Acquisition_c_a4d46a4d____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_Data_Acquisition_c_a4d46a4d____REVSH|
#line 478
|__asm___18_Data_Acquisition_c_a4d46a4d____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
