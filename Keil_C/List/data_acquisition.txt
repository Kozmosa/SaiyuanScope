; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\Data_Acquisition.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\Data_Acquisition.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\Data_Acquisition.crf ..\User\Data_Acquisition.c]
                          THUMB

                          AREA ||i.DMA0_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA0_IRQHandler PROC
;;;121    // =================================================================
;;;122    void DMA0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
;;;124        if(DMA_GetFlagStatus(DMA0, DMA_FLAG_TCIF) == SET)
000002  4d1d              LDR      r5,|L1.120|
000004  2102              MOVS     r1,#2
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       DMA_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d12e              BNE      |L1.110|
;;;125        {
;;;126            DMA_ClearFlag(DMA0, DMA_FLAG_TCIF); 
000010  2102              MOVS     r1,#2
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       DMA_ClearFlag
;;;127            Debug_ISR_Count++; 
000018  4c18              LDR      r4,|L1.124|
00001a  6861              LDR      r1,[r4,#4]  ; Debug_ISR_Count
00001c  1c49              ADDS     r1,r1,#1
00001e  6061              STR      r1,[r4,#4]  ; Debug_ISR_Count
;;;128    
;;;129            DMA_Cmd(DMA0, DISABLE);
000020  2100              MOVS     r1,#0
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DMA_Cmd
;;;130            
;;;131            // 关键：清除 ADC 标志，防止下次无法启动
;;;132            ADC_ClearFlag(ADC, ADC_Flag_ADCIF);
000028  4e15              LDR      r6,|L1.128|
00002a  2101              MOVS     r1,#1
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       ADC_ClearFlag
;;;133    
;;;134            Current_Ch_Index++;
000032  7860              LDRB     r0,[r4,#1]  ; Current_Ch_Index
000034  1c40              ADDS     r0,r0,#1
000036  7060              STRB     r0,[r4,#1]
;;;135    
;;;136            if(Current_Ch_Index < DAQ_SAMPLE_DEPTH) 
000038  7860              LDRB     r0,[r4,#1]  ; Current_Ch_Index
00003a  2808              CMP      r0,#8
00003c  d218              BCS      |L1.112|
;;;137            {
;;;138                ADC_SetChannel(ADC, Channel_List[Current_Ch_Index]);
00003e  4811              LDR      r0,|L1.132|
000040  7861              LDRB     r1,[r4,#1]  ; Current_Ch_Index
000042  5c41              LDRB     r1,[r0,r1]
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       ADC_SetChannel
;;;139                DMA_SetDstAddress(DMA0, (uint32_t)&Acq_Data.Buffer[Current_Ch_Index]);
00004a  7860              LDRB     r0,[r4,#1]  ; Current_Ch_Index
00004c  490e              LDR      r1,|L1.136|
00004e  0040              LSLS     r0,r0,#1
000050  1841              ADDS     r1,r0,r1
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       DMA_SetDstAddress
;;;140                DMA_SetCurrDataCounter(DMA0, 1); 
000058  2101              MOVS     r1,#1
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       DMA_SetCurrDataCounter
;;;141                DMA_Cmd(DMA0, ENABLE);
000060  2101              MOVS     r1,#1
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       DMA_Cmd
;;;142                ADC_SoftwareStartConv(ADC);
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       ADC_SoftwareStartConv
                  |L1.110|
;;;143            }
;;;144            else
;;;145            {
;;;146                Acq_Done_Flag = 1; 
;;;147            }
;;;148        }
;;;149    }
00006e  bd70              POP      {r4-r6,pc}
                  |L1.112|
000070  2001              MOVS     r0,#1                 ;146
000072  7020              STRB     r0,[r4,#0]            ;146
000074  bd70              POP      {r4-r6,pc}
                          ENDP

000076  0000              DCW      0x0000
                  |L1.120|
                          DCD      0x40010800
                  |L1.124|
                          DCD      ||.data||
                  |L1.128|
                          DCD      0x40022110
                  |L1.132|
                          DCD      ||.constdata||
                  |L1.136|
                          DCD      ||.bss||

                          AREA ||i.Data_Acquisition_Init||, CODE, READONLY, ALIGN=2

                  Data_Acquisition_Init PROC
;;;25     
;;;26     void Data_Acquisition_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;27     {
000002  b08e              SUB      sp,sp,#0x38
;;;28         GPIO_InitTypeDef GPIO_InitStructure;
;;;29         ADC_InitTypeDef  ADC_InitStructure;
;;;30         DMA_InitTypeDef  DMA_InitStructure;
;;;31     
;;;32         // 1. 开启时钟
;;;33         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;34     
;;;35     
;;;36         // 2. GPIO 配置
;;;37         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_HI; 
00000c  2400              MOVS     r4,#0
00000e  4668              MOV      r0,sp
000010  8644              STRH     r4,[r0,#0x32]
;;;38         GPIO_InitStructure.GPIO_DriveLevel = GPIO_DriveLevel_0;
000012  8684              STRH     r4,[r0,#0x34]
;;;39         GPIO_InitStructure.GPIO_Pin = DAQ_CH1_PIN | DAQ_CH2_PIN; 
000014  2603              MOVS     r6,#3
000016  8606              STRH     r6,[r0,#0x30]
;;;40         GPIO_Init(DAQ_CH1_GPIO_PORT, &GPIO_InitStructure);
000018  a90c              ADD      r1,sp,#0x30
00001a  482a              LDR      r0,|L2.196|
00001c  f7fffffe          BL       GPIO_Init
;;;41     
;;;42         // 3. DMA 配置 (使用 DMA0)
;;;43         DMA_DeInit(DMA0);
000020  4d29              LDR      r5,|L2.200|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DMA_DeInit
;;;44         DMA_StructInit(&DMA_InitStructure);
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       DMA_StructInit
;;;45         
;;;46         // 源地址 & 目标地址
;;;47         DMA_InitStructure.DMA_SrcAddress = (uint32_t)&(ADC->ADC_VALUE); 
00002e  4827              LDR      r0,|L2.204|
000030  9006              STR      r0,[sp,#0x18]
;;;48         DMA_InitStructure.DMA_DstAddress = (uint32_t)&Acq_Data.Buffer[0];
000032  4827              LDR      r0,|L2.208|
000034  9007              STR      r0,[sp,#0x1c]
;;;49         
;;;50         // 基础配置
;;;51         DMA_InitStructure.DMA_BufferSize = 1;                    
000036  2001              MOVS     r0,#1
000038  9004              STR      r0,[sp,#0x10]
;;;52         DMA_InitStructure.DMA_SourceMode = DMA_SourceMode_FIXED; 
00003a  4668              MOV      r0,sp
00003c  8184              STRH     r4,[r0,#0xc]
;;;53         DMA_InitStructure.DMA_TargetMode = DMA_TargetMode_FIXED; 
00003e  8144              STRH     r4,[r0,#0xa]
;;;54         DMA_InitStructure.DMA_DataSize   = DMA_DataSize_HalfWord;
000040  2104              MOVS     r1,#4
000042  8101              STRH     r1,[r0,#8]
;;;55         
;;;56         // 【重点】使用移位后的 59
;;;57         DMA_InitStructure.DMA_Request    = ADC_DMA_REQ_SRC;      
000044  203b              MOVS     r0,#0x3b
000046  0100              LSLS     r0,r0,#4
000048  9005              STR      r0,[sp,#0x14]
;;;58         
;;;59         DMA_InitStructure.DMA_CircularMode = DMA_CircularMode_Disable;
00004a  4668              MOV      r0,sp
00004c  80c4              STRH     r4,[r0,#6]
;;;60         DMA_InitStructure.DMA_Priority   = DMA_Priority_VERY_HIGH;
00004e  8086              STRH     r6,[r0,#4]
;;;61         
;;;62         DMA_Init(DMA0, &DMA_InitStructure);
000050  a901              ADD      r1,sp,#4
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       DMA_Init
;;;63     
;;;64         // 4. DMA 中断配置
;;;65         // SC32 手册：DMA0 对应中断号 11 (请确保 startup 文件里是 DMA0_IRQHandler)
;;;66         DMA_ITConfig(DMA0, DMA_IT_TCIE, ENABLE);
000058  2201              MOVS     r2,#1
00005a  0451              LSLS     r1,r2,#17
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       DMA_ITConfig
000062  491c              LDR      r1,|L2.212|
000064  6808              LDR      r0,[r1,#0]
000066  0200              LSLS     r0,r0,#8
000068  0a00              LSRS     r0,r0,#8
00006a  6008              STR      r0,[r1,#0]
00006c  491a              LDR      r1,|L2.216|
00006e  14e8              ASRS     r0,r5,#19
000070  6008              STR      r0,[r1,#0]
;;;67         NVIC_SetPriority(DMA0_IRQn, 0); 
;;;68         NVIC_EnableIRQ(DMA0_IRQn);
;;;69     
;;;70         // 5. ADC 配置
;;;71         ADC_DeInit(ADC);
000072  4e16              LDR      r6,|L2.204|
000074  3e08              SUBS     r6,r6,#8
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       ADC_DeInit
;;;72         ADC_StructInit(&ADC_InitStructure);
00007c  a808              ADD      r0,sp,#0x20
00007e  f7fffffe          BL       ADC_StructInit
;;;73         ADC_InitStructure.ADC_ConvMode = ADC_ConvMode_Single; 
000082  4668              MOV      r0,sp
000084  8584              STRH     r4,[r0,#0x2c]
;;;74         ADC_InitStructure.ADC_Prescaler = ADC_Prescaler_3CLOCK; 
000086  2001              MOVS     r0,#1
000088  0480              LSLS     r0,r0,#18
00008a  9008              STR      r0,[sp,#0x20]
;;;75         ADC_InitStructure.ADC_VREF = ADC_VREF_VDD;
00008c  940a              STR      r4,[sp,#0x28]
;;;76         ADC_InitStructure.ADC_EAIN = Channel_List[0];
00008e  9409              STR      r4,[sp,#0x24]
;;;77         ADC_Init(ADC, &ADC_InitStructure);
000090  a908              ADD      r1,sp,#0x20
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       ADC_Init
;;;78         
;;;79         // 6. 启动配置
;;;80         ADC_SetChannel(ADC, Channel_List[0]);
000098  2100              MOVS     r1,#0
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       ADC_SetChannel
;;;81         
;;;82         // 【重点】手册里说 "59: ADCCON->DMAEN"
;;;83         // 这意味着 ADC 这一侧的 DMA 开关必须打开
;;;84         ADC_DMACmd(ADC, ENABLE); 
0000a0  2101              MOVS     r1,#1
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       ADC_DMACmd
;;;85         
;;;86         // 双重保险：强制置位 ADC_IDE 寄存器的 DMAEN 位 (通常是 bit 0)
;;;87         // 如果你的头文件里没有 ADC_IDE，可能是 ADC_CON 的某个位，ADC_DMACmd 函数应该已经处理了
;;;88         // ADC->ADC_IDE |= 0x01; 
;;;89     
;;;90         // 开启 DMA
;;;91         DMA_Cmd(DMA0, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       DMA_Cmd
;;;92         // 开启 ADC
;;;93         ADC_Cmd(ADC, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       ADC_Cmd
;;;94         
;;;95         // 触发转换
;;;96         ADC_SoftwareStartConv(ADC);
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       ADC_SoftwareStartConv
;;;97     }
0000be  b00e              ADD      sp,sp,#0x38
0000c0  bd70              POP      {r4-r6,pc}
;;;98     
                          ENDP

0000c2  0000              DCW      0x0000
                  |L2.196|
                          DCD      0x40011000
                  |L2.200|
                          DCD      0x40010800
                  |L2.204|
                          DCD      0x40022118
                  |L2.208|
                          DCD      ||.bss||
                  |L2.212|
                          DCD      0xe000e408
                  |L2.216|
                          DCD      0xe000e100

                          AREA ||i.Data_Acquisition_Start_Next||, CODE, READONLY, ALIGN=2

                  Data_Acquisition_Start_Next PROC
;;;98     
;;;99     void Data_Acquisition_Start_Next(void)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
;;;101        if(Acq_Done_Flag == 1)
000002  4810              LDR      r0,|L3.68|
000004  7801              LDRB     r1,[r0,#0]  ; Acq_Done_Flag
000006  2901              CMP      r1,#1
000008  d11a              BNE      |L3.64|
;;;102        {
;;;103            Acq_Done_Flag = 0;
00000a  2100              MOVS     r1,#0
00000c  7001              STRB     r1,[r0,#0]
;;;104            Current_Ch_Index = 0;
00000e  7041              STRB     r1,[r0,#1]
;;;105    
;;;106            ADC_SetChannel(ADC, Channel_List[0]);
000010  4c0d              LDR      r4,|L3.72|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_SetChannel
;;;107    
;;;108            DMA_Cmd(DMA0, DISABLE);
000018  4d0c              LDR      r5,|L3.76|
00001a  2100              MOVS     r1,#0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       DMA_Cmd
;;;109            DMA_SetDstAddress(DMA0, (uint32_t)&Acq_Data.Buffer[0]);
000022  490b              LDR      r1,|L3.80|
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       DMA_SetDstAddress
;;;110            DMA_SetCurrDataCounter(DMA0, 1);
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       DMA_SetCurrDataCounter
;;;111            DMA_Cmd(DMA0, ENABLE);
000032  2101              MOVS     r1,#1
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       DMA_Cmd
;;;112    
;;;113            // 再次触发
;;;114            ADC_SoftwareStartConv(ADC);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       ADC_SoftwareStartConv
                  |L3.64|
;;;115        }
;;;116    }
000040  bd70              POP      {r4-r6,pc}
;;;117    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      ||.data||
                  |L3.72|
                          DCD      0x40022110
                  |L3.76|
                          DCD      0x40010800
                  |L3.80|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Acq_Data
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Channel_List
000000  00010a0b          DCB      0x00,0x01,0x0a,0x0b
000004  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f

                          AREA ||.data||, DATA, ALIGN=2

                  Acq_Done_Flag
000000  00                DCB      0x00
                  Current_Ch_Index
000001  000000            DCB      0x00,0x00,0x00
                  Debug_ISR_Count
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\User\\Data_Acquisition.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_Data_Acquisition_c_a4d46a4d____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___18_Data_Acquisition_c_a4d46a4d____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_Data_Acquisition_c_a4d46a4d____REVSH|
#line 478
|__asm___18_Data_Acquisition_c_a4d46a4d____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
