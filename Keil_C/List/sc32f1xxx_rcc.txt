; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_rcc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_rcc.d --cpu=Cortex-M0+ --apcs=interwork -O1 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\Drivers -I..\Apps -I..\CMSIS -I..\User -D__UVISION_VERSION=536 -DSC32R803 --omf_browse=..\Output\sc32f1xxx_rcc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;771      */
;;;772    void RCC_AHBPeriphClockCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  4a05              LDR      r2,|L1.24|
;;;773    {
;;;774        /* Check the parameters */
;;;775        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;776    
;;;777        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L1.14|
;;;778        {
;;;779            RCCAHB->AHB_CFG |= RCC_AHBPeriph;
000006  6811              LDR      r1,[r2,#0]
000008  4301              ORRS     r1,r1,r0
00000a  6011              STR      r1,[r2,#0]
;;;780        }
;;;781        else
;;;782        {
;;;783            RCCAHB->AHB_CFG &= ~RCC_AHBPeriph;
;;;784        }
;;;785    }
00000c  4770              BX       lr
                  |L1.14|
00000e  6811              LDR      r1,[r2,#0]            ;783
000010  4381              BICS     r1,r1,r0              ;783
000012  6011              STR      r1,[r2,#0]            ;783
000014  4770              BX       lr
;;;786    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x40003000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;916     */
;;;917    void RCC_AHBPeriphResetCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  4a05              LDR      r2,|L2.24|
;;;918    {
;;;919        /* Check the parameters */
;;;920        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;921    
;;;922        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L2.14|
;;;923        {
;;;924            RCCAHB->AHB_RST |= RCC_AHBPeriph;
000006  6851              LDR      r1,[r2,#4]
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;925        }
;;;926        else
;;;927        {
;;;928            RCCAHB->AHB_RST &= ~RCC_AHBPeriph;
;;;929        }
;;;930    }
00000c  4770              BX       lr
                  |L2.14|
00000e  6851              LDR      r1,[r2,#4]            ;928
000010  4381              BICS     r1,r1,r0              ;928
000012  6051              STR      r1,[r2,#4]            ;928
000014  4770              BX       lr
;;;931    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x40003000

                          AREA ||i.RCC_APB0Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0Cmd PROC
;;;273      */
;;;274    void RCC_APB0Cmd ( FunctionalState NewState )
000000  4905              LDR      r1,|L3.24|
;;;275    {
;;;276        /* Check the parameters */
;;;277        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;278    
;;;279        if ( NewState != DISABLE )
;;;280        {
;;;281            RCCAPB0->APB0_CFG |= APB0_CFG_ENAPB;
000002  018a              LSLS     r2,r1,#6
000004  2800              CMP      r0,#0                 ;279
000006  d003              BEQ      |L3.16|
000008  6808              LDR      r0,[r1,#0]
00000a  4310              ORRS     r0,r0,r2
00000c  6008              STR      r0,[r1,#0]
;;;282        }
;;;283        else
;;;284        {
;;;285            RCCAPB0->APB0_CFG &= ~APB0_CFG_ENAPB;
;;;286        }
;;;287    }
00000e  4770              BX       lr
                  |L3.16|
000010  6808              LDR      r0,[r1,#0]            ;285
000012  4390              BICS     r0,r0,r2              ;285
000014  6008              STR      r0,[r1,#0]            ;285
000016  4770              BX       lr
;;;288    
                          ENDP

                  |L3.24|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0Config||, CODE, READONLY, ALIGN=2

                  RCC_APB0Config PROC
;;;539     */
;;;540    void RCC_APB0Config ( RCC_PCLK_TypeDef RCC_APB0CLK )
000000  4904              LDR      r1,|L4.20|
;;;541    {
;;;542        /* Check the parameters */
;;;543        assert_param ( IS_RCC_PCLK ( RCC_APB0CLK ) );
;;;544    
;;;545        RCCAPB0->APB0_CFG &= ~ ( ( uint32_t ) APB0_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;546        RCCAPB0->APB0_CFG |= RCC_APB0CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;547    }
000012  4770              BX       lr
;;;548    
                          ENDP

                  |L4.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphClockCmd PROC
;;;811      */
;;;812    void RCC_APB0PeriphClockCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  4a05              LDR      r2,|L5.24|
;;;813    {
;;;814        /* Check the parameters */
;;;815        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;816    
;;;817        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L5.14|
;;;818        {
;;;819            RCCAPB0->APB0_CFG |= RCC_APB0Periph;
000006  6811              LDR      r1,[r2,#0]
000008  4301              ORRS     r1,r1,r0
00000a  6011              STR      r1,[r2,#0]
;;;820        }
;;;821        else
;;;822        {
;;;823            RCCAPB0->APB0_CFG &= ~RCC_APB0Periph;
;;;824        }
;;;825    }
00000c  4770              BX       lr
                  |L5.14|
00000e  6811              LDR      r1,[r2,#0]            ;823
000010  4381              BICS     r1,r1,r0              ;823
000012  6011              STR      r1,[r2,#0]            ;823
000014  4770              BX       lr
;;;826    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphResetCmd PROC
;;;956     */
;;;957    void RCC_APB0PeriphResetCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  4a05              LDR      r2,|L6.24|
;;;958    {
;;;959        /* Check the parameters */
;;;960        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;961    
;;;962        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L6.14|
;;;963        {
;;;964            RCCAPB0->APB0_RST |= RCC_APB0Periph;
000006  6851              LDR      r1,[r2,#4]
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;965        }
;;;966        else
;;;967        {
;;;968            RCCAPB0->APB0_RST &= ~RCC_APB0Periph;
;;;969        }
;;;970    }
00000c  4770              BX       lr
                  |L6.14|
00000e  6851              LDR      r1,[r2,#4]            ;968
000010  4381              BICS     r1,r1,r0              ;968
000012  6051              STR      r1,[r2,#4]            ;968
000014  4770              BX       lr
;;;971    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40020000

                          AREA ||i.RCC_APB1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1Cmd PROC
;;;295      */
;;;296    void RCC_APB1Cmd ( FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;297    {
;;;298        /* Check the parameters */
;;;299        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;300    
;;;301        if ( NewState != DISABLE )
;;;302        {
;;;303            RCCAPB1->APB1_CFG |= APB1_CFG_ENAPB;
000002  4906              LDR      r1,|L7.28|
000004  05d2              LSLS     r2,r2,#23
000006  2800              CMP      r0,#0                 ;301
000008  d003              BEQ      |L7.18|
00000a  6808              LDR      r0,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;304        }
;;;305        else
;;;306        {
;;;307            RCCAPB1->APB1_CFG &= ~APB1_CFG_ENAPB;
;;;308        }
;;;309    }
000010  4770              BX       lr
                  |L7.18|
000012  6808              LDR      r0,[r1,#0]            ;307
000014  4390              BICS     r0,r0,r2              ;307
000016  6008              STR      r0,[r1,#0]            ;307
000018  4770              BX       lr
;;;310    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1Config||, CODE, READONLY, ALIGN=2

                  RCC_APB1Config PROC
;;;561     */
;;;562    void RCC_APB1Config ( RCC_PCLK_TypeDef RCC_APB1CLK )
000000  4904              LDR      r1,|L8.20|
;;;563    {
;;;564        /* Check the parameters */
;;;565        assert_param ( IS_RCC_PCLK ( RCC_APB1CLK ) );
;;;566    
;;;567        RCCAPB1->APB1_CFG &= ~ ( ( uint32_t ) APB1_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;568        RCCAPB1->APB1_CFG |= RCC_APB1CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;569    }
000012  4770              BX       lr
;;;570    
                          ENDP

                  |L8.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;850      */
;;;851    void RCC_APB1PeriphClockCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  4a05              LDR      r2,|L9.24|
;;;852    {
;;;853        /* Check the parameters */
;;;854        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;855    
;;;856        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L9.14|
;;;857        {
;;;858            RCCAPB1->APB1_CFG |= RCC_APB1Periph;
000006  6811              LDR      r1,[r2,#0]
000008  4301              ORRS     r1,r1,r0
00000a  6011              STR      r1,[r2,#0]
;;;859        }
;;;860        else
;;;861        {
;;;862            RCCAPB1->APB1_CFG &= ~RCC_APB1Periph;
;;;863        }
;;;864    }
00000c  4770              BX       lr
                  |L9.14|
00000e  6811              LDR      r1,[r2,#0]            ;862
000010  4381              BICS     r1,r1,r0              ;862
000012  6011              STR      r1,[r2,#0]            ;862
000014  4770              BX       lr
;;;865    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;995     */
;;;996    void RCC_APB1PeriphResetCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  4a05              LDR      r2,|L10.24|
;;;997    {
;;;998        /* Check the parameters */
;;;999        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;1000   
;;;1001       if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L10.14|
;;;1002       {
;;;1003           RCCAPB1->APB1_RST |= RCC_APB1Periph;
000006  6851              LDR      r1,[r2,#4]
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;1004       }
;;;1005       else
;;;1006       {
;;;1007           RCCAPB1->APB1_RST &= ~RCC_APB1Periph;
;;;1008       }
;;;1009   }
00000c  4770              BX       lr
                  |L10.14|
00000e  6851              LDR      r1,[r2,#4]            ;1007
000010  4381              BICS     r1,r1,r0              ;1007
000012  6051              STR      r1,[r2,#4]            ;1007
000014  4770              BX       lr
;;;1010   
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2Cmd PROC
;;;317      */
;;;318    void RCC_APB2Cmd ( FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;319    {
;;;320        /* Check the parameters */
;;;321        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;322    
;;;323        if ( NewState != DISABLE )
;;;324        {
;;;325            RCCAPB2->APB2_CFG |= APB2_CFG_ENAPB;
000002  4906              LDR      r1,|L11.28|
000004  05d2              LSLS     r2,r2,#23
000006  2800              CMP      r0,#0                 ;323
000008  d003              BEQ      |L11.18|
00000a  6808              LDR      r0,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;326        }
;;;327        else
;;;328        {
;;;329            RCCAPB2->APB2_CFG &= ~APB2_CFG_ENAPB;
;;;330        }
;;;331    }
000010  4770              BX       lr
                  |L11.18|
000012  6808              LDR      r0,[r1,#0]            ;329
000014  4390              BICS     r0,r0,r2              ;329
000016  6008              STR      r0,[r1,#0]            ;329
000018  4770              BX       lr
;;;332    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2Config||, CODE, READONLY, ALIGN=2

                  RCC_APB2Config PROC
;;;583     */
;;;584    void RCC_APB2Config ( RCC_PCLK_TypeDef RCC_APB2CLK )
000000  4904              LDR      r1,|L12.20|
;;;585    {
;;;586        /* Check the parameters */
;;;587        assert_param ( IS_RCC_PCLK ( RCC_APB2CLK ) );
;;;588    
;;;589        RCCAPB2->APB2_CFG &= ~ ( ( uint32_t ) APB2_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;590        RCCAPB2->APB2_CFG |= RCC_APB2CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;591    }
000012  4770              BX       lr
;;;592    
                          ENDP

                  |L12.20|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;884      */
;;;885    void RCC_APB2PeriphClockCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  4a05              LDR      r2,|L13.24|
;;;886    {
;;;887        /* Check the parameters */
;;;888        assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;889    
;;;890        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L13.14|
;;;891        {
;;;892            RCCAPB2->APB2_CFG |= RCC_APB2Periph;
000006  6811              LDR      r1,[r2,#0]
000008  4301              ORRS     r1,r1,r0
00000a  6011              STR      r1,[r2,#0]
;;;893        }
;;;894        else
;;;895        {
;;;896            RCCAPB2->APB2_CFG &= ~RCC_APB2Periph;
;;;897        }
;;;898    }
00000c  4770              BX       lr
                  |L13.14|
00000e  6811              LDR      r1,[r2,#0]            ;896
000010  4381              BICS     r1,r1,r0              ;896
000012  6011              STR      r1,[r2,#0]            ;896
000014  4770              BX       lr
;;;899    
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1029    */
;;;1030   void RCC_APB2PeriphResetCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  4a05              LDR      r2,|L14.24|
;;;1031   {
;;;1032       /* Check the parameters */
;;;1033       assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;1034   
;;;1035       if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
000004  d003              BEQ      |L14.14|
;;;1036       {
;;;1037           RCCAPB2->APB2_RST |= RCC_APB2Periph;
000006  6851              LDR      r1,[r2,#4]
000008  4301              ORRS     r1,r1,r0
00000a  6051              STR      r1,[r2,#4]
;;;1038       }
;;;1039       else
;;;1040       {
;;;1041           RCCAPB2->APB2_RST &= ~RCC_APB2Periph;
;;;1042       }
;;;1043   }
00000c  4770              BX       lr
                  |L14.14|
00000e  6851              LDR      r1,[r2,#4]            ;1041
000010  4381              BICS     r1,r1,r0              ;1041
000012  6051              STR      r1,[r2,#4]            ;1041
000014  4770              BX       lr
;;;1044   
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40022000

                          AREA ||i.RCC_BTMCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_BTMCLKConfig PROC
;;;743     */
;;;744    void RCC_BTMCLKConfig ( RCC_BTMCLKSource_TypeDef RCC_BTMCLKSource )
000000  b500              PUSH     {lr}
;;;745    {
000002  4602              MOV      r2,r0
;;;746        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;747        /* Check the parameters */
;;;748        assert_param ( RCC_BTMCLKSOURCE ( RCC_BTMCLKSource ) );
;;;749    
;;;750        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_BTMCLKSEL );
00000a  4904              LDR      r1,|L15.28|
00000c  6988              LDR      r0,[r1,#0x18]
00000e  0840              LSRS     r0,r0,#1
000010  0040              LSLS     r0,r0,#1
000012  6188              STR      r0,[r1,#0x18]
;;;751        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_BTMCLKSource );
000014  698b              LDR      r3,[r1,#0x18]
000016  4313              ORRS     r3,r3,r2
000018  618b              STR      r3,[r1,#0x18]
;;;752    }
00001a  bd00              POP      {pc}
;;;753    
                          ENDP

                  |L15.28|
                          DCD      0x40003000

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1248    */
;;;1249   void RCC_ClearFlag ( uint32_t RCC_FLAG )
000000  4902              LDR      r1,|L16.12|
;;;1250   {
;;;1251       /* Check the parameters */
;;;1252       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1253   
;;;1254       /* Clear the flags */
;;;1255       RCC->RCC_STS |= ( uint32_t ) RCC_FLAG;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;1256   }
000008  4770              BX       lr
;;;1257   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40003000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;61      */
;;;62     void RCC_DeInit ( void )
000000  4804              LDR      r0,|L17.20|
;;;63     {
;;;64         /*	RCC Reg Unlock = 0 */
;;;65         RCC->RCC_KEY = 0x40;
000002  2140              MOVS     r1,#0x40
000004  60c1              STR      r1,[r0,#0xc]
;;;66     
;;;67         /* Reset RCC_CFG0 register */
;;;68         RCC->RCC_CFG0 = ( uint32_t ) 0x00001040;
000006  2141              MOVS     r1,#0x41
000008  0189              LSLS     r1,r1,#6
00000a  6141              STR      r1,[r0,#0x14]
;;;69     
;;;70         /* Reset RCC_CFG1 register */
;;;71         RCC->RCC_CFG1 = ( uint32_t ) 0x00000000;
00000c  2100              MOVS     r1,#0
00000e  6181              STR      r1,[r0,#0x18]
;;;72     
;;;73     #if defined(SC32f10xx)
;;;74         /* Reset PLL_CFG register */
;;;75         RCC->PLL_CFG = ( uint32_t ) 0x00000000;
;;;76     #endif
;;;77     
;;;78         /* Reset PLL_CFG register */
;;;79         RCC->NMI_CFG = ( uint32_t ) 0x00000000;
000010  62c1              STR      r1,[r0,#0x2c]
;;;80     
;;;81     }
000012  4770              BX       lr
;;;82     
                          ENDP

                  |L17.20|
                          DCD      0x40003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;598      */
;;;599    void RCC_GetClocksFreq ( RCC_ClocksTypeDef* RCC_Clocks )
000000  4a1e              LDR      r2,|L18.124|
;;;600    {
;;;601        uint32_t  tmp;
;;;602    
;;;603    #if defined(SC32f10xx)
;;;604        uint32_t  pllp, pllsource, pllm, plln;
;;;605    #endif
;;;606    
;;;607        /* Get SYSCLK source -------------------------------------------------------*/
;;;608        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
000002  6951              LDR      r1,[r2,#0x14]
000004  0609              LSLS     r1,r1,#24
000006  d402              BMI      |L18.14|
;;;609        {
;;;610    #if defined(SC32f10xx) || defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806) || defined(SC32R803) || defined(SC32f15xx)|| defined(SC32R601)
;;;611            RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE / 2;
000008  491d              LDR      r1,|L18.128|
00000a  6001              STR      r1,[r0,#0]
00000c  e01b              B        |L18.70|
                  |L18.14|
;;;612    #endif
;;;613        }
;;;614        else
;;;615        {
;;;616            switch ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL )
00000e  6951              LDR      r1,[r2,#0x14]
000010  2303              MOVS     r3,#3
000012  021b              LSLS     r3,r3,#8
000014  4019              ANDS     r1,r1,r3
000016  d00c              BEQ      |L18.50|
000018  39ff              SUBS     r1,r1,#0xff
00001a  3901              SUBS     r1,#1
00001c  d006              BEQ      |L18.44|
00001e  39ff              SUBS     r1,r1,#0xff
000020  3901              SUBS     r1,#1
000022  d00e              BEQ      |L18.66|
000024  39ff              SUBS     r1,r1,#0xff
000026  3901              SUBS     r1,#1
000028  d10d              BNE      |L18.70|
00002a  e006              B        |L18.58|
                  |L18.44|
;;;617            {
;;;618    #if defined(SC32R803) ||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)
;;;619            case RCC_SYSCLKSource_HXT:   /* HXT used as system clock source */
;;;620                RCC_Clocks->SYSCLK_Frequency = HXT_VALUE;
00002c  4915              LDR      r1,|L18.132|
00002e  6001              STR      r1,[r0,#0]
;;;621                break;
000030  e009              B        |L18.70|
                  |L18.50|
;;;622    #endif
;;;623            case RCC_SYSCLKSource_LIRC:   /* LIRC used as system clock source */
;;;624                RCC_Clocks->SYSCLK_Frequency = LIRC_VALUE;
000032  217d              MOVS     r1,#0x7d
000034  0209              LSLS     r1,r1,#8
000036  6001              STR      r1,[r0,#0]
;;;625                break;
000038  e005              B        |L18.70|
                  |L18.58|
;;;626            case RCC_SYSCLKSource_LXT:   /* LXT used as system clock source */
;;;627                RCC_Clocks->SYSCLK_Frequency = LXT_VALUE;
00003a  2101              MOVS     r1,#1
00003c  03c9              LSLS     r1,r1,#15
00003e  6001              STR      r1,[r0,#0]
;;;628                break;
000040  e001              B        |L18.70|
                  |L18.66|
;;;629    #if defined(SC32R803) ||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)||defined(SC32f15xx)||defined(SC32R601)
;;;630            case RCC_SYSCLKSource_HIRC:   /* HIRC used as system clock source */
;;;631                RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE;
000042  4911              LDR      r1,|L18.136|
000044  6001              STR      r1,[r0,#0]
                  |L18.70|
;;;632                break;
;;;633    #elif defined(SC32f10xx)
;;;634            case RCC_SYSCLKSource_PLLRCLK:   /* PLL used as system clock source */
;;;635                if ( ( RCC->PLL_CFG & PLL_CFG_PLLCLKSEL ) == RESET ) /* HXT used as PLL clock source */
;;;636                {
;;;637                    pllsource = HIRC_VALUE;
;;;638                }
;;;639                else   /* HIRC used as PLL clock source */
;;;640                {
;;;641                    pllsource = HXT_VALUE;
;;;642                }
;;;643    
;;;644                pllm = ( ( RCC->PLL_CFG & PLL_CFG_MDIVM ) >> PLL_CFG_MDIVM_Pos );
;;;645                plln = ( ( RCC->PLL_CFG & PLL_CFG_NDIVN ) >> PLL_CFG_NDIVN_Pos );
;;;646                pllp = ( ( RCC->PLL_CFG & PLL_CFG_PDIVP ) >> PLL_CFG_PDIVP_Pos );
;;;647    
;;;648                RCC_Clocks->SYSCLK_Frequency = ( ( ( pllsource / pllm ) * plln ) >> ( pllp + 1 ) );
;;;649                break;
;;;650    #endif
;;;651            }
;;;652        }
;;;653    
;;;654        /* Get AHB source -------------------------------------------------------*/
;;;655        tmp = ( ( RCCAHB->AHB_CFG & AHB_CFG_CLKDIV ) >> AHB_CFG_CLKDIV_Pos );
000046  6811              LDR      r1,[r2,#0]
000048  0249              LSLS     r1,r1,#9
00004a  0f4a              LSRS     r2,r1,#29
;;;656        RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> tmp;
00004c  6801              LDR      r1,[r0,#0]
00004e  40d1              LSRS     r1,r1,r2
000050  6041              STR      r1,[r0,#4]
;;;657    
;;;658        /* Get APB source -------------------------------------------------------*/
;;;659        tmp = ( ( RCCAPB0->APB0_CFG & APB0_CFG_CLKDIV ) >> APB0_CFG_CLKDIV_Pos );
000052  4a0e              LDR      r2,|L18.140|
000054  6812              LDR      r2,[r2,#0]
000056  0252              LSLS     r2,r2,#9
000058  0f52              LSRS     r2,r2,#29
;;;660        RCC_Clocks->PCLK0_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
00005a  460b              MOV      r3,r1
00005c  40d3              LSRS     r3,r3,r2
00005e  6083              STR      r3,[r0,#8]
;;;661    
;;;662        /* Get AHB source -------------------------------------------------------*/
;;;663        tmp = ( ( RCCAPB1->APB1_CFG & APB1_CFG_CLKDIV ) >> APB1_CFG_CLKDIV_Pos );
000060  4a0b              LDR      r2,|L18.144|
000062  6812              LDR      r2,[r2,#0]
000064  0252              LSLS     r2,r2,#9
000066  0f52              LSRS     r2,r2,#29
;;;664        RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
000068  460b              MOV      r3,r1
00006a  40d3              LSRS     r3,r3,r2
00006c  60c3              STR      r3,[r0,#0xc]
;;;665    
;;;666        /* Get AHB source -------------------------------------------------------*/
;;;667        tmp = ( ( RCCAPB2->APB2_CFG & APB2_CFG_CLKDIV ) >> APB2_CFG_CLKDIV_Pos );
00006e  4a09              LDR      r2,|L18.148|
000070  6812              LDR      r2,[r2,#0]
000072  0252              LSLS     r2,r2,#9
000074  0f52              LSRS     r2,r2,#29
;;;668        RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
000076  40d1              LSRS     r1,r1,r2
000078  6101              STR      r1,[r0,#0x10]
;;;669    }
00007a  4770              BX       lr
;;;670    
                          ENDP

                  |L18.124|
                          DCD      0x40003000
                  |L18.128|
                          DCD      0x01e84800
                  |L18.132|
                          DCD      0x00f42400
                  |L18.136|
                          DCD      0x03d09000
                  |L18.140|
                          DCD      0x40020000
                  |L18.144|
                          DCD      0x40021000
                  |L18.148|
                          DCD      0x40022000

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1229    */
;;;1230   FlagStatus RCC_GetFlagStatus ( uint32_t RCC_FLAG )
000000  4903              LDR      r1,|L19.16|
;;;1231   {
;;;1232       /* Check the parameters */
;;;1233       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1234   
;;;1235       if( ( RCC->RCC_STS & RCC_FLAG ) != ( uint32_t ) RESET )
000002  6a09              LDR      r1,[r1,#0x20]
000004  4201              TST      r1,r0
000006  d001              BEQ      |L19.12|
;;;1236       {
;;;1237           return ( SET );
000008  2001              MOVS     r0,#1
;;;1238       }
;;;1239       return ( RESET );
;;;1240   }
00000a  4770              BX       lr
                  |L19.12|
00000c  2000              MOVS     r0,#0                 ;1239
00000e  4770              BX       lr
;;;1241   
                          ENDP

                  |L19.16|
                          DCD      0x40003000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;490      */
;;;491    RCC_SYSCLKSource_TypeDef RCC_GetSYSCLKSource ( void )
000000  4805              LDR      r0,|L20.24|
;;;492    {
;;;493        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000002  6941              LDR      r1,[r0,#0x14]
000004  0609              LSLS     r1,r1,#24
000006  d504              BPL      |L20.18|
;;;494        {
;;;495            return ( ( RCC_SYSCLKSource_TypeDef ) ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL ) );
000008  6940              LDR      r0,[r0,#0x14]
00000a  2103              MOVS     r1,#3
00000c  0209              LSLS     r1,r1,#8
00000e  4008              ANDS     r0,r0,r1
;;;496        }
;;;497        else
;;;498        {
;;;499    #if defined (SC32f10xx)
;;;500            return RCC_SYSCLKSource_HIRC;
;;;501    #elif defined (SC32R803) || defined(SC32f12xx) || defined(SC32R805) || defined(SC32R806) || defined (SC32f15xx)||defined(SC32R601)
;;;502            return RCC_SYSCLKSource_HIRC_2;
;;;503    #endif
;;;504        }
;;;505    
;;;506    }
000010  4770              BX       lr
                  |L20.18|
000012  4802              LDR      r0,|L20.28|
000014  4770              BX       lr
;;;507    
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      0x40003000
                  |L20.28|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;517     */
;;;518    void RCC_HCLKConfig ( RCC_HCLK_TypeDef RCC_HCLK )
000000  4904              LDR      r1,|L21.20|
;;;519    {
;;;520        /* Check the parameters */
;;;521        assert_param ( IS_RCC_HCLK ( RCC_HCLK ) );
;;;522    
;;;523        RCCAHB->AHB_CFG &= ( uint32_t ) ~ ( AHB_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;524        RCCAHB->AHB_CFG |= RCC_HCLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;525    }
000012  4770              BX       lr
;;;526    
                          ENDP

                  |L21.20|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCCmd PROC
;;;134      */
;;;135    void RCC_HIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;136    {
000002  4602              MOV      r2,r0
;;;137        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;138        if ( NewState != DISABLE )
;;;139        {
;;;140            /* Enable the selected HIRC peripheral */
;;;141            RCC->RCC_CFG0 |= RCC_CFG0_HIRCEN;
00000a  4906              LDR      r1,|L22.36|
00000c  2340              MOVS     r3,#0x40
00000e  2a00              CMP      r2,#0                 ;138
000010  d003              BEQ      |L22.26|
000012  6948              LDR      r0,[r1,#0x14]
000014  4318              ORRS     r0,r0,r3
000016  6148              STR      r0,[r1,#0x14]
;;;142        }
;;;143        else
;;;144        {
;;;145            /* Disable the selected HIRC peripheral */
;;;146            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCEN );
;;;147        }
;;;148    }
000018  bd00              POP      {pc}
                  |L22.26|
00001a  6948              LDR      r0,[r1,#0x14]         ;146
00001c  4398              BICS     r0,r0,r3              ;146
00001e  6148              STR      r0,[r1,#0x14]         ;146
000020  bd00              POP      {pc}
;;;149    
                          ENDP

000022  0000              DCW      0x0000
                  |L22.36|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCDIV1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCDIV1Cmd PROC
;;;251    
;;;252    void RCC_HIRCDIV1Cmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;253    {
000002  4602              MOV      r2,r0
;;;254        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;255        if ( NewState != DISABLE )
;;;256        {
;;;257            /* Enable the selected HIRCDIV1 peripheral */
;;;258            RCC->RCC_CFG0 |= RCC_CFG0_HIRCDIV1;
00000a  4906              LDR      r1,|L23.36|
00000c  140b              ASRS     r3,r1,#16
00000e  2a00              CMP      r2,#0                 ;255
000010  d003              BEQ      |L23.26|
000012  6948              LDR      r0,[r1,#0x14]
000014  4318              ORRS     r0,r0,r3
000016  6148              STR      r0,[r1,#0x14]
;;;259        }
;;;260        else
;;;261        {
;;;262            /* Disable the selected HIRCDIV1 peripheral */
;;;263            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCDIV1 );
;;;264        }
;;;265    }
000018  bd00              POP      {pc}
                  |L23.26|
00001a  6948              LDR      r0,[r1,#0x14]         ;263
00001c  4398              BICS     r0,r0,r3              ;263
00001e  6148              STR      r0,[r1,#0x14]         ;263
000020  bd00              POP      {pc}
;;;266    #endif
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      0x40003000

                          AREA ||i.RCC_HXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_HXTCmd PROC
;;;112      */
;;;113    void RCC_HXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;114    {
000002  4602              MOV      r2,r0
;;;115        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;116        if ( NewState != DISABLE )
;;;117        {
;;;118            /* Enable the selected HXT peripheral */
;;;119            RCC->RCC_CFG0 |= RCC_CFG0_HXTEN;
00000a  4906              LDR      r1,|L24.36|
00000c  2320              MOVS     r3,#0x20
00000e  2a00              CMP      r2,#0                 ;116
000010  d003              BEQ      |L24.26|
000012  6948              LDR      r0,[r1,#0x14]
000014  4318              ORRS     r0,r0,r3
000016  6148              STR      r0,[r1,#0x14]
;;;120        }
;;;121        else
;;;122        {
;;;123            /* Disable the selected HXT peripheral */
;;;124            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HXTEN );
;;;125        }
;;;126    }
000018  bd00              POP      {pc}
                  |L24.26|
00001a  6948              LDR      r0,[r1,#0x14]         ;124
00001c  4398              BICS     r0,r0,r3              ;124
00001e  6148              STR      r0,[r1,#0x14]         ;124
000020  bd00              POP      {pc}
;;;127    #endif
                          ENDP

000022  0000              DCW      0x0000
                  |L24.36|
                          DCD      0x40003000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1200     */
;;;1201   void RCC_ITConfig ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;1202   {
000002  4602              MOV      r2,r0
;;;1203       RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;1204       if ( NewState != DISABLE )
;;;1205       {
;;;1206           RCC->RCC_CFG0 |= RCC_CFG0_INTEN;
00000a  4906              LDR      r1,|L25.36|
00000c  13cb              ASRS     r3,r1,#15
00000e  2a00              CMP      r2,#0                 ;1204
000010  d003              BEQ      |L25.26|
000012  6948              LDR      r0,[r1,#0x14]
000014  4318              ORRS     r0,r0,r3
000016  6148              STR      r0,[r1,#0x14]
;;;1207       }
;;;1208       else
;;;1209       {
;;;1210           RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_INTEN );
;;;1211       }
;;;1212   }
000018  bd00              POP      {pc}
                  |L25.26|
00001a  6948              LDR      r0,[r1,#0x14]         ;1210
00001c  4398              BICS     r0,r0,r3              ;1210
00001e  6148              STR      r0,[r1,#0x14]         ;1210
000020  bd00              POP      {pc}
;;;1213   
                          ENDP

000022  0000              DCW      0x0000
                  |L25.36|
                          DCD      0x40003000

                          AREA ||i.RCC_LCDLEDCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_LCDLEDCLKConfig PROC
;;;726     */
;;;727    void RCC_LCDLEDCLKConfig ( RCC_LCDLEDCLKSource_TypeDef RCC_LCDLEDCLKSource )
000000  b500              PUSH     {lr}
;;;728    {
000002  4603              MOV      r3,r0
;;;729        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;730        /* Check the parameters */
;;;731        assert_param ( RCC_LCDLEDCLKSOURCE ( RCC_LCDLEDCLKSource ) );
;;;732    
;;;733        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_LCDCLKSEL );
00000a  4904              LDR      r1,|L26.28|
00000c  698a              LDR      r2,[r1,#0x18]
00000e  2002              MOVS     r0,#2
000010  4382              BICS     r2,r2,r0
000012  618a              STR      r2,[r1,#0x18]
;;;734        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_LCDLEDCLKSource );
000014  698a              LDR      r2,[r1,#0x18]
000016  431a              ORRS     r2,r2,r3
000018  618a              STR      r2,[r1,#0x18]
;;;735    }
00001a  bd00              POP      {pc}
;;;736    #endif
                          ENDP

                  |L26.28|
                          DCD      0x40003000

                          AREA ||i.RCC_LIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_LIRCCmd PROC
;;;178      */
;;;179    void RCC_LIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;180    {
000002  4602              MOV      r2,r0
;;;181        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;182        if ( NewState != DISABLE )
;;;183        {
;;;184            /* Enable the selected LIRC peripheral */
;;;185            RCC->RCC_CFG0 |= RCC_CFG0_LIRCEN;
00000a  4906              LDR      r1,|L27.36|
00000c  2302              MOVS     r3,#2
00000e  2a00              CMP      r2,#0                 ;182
000010  d003              BEQ      |L27.26|
000012  6948              LDR      r0,[r1,#0x14]
000014  4318              ORRS     r0,r0,r3
000016  6148              STR      r0,[r1,#0x14]
;;;186        }
;;;187        else
;;;188        {
;;;189            /* Disable the selected LIRC peripheral */
;;;190            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LIRCEN );
;;;191        }
;;;192    }
000018  bd00              POP      {pc}
                  |L27.26|
00001a  6948              LDR      r0,[r1,#0x14]         ;190
00001c  4398              BICS     r0,r0,r3              ;190
00001e  6148              STR      r0,[r1,#0x14]         ;190
000020  bd00              POP      {pc}
;;;193    
                          ENDP

000022  0000              DCW      0x0000
                  |L27.36|
                          DCD      0x40003000

                          AREA ||i.RCC_LXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_LXTCmd PROC
;;;156      */
;;;157    void RCC_LXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;158    {
000002  4602              MOV      r2,r0
;;;159        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;160        if ( NewState != DISABLE )
;;;161        {
;;;162            /* Enable the selected LXT peripheral */
;;;163            RCC->RCC_CFG0 |= RCC_CFG0_LXTEN;
00000a  4906              LDR      r1,|L28.36|
00000c  2a00              CMP      r2,#0                 ;160
00000e  d004              BEQ      |L28.26|
000010  6948              LDR      r0,[r1,#0x14]
000012  2201              MOVS     r2,#1
000014  4310              ORRS     r0,r0,r2
000016  6148              STR      r0,[r1,#0x14]
;;;164        }
;;;165        else
;;;166        {
;;;167            /* Disable the selected LXT peripheral */
;;;168            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LXTEN );
;;;169        }
;;;170    }
000018  bd00              POP      {pc}
                  |L28.26|
00001a  6948              LDR      r0,[r1,#0x14]         ;168
00001c  0840              LSRS     r0,r0,#1              ;168
00001e  0040              LSLS     r0,r0,#1              ;168
000020  6148              STR      r0,[r1,#0x14]         ;168
000022  bd00              POP      {pc}
;;;171    
                          ENDP

                  |L28.36|
                          DCD      0x40003000

                          AREA ||i.RCC_NMICmd||, CODE, READONLY, ALIGN=2

                  RCC_NMICmd PROC
;;;1065    */
;;;1066   void RCC_NMICmd ( uint32_t RCC_NMIPeriph, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;1067   {
;;;1068       uint32_t temp;
;;;1069       /* Check the parameters */
;;;1070       assert_param ( IS_RCC_NMIPeriph ( RCC_NMIPeriph ) );
;;;1071   
;;;1072       temp = RCC->NMI_CFG;
000002  4b06              LDR      r3,|L29.28|
000004  6ada              LDR      r2,[r3,#0x2c]
;;;1073   
;;;1074       temp &= ( ~RCC_NMIPeriph );
000006  4382              BICS     r2,r2,r0
;;;1075   
;;;1076       if ( NewState != DISABLE )
;;;1077       {
;;;1078           temp |= 0xA05F0000 | RCC_NMIPeriph;
000008  4c05              LDR      r4,|L29.32|
00000a  2900              CMP      r1,#0                 ;1076
00000c  d002              BEQ      |L29.20|
00000e  4302              ORRS     r2,r2,r0
000010  4322              ORRS     r2,r2,r4
000012  e000              B        |L29.22|
                  |L29.20|
;;;1079       }
;;;1080       else
;;;1081       {
;;;1082           temp |= 0xA05F0000;
000014  4322              ORRS     r2,r2,r4
                  |L29.22|
;;;1083       }
;;;1084       RCC->NMI_CFG = temp;
000016  62da              STR      r2,[r3,#0x2c]
;;;1085   }
000018  bd10              POP      {r4,pc}
;;;1086   /* End of RCC_Group3.	*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L29.28|
                          DCD      0x40003000
                  |L29.32|
                          DCD      0xa05f0000

                          AREA ||i.RCC_PWM0CLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_PWM0CLKConfig PROC
;;;708     */
;;;709    void RCC_PWM0CLKConfig ( RCC_PWM0CLKSource_TypeDef RCC_PWM0CLKSource )
000000  b500              PUSH     {lr}
;;;710    {
000002  4603              MOV      r3,r0
;;;711        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;712        /* Check the parameters */
;;;713        assert_param ( RCC_PWM0CLKSOURCE ( RCC_PWM0CLKSource ) );
;;;714    
;;;715        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_PWM0CLKSEL );
00000a  4904              LDR      r1,|L30.28|
00000c  698a              LDR      r2,[r1,#0x18]
00000e  2004              MOVS     r0,#4
000010  4382              BICS     r2,r2,r0
000012  618a              STR      r2,[r1,#0x18]
;;;716        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_PWM0CLKSource );
000014  698a              LDR      r2,[r1,#0x18]
000016  431a              ORRS     r2,r2,r3
000018  618a              STR      r2,[r1,#0x18]
;;;717    }
00001a  bd00              POP      {pc}
;;;718    #endif
                          ENDP

                  |L30.28|
                          DCD      0x40003000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;391     */
;;;392    ErrorStatus RCC_SYSCLKConfig ( RCC_SYSCLKSource_TypeDef RCC_SYSCLKSource )
000000  b530              PUSH     {r4,r5,lr}
;;;393    {
000002  4603              MOV      r3,r0
;;;394        uint32_t tmpreg;
;;;395        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;396    
;;;397    
;;;398        /* Check the parameters */
;;;399        assert_param ( IS_RCC_SYSCLKSOURCE ( RCC_SYSCLKSource ) );
;;;400    	
;;;401    		tmpreg = RCC->RCC_CFG0;
00000a  4a1b              LDR      r2,|L31.120|
00000c  6950              LDR      r0,[r2,#0x14]
;;;402    	
;;;403    		tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
00000e  2403              MOVS     r4,#3
000010  0324              LSLS     r4,r4,#12
000012  43a0              BICS     r0,r0,r4
;;;404    	
;;;405    		tmpreg |= ( uint32_t ) RCC_WAIT_3;
000014  4320              ORRS     r0,r0,r4
;;;406    	
;;;407    		RCC->RCC_CFG0 = tmpreg;
000016  6150              STR      r0,[r2,#0x14]
;;;408    	
;;;409        if ( RCC_SYSCLKSource != ( ( uint16_t ) ( ~RCC_CFG0_SYSCLKSW ) ) )
000018  4818              LDR      r0,|L31.124|
;;;410        {
;;;411    		    RCC_Unlock ( 0xFF );
;;;412    				
;;;413            tmpreg = RCC->RCC_CFG0;
;;;414    
;;;415            tmpreg &= ( uint32_t ) ~ ( RCC_CFG0_SYSCLKSEL | RCC_CFG0_SYSCLKSW );
;;;416    
;;;417            tmpreg |= ( uint32_t ) RCC_SYSCLKSource;
;;;418    
;;;419            RCC->RCC_CFG0 = tmpreg;
;;;420    
;;;421            RCC->RCC_CFG0 |= RCC_CFG0_SYSCLKSW;
00001a  2580              MOVS     r5,#0x80
00001c  4283              CMP      r3,r0                 ;409
00001e  d01b              BEQ      |L31.88|
000020  20ff              MOVS     r0,#0xff              ;411
000022  f7fffffe          BL       RCC_Unlock
000026  6950              LDR      r0,[r2,#0x14]         ;413
000028  2107              MOVS     r1,#7                 ;415
00002a  01c9              LSLS     r1,r1,#7              ;415
00002c  4388              BICS     r0,r0,r1              ;415
00002e  4318              ORRS     r0,r0,r3              ;417
000030  6150              STR      r0,[r2,#0x14]         ;419
000032  6950              LDR      r0,[r2,#0x14]
000034  4328              ORRS     r0,r0,r5
000036  6150              STR      r0,[r2,#0x14]
;;;422    
;;;423            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000038  6950              LDR      r0,[r2,#0x14]
00003a  0600              LSLS     r0,r0,#24
00003c  d50a              BPL      |L31.84|
;;;424    				{
;;;425    #if defined(SC32R803)||defined(SC32f12xx)||defined(SC32R805) || defined(SC32R806)||defined(SC32f15xx)||defined(SC32R601)
;;;426    					if ( RCC_SYSCLKSource == RCC_SYSCLKSource_HIRC )
00003e  1fd8              SUBS     r0,r3,#7
000040  38ff              SUBS     r0,r0,#0xff
000042  38fa              SUBS     r0,r0,#0xfa
000044  d104              BNE      |L31.80|
;;;427    					{
;;;428    							tmpreg = RCC->RCC_CFG0;
000046  6950              LDR      r0,[r2,#0x14]
;;;429    							tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
000048  43a0              BICS     r0,r0,r4
;;;430    							tmpreg |= ( uint32_t ) RCC_WAIT_2;
00004a  01a9              LSLS     r1,r5,#6
00004c  4308              ORRS     r0,r0,r1
;;;431    							RCC->RCC_CFG0 = tmpreg;
00004e  6150              STR      r0,[r2,#0x14]
                  |L31.80|
;;;432    					}
;;;433    #elif defined(SC32f10xx)
;;;434    					uint32_t Multioperator = 1;
;;;435    					for ( int i = 1; i <= ((RCC->PLL_CFG &0x03) + 1 ); i++ )
;;;436    					{
;;;437    							Multioperator *=  2;
;;;438    					}
;;;439    					if ( ( ( 2 * ((RCC->PLL_CFG &0xFF00)>>8) ) / Multioperator ) >= 64 )
;;;440    					{
;;;441    							tmpreg = RCC->RCC_CFG0;
;;;442    							tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
;;;443    							tmpreg |= ( uint32_t ) RCC_WAIT_1;
;;;444    							RCC->RCC_CFG0 = tmpreg;
;;;445    					}
;;;446    #endif
;;;447    						return SUCCESS;
000050  2000              MOVS     r0,#0
;;;448    				}
;;;449                
;;;450            else
;;;451    				{
;;;452                return ERROR;
;;;453    				}
;;;454        }
;;;455        else
;;;456        {
;;;457    
;;;458            RCC->RCC_CFG0 &= ( uint32_t ) ~RCC_CFG0_SYSCLKSW;
;;;459    
;;;460            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
;;;461    				{
;;;462    						tmpreg = RCC->RCC_CFG0;
;;;463    						tmpreg &= ( uint32_t ) ~ RCC_CFG0_WAIT_Msk;
;;;464    						tmpreg |= ( uint32_t ) RCC_WAIT_1;
;;;465    						RCC->RCC_CFG0 = tmpreg;
;;;466    					
;;;467                return SUCCESS;
;;;468    				}
;;;469            else
;;;470    				{
;;;471                return ERROR;
;;;472    				}
;;;473        }
;;;474    }
000052  bd30              POP      {r4,r5,pc}
                  |L31.84|
000054  2001              MOVS     r0,#1                 ;452
000056  bd30              POP      {r4,r5,pc}
                  |L31.88|
000058  6950              LDR      r0,[r2,#0x14]         ;458
00005a  43a8              BICS     r0,r0,r5              ;458
00005c  6150              STR      r0,[r2,#0x14]         ;458
00005e  6950              LDR      r0,[r2,#0x14]         ;460
000060  0600              LSLS     r0,r0,#24             ;460
000062  d407              BMI      |L31.116|
000064  6950              LDR      r0,[r2,#0x14]         ;462
000066  43a0              BICS     r0,r0,r4              ;463
000068  2101              MOVS     r1,#1                 ;464
00006a  0309              LSLS     r1,r1,#12             ;464
00006c  4308              ORRS     r0,r0,r1              ;464
00006e  6150              STR      r0,[r2,#0x14]         ;465
000070  2000              MOVS     r0,#0                 ;467
000072  bd30              POP      {r4,r5,pc}
                  |L31.116|
000074  2001              MOVS     r0,#1                 ;471
000076  bd30              POP      {r4,r5,pc}
;;;475    
                          ENDP

                  |L31.120|
                          DCD      0x40003000
                  |L31.124|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_SystickCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SystickCLKConfig PROC
;;;1109    */
;;;1110   void RCC_SystickCLKConfig ( RCC_SysTickSource_TypeDef RCC_SysTickSource )
000000  b510              PUSH     {r4,lr}
;;;1111   {
000002  4602              MOV      r2,r0
;;;1112   
;;;1113       /* Check the parameters */
;;;1114       assert_param ( IS_RCC_SYSTICKSOURCE ( RCC_SysTickSource ) );
;;;1115   
;;;1116       if ( RCC_SysTickSource == RCC_SysTickSource_HCLK )
;;;1117       {
;;;1118           SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000004  4c0b              LDR      r4,|L32.52|
000006  2304              MOVS     r3,#4
000008  2a01              CMP      r2,#1                 ;1116
00000a  d00e              BEQ      |L32.42|
;;;1119       }
;;;1120       else
;;;1121       {
;;;1122           RCC_Unlock ( 0xFF );
00000c  20ff              MOVS     r0,#0xff
00000e  f7fffffe          BL       RCC_Unlock
;;;1123           SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
000012  6920              LDR      r0,[r4,#0x10]
000014  4398              BICS     r0,r0,r3
000016  6120              STR      r0,[r4,#0x10]
;;;1124           RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_STCLKSEL );
000018  4907              LDR      r1,|L32.56|
00001a  6988              LDR      r0,[r1,#0x18]
00001c  2360              MOVS     r3,#0x60
00001e  4398              BICS     r0,r0,r3
000020  6188              STR      r0,[r1,#0x18]
;;;1125           RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_SysTickSource );
000022  6988              LDR      r0,[r1,#0x18]
000024  4310              ORRS     r0,r0,r2
000026  6188              STR      r0,[r1,#0x18]
;;;1126       }
;;;1127   }
000028  bd10              POP      {r4,pc}
                  |L32.42|
00002a  6920              LDR      r0,[r4,#0x10]         ;1118
00002c  4318              ORRS     r0,r0,r3              ;1118
00002e  6120              STR      r0,[r4,#0x10]         ;1118
000030  bd10              POP      {r4,pc}
;;;1128   /**
                          ENDP

000032  0000              DCW      0x0000
                  |L32.52|
                          DCD      0xe000e000
                  |L32.56|
                          DCD      0x40003000

                          AREA ||i.RCC_SystickCmd||, CODE, READONLY, ALIGN=2

                  RCC_SystickCmd PROC
;;;1147     */
;;;1148   void RCC_SystickCmd ( FunctionalState NewState )
000000  4906              LDR      r1,|L33.28|
;;;1149   {
;;;1150       /* Check the parameters */
;;;1151       assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;1152   
;;;1153       if ( NewState != DISABLE )
000002  2800              CMP      r0,#0
000004  d004              BEQ      |L33.16|
;;;1154       {
;;;1155           SysTick->CTRL |= ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk ); /* Enable SysTick IRQ and SysTick Timer */
000006  6908              LDR      r0,[r1,#0x10]
000008  2203              MOVS     r2,#3
00000a  4310              ORRS     r0,r0,r2
00000c  6108              STR      r0,[r1,#0x10]
;;;1156       }
;;;1157       else
;;;1158       {
;;;1159           SysTick->CTRL &= ~ ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk );
;;;1160       }
;;;1161   }
00000e  4770              BX       lr
                  |L33.16|
000010  6908              LDR      r0,[r1,#0x10]         ;1159
000012  0880              LSRS     r0,r0,#2              ;1159
000014  0080              LSLS     r0,r0,#2              ;1159
000016  6108              STR      r0,[r1,#0x10]         ;1159
000018  4770              BX       lr
;;;1162   /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L33.28|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickGetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_SystickGetFlagStatus PROC
;;;1168    */
;;;1169   FlagStatus RCC_SystickGetFlagStatus ( void )
000000  4803              LDR      r0,|L34.16|
;;;1170   {
;;;1171       if ( ( SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk ) != ( uint32_t ) RESET )
000002  6900              LDR      r0,[r0,#0x10]
000004  03c0              LSLS     r0,r0,#15
000006  d501              BPL      |L34.12|
;;;1172       {
;;;1173           return ( SET );
000008  2001              MOVS     r0,#1
;;;1174       }
;;;1175       return ( RESET );
;;;1176   }
00000a  4770              BX       lr
                  |L34.12|
00000c  2000              MOVS     r0,#0                 ;1175
00000e  4770              BX       lr
;;;1177   /**
                          ENDP

                  |L34.16|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickSetCounter||, CODE, READONLY, ALIGN=2

                  RCC_SystickSetCounter PROC
;;;1132    */
;;;1133   void RCC_SystickSetCounter ( uint32_t Counter )
000000  4904              LDR      r1,|L35.20|
;;;1134   {
;;;1135       if ( ( Counter - 1UL ) <= SysTick_LOAD_RELOAD_Msk ) /* Reload value possible */
000002  1e40              SUBS     r0,r0,#1
000004  4288              CMP      r0,r1
000006  d803              BHI      |L35.16|
;;;1136       {
;;;1137           SysTick->LOAD = ( uint32_t ) ( Counter - 1UL ); /* set reload register */
000008  4903              LDR      r1,|L35.24|
00000a  6148              STR      r0,[r1,#0x14]
;;;1138           SysTick->VAL  = 0UL;   /* Load the SysTick Counter Value */
00000c  2000              MOVS     r0,#0
00000e  6188              STR      r0,[r1,#0x18]
                  |L35.16|
;;;1139       }
;;;1140   }
000010  4770              BX       lr
;;;1141   /**
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      0x00ffffff
                  |L35.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_Unlock||, CODE, READONLY, ALIGN=2

                  RCC_Unlock PROC
;;;92      */
;;;93     ErrorStatus RCC_Unlock ( uint8_t TimeLimit )
000000  2840              CMP      r0,#0x40
;;;94     {
000002  d303              BCC      |L36.12|
;;;95         if ( TimeLimit >= 0x40 )
;;;96         {
;;;97             RCC->RCC_KEY = TimeLimit;
000004  4902              LDR      r1,|L36.16|
000006  60c8              STR      r0,[r1,#0xc]
;;;98             return SUCCESS;
000008  2000              MOVS     r0,#0
;;;99         }
;;;100        else
;;;101        {
;;;102            return ERROR;
;;;103        }
;;;104    }
00000a  4770              BX       lr
                  |L36.12|
00000c  2001              MOVS     r0,#1                 ;102
00000e  4770              BX       lr
;;;105    #if !(defined(SC32f15xx)||defined(SC32R601))
                          ENDP

                  |L36.16|
                          DCD      0x40003000

                          AREA ||i.RCC_WaitConfig||, CODE, READONLY, ALIGN=2

                  RCC_WaitConfig PROC
;;;679     */
;;;680    void RCC_WaitConfig ( RCC_Wait_TypeDef RCC_Wait )
000000  b500              PUSH     {lr}
;;;681    {
000002  4603              MOV      r3,r0
;;;682        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;683        /* Check the parameters */
;;;684        assert_param ( IS_RCC_Wait ( RCC_Wait ) );
;;;685    
;;;686        RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
00000a  4905              LDR      r1,|L37.32|
00000c  694a              LDR      r2,[r1,#0x14]
00000e  2003              MOVS     r0,#3
000010  0300              LSLS     r0,r0,#12
000012  4382              BICS     r2,r2,r0
000014  614a              STR      r2,[r1,#0x14]
;;;687        RCC->RCC_CFG0 |= RCC_Wait;
000016  694a              LDR      r2,[r1,#0x14]
000018  431a              ORRS     r2,r2,r3
00001a  614a              STR      r2,[r1,#0x14]
;;;688    
;;;689    }
00001c  bd00              POP      {pc}
;;;690    /** @defgroup RCC_Group3 Peripheral clocks configuration functions
                          ENDP

00001e  0000              DCW      0x0000
                  |L37.32|
                          DCD      0x40003000

                          AREA ||i.SC_Delay||, CODE, READONLY, ALIGN=2

                  SC_Delay PROC
;;;1295     */
;;;1296   void SC_Delay(uint32_t ms_Delay)
000000  4a07              LDR      r2,|L38.32|
;;;1297   {
;;;1298   		uint32_t tickstart = uwTick;
000002  6811              LDR      r1,[r2,#0]  ; uwTick
;;;1299   		uint32_t tickend = tickstart + ms_Delay;
000004  1808              ADDS     r0,r1,r0
;;;1300   		if(tickend < tickstart)
000006  4288              CMP      r0,r1
000008  d206              BCS      |L38.24|
                  |L38.10|
;;;1301   		{
;;;1302   			while(uwTick >= tickstart || uwTick < tickend);
00000a  6813              LDR      r3,[r2,#0]  ; uwTick
00000c  428b              CMP      r3,r1
00000e  d2fc              BCS      |L38.10|
000010  6813              LDR      r3,[r2,#0]  ; uwTick
000012  4283              CMP      r3,r0
000014  d3f9              BCC      |L38.10|
;;;1303   		}
;;;1304   		else
;;;1305   		{
;;;1306   			while (uwTick < tickend);
;;;1307   		}
;;;1308   }
000016  4770              BX       lr
                  |L38.24|
000018  6811              LDR      r1,[r2,#0]            ;1306  ; uwTick
00001a  4281              CMP      r1,r0                 ;1306
00001c  d3fc              BCC      |L38.24|
00001e  4770              BX       lr
;;;1309   
                          ENDP

                  |L38.32|
                          DCD      ||.data||

                          AREA ||i.SC_Delay_us||, CODE, READONLY, ALIGN=2

                  SC_Delay_us PROC
;;;1325     */
;;;1326   void SC_Delay_us(uint32_t us_Delay,uint32_t Sys_freq)
000000  b510              PUSH     {r4,lr}
;;;1327   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1328   		if(us_Delay < SC_MAX_DELAY && us_Delay >= 10)
000006  4620              MOV      r0,r4
000008  380a              SUBS     r0,r0,#0xa
00000a  220b              MOVS     r2,#0xb
00000c  42d0              CMN      r0,r2
00000e  d20f              BCS      |L39.48|
;;;1329   		{
;;;1330   			SysTick->LOAD = ( uint32_t ) ((us_Delay-2)* (Sys_freq/1000000));
000010  4908              LDR      r1,|L39.52|
000012  4618              MOV      r0,r3
000014  f7fffffe          BL       __aeabi_uidivmod
000018  4601              MOV      r1,r0
00001a  1ea4              SUBS     r4,r4,#2
00001c  4806              LDR      r0,|L39.56|
00001e  4361              MULS     r1,r4,r1
000020  6141              STR      r1,[r0,#0x14]
;;;1331   			SysTick->VAL=0UL;
000022  2100              MOVS     r1,#0
000024  6181              STR      r1,[r0,#0x18]
;;;1332   			uint32_t tickstart = uwTick;
000026  4805              LDR      r0,|L39.60|
000028  6801              LDR      r1,[r0,#0]  ; uwTick
                  |L39.42|
;;;1333   			while(uwTick==tickstart);
00002a  6802              LDR      r2,[r0,#0]  ; uwTick
00002c  428a              CMP      r2,r1
00002e  d0fc              BEQ      |L39.42|
                  |L39.48|
;;;1334   		}
;;;1335   }
000030  bd10              POP      {r4,pc}
;;;1336   
                          ENDP

000032  0000              DCW      0x0000
                  |L39.52|
                          DCD      0x000f4240
                  |L39.56|
                          DCD      0xe000e000
                  |L39.60|
                          DCD      ||.data||

                          AREA ||i.SC_IncTick||, CODE, READONLY, ALIGN=2

                  SC_IncTick PROC
;;;1280     */
;;;1281   void SC_IncTick(void)
000000  4802              LDR      r0,|L40.12|
;;;1282   {
;;;1283     uwTick++;
000002  6801              LDR      r1,[r0,#0]  ; uwTick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; uwTick
;;;1284   }
000008  4770              BX       lr
;;;1285   
                          ENDP

00000a  0000              DCW      0x0000
                  |L40.12|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_rcc_c_49e27980____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH|
#line 478
|__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
